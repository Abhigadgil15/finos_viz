import 'core-js/modules/web.dom-collections.iterator.js';
import * as internal__default from '../../dist/esm/@finos/perspective-vieux/pkg/perspective_vieux.js';
import internal__default__default, { set_panic_hook } from '../../dist/esm/@finos/perspective-vieux/pkg/perspective_vieux.js';
import wasm_internal from '../../dist/esm/@finos/perspective-vieux/pkg/perspective_vieux_bg.wasm';
import 'core-js/modules/es.string.replace.js';
import { render, html, nothing } from 'lit-html';
import debounce from 'lodash/debounce';
import Awesomplete from 'awesomplete';
import * as perspective from '@finos/perspective/dist/esm/config/constants.js';
import { FILTER_OPERATORS, TYPE_AGGREGATES } from '@finos/perspective/dist/esm/config/constants.js';
import { get_type_config } from '@finos/perspective/dist/esm/config';
import 'core-js/modules/es.array.reduce.js';
import 'core-js/modules/es.promise.finally.js';
import 'core-js/modules/es.array.unscopables.flat-map.js';
import isEqual from 'lodash/isEqual';

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }

  return desc;
}

function _CustomElement() {
  return Reflect.construct(HTMLElement, [], this.__proto__.constructor);
}

Object.setPrototypeOf(_CustomElement.prototype, HTMLElement.prototype);
Object.setPrototypeOf(_CustomElement, HTMLElement);
const wasm = internal__default__default(wasm_internal).then(() => {
  set_panic_hook();
  return internal__default;
});
let _index = undefined;

async function _await_index(f) {
  await new Promise(setTimeout);

  if (!_index) {
    _index = await wasm;
  }

  return f();
} // function handle_view_errors(e) {
//     if (e.message !== "View is not initialized") {
//         throw e;
//     }
// }


class PerspectiveVieuxElement extends _CustomElement {
  constructor() {
    super();

    _await_index(() => {
      this._instance = new _index.PerspectiveVieuxElement(this);
    });
  }

  connectedCallback() {
    _await_index(() => {
      this._instance.connected_callback();
    });
  }

  load(table) {
    _await_index(() => this._instance.load(table));
  }

  set_view(view) {
    _await_index(() => this._instance.set_view(view));
  }

  delete_view() {
    return _await_index(() => this._instance.delete_view());
  }

  toggle_config(force) {
    return _await_index(() => this._instance.toggle_config(force));
  }

  _open_expression_editor(target) {
    return _await_index(() => this._instance._open_expression_editor(target));
  }

}

if (document.createElement("perspective-vieux").constructor === HTMLElement) {
  window.customElements.define("perspective-vieux", PerspectiveVieuxElement);
}

class PerspectiveColumnStyleElement extends _CustomElement {
  constructor() {
    super();
  }

  open(target, config, default_config) {
    _await_index(() => {
      if (this._instance) {
        this._instance.reset(config, default_config);
      } else {
        this._instance = new _index.PerspectiveColumnStyleElement(this, config, default_config);
      }

      this._instance.open(target);
    });
  }

}

if (document.createElement("perspective-column-style").constructor === HTMLElement) {
  window.customElements.define("perspective-column-style", PerspectiveColumnStyleElement);
}

require("core-js/modules/es.array.reduce.js");

require("core-js/modules/es.string.replace.js");

require("core-js/modules/web.dom-collections.iterator.js");

/*

Forked from https://github.com/timruffles/mobile-drag-drop/ v2.3.0-rc.2

Copyright (c) 2013 Tim Ruffles

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
const CLASS_PREFIX = "dnd-poly-";
const CLASS_DRAG_IMAGE = CLASS_PREFIX + "drag-image";
const CLASS_DRAG_IMAGE_SNAPBACK = CLASS_PREFIX + "snapback";
const CLASS_DRAG_OPERATION_ICON = CLASS_PREFIX + "icon";
const EVENT_PREFIX = "dnd-poly-";
const EVENT_DRAG_DRAGSTART_PENDING = EVENT_PREFIX + "dragstart-pending";
const EVENT_DRAG_DRAGSTART_CANCEL = EVENT_PREFIX + "dragstart-cancel";
const ALLOWED_EFFECTS = ["none", "copy", "copyLink", "copyMove", "link", "linkMove", "move", "all"];
const DROP_EFFECTS = ["none", "copy", "move", "link"];

function detectFeatures() {
  const features = {
    dragEvents: "ondragstart" in document.documentElement,
    draggable: "draggable" in document.documentElement,
    userAgentSupportingNativeDnD: undefined
  };
  const isBlinkEngine = !!window.chrome || /chrome/i.test(navigator.userAgent);
  features.userAgentSupportingNativeDnD = !(/iPad|iPhone|iPod|Android/.test(navigator.userAgent) || isBlinkEngine && "ontouchstart" in document.documentElement);
  return features;
}

function supportsPassiveEventListener() {
  let supportsPassiveEventListeners = false;

  try {
    const opts = Object.defineProperty({}, "passive", {
      get: function () {
        supportsPassiveEventListeners = true;
      }
    });
    window.addEventListener("test", null, opts);
  } catch (e) {}

  return supportsPassiveEventListeners;
}

const supportsPassive = supportsPassiveEventListener();

function isDOMElement(object) {
  return object && object.tagName;
}

function addDocumentListener(ev, handler, passive) {
  if (passive === void 0) {
    passive = true;
  }

  document.addEventListener(ev, handler, supportsPassive ? {
    passive: passive
  } : false);
}

function removeDocumentListener(ev, handler) {
  document.removeEventListener(ev, handler);
}

function onEvt(el, event, handler, capture) {
  if (capture === void 0) {
    capture = false;
  }

  const options = supportsPassive ? {
    passive: true,
    capture: capture
  } : capture;
  el.addEventListener(event, handler, options);
  return {
    off: function () {
      el.removeEventListener(event, handler, options);
    }
  };
}

function prepareNodeCopyAsDragImage(srcNode, dstNode) {
  if (srcNode.nodeType === 1) {
    const cs = getComputedStyle(srcNode);

    for (let i = 0; i < cs.length; i++) {
      const csName = cs[i];
      dstNode.style.setProperty(csName, cs.getPropertyValue(csName), cs.getPropertyPriority(csName));
    }

    dstNode.style.pointerEvents = "none";
    dstNode.removeAttribute("id");
    dstNode.removeAttribute("class");
    dstNode.removeAttribute("draggable");

    if (dstNode.nodeName === "CANVAS") {
      const canvasSrc = srcNode;
      const canvasDst = dstNode;
      const canvasSrcImgData = canvasSrc.getContext("2d").getImageData(0, 0, canvasSrc.width, canvasSrc.height);
      canvasDst.getContext("2d").putImageData(canvasSrcImgData, 0, 0);
    }
  }

  if (srcNode.hasChildNodes()) {
    for (let i = 0; i < srcNode.childNodes.length; i++) {
      prepareNodeCopyAsDragImage(srcNode.childNodes[i], dstNode.childNodes[i]);
    }
  }
}

function createDragImage(sourceNode) {
  const dragImage = sourceNode.cloneNode(true);
  prepareNodeCopyAsDragImage(sourceNode, dragImage);
  return dragImage;
}

function average(array) {
  if (array.length === 0) {
    return 0;
  }

  return array.reduce(function (s, v) {
    return v + s;
  }, 0) / array.length;
}

function isTouchIdentifierContainedInTouchEvent(touchEvent, touchIdentifier) {
  for (let i = 0; i < touchEvent.changedTouches.length; i++) {
    const touch = touchEvent.changedTouches[i];

    if (touch.identifier === touchIdentifier) {
      return true;
    }
  }

  return false;
}

function updateCentroidCoordinatesOfTouchesIn(coordinateProp, event, outPoint) {
  const pageXs = [],
        pageYs = [];

  for (let i = 0; i < event.touches.length; i++) {
    const touch = event.touches[i];
    pageXs.push(touch[coordinateProp + "X"]);
    pageYs.push(touch[coordinateProp + "Y"]);
  }

  outPoint.x = average(pageXs);
  outPoint.y = average(pageYs);
}

const TRANSFORM_CSS_VENDOR_PREFIXES = ["", "-webkit-"];

function extractTransformStyles(sourceNode) {
  return TRANSFORM_CSS_VENDOR_PREFIXES.map(function (prefix) {
    const transform = sourceNode.style[prefix + "transform"];

    if (!transform || transform === "none") {
      return "";
    }

    return transform.replace(/translate\(\D*\d+[^,]*,\D*\d+[^,]*\)\s*/g, "");
  });
}

function translateElementToPoint(element, pnt, originalTransforms, offset, centerOnCoordinates) {
  if (centerOnCoordinates === void 0) {
    centerOnCoordinates = true;
  }

  let x = pnt.x,
      y = pnt.y;

  if (offset) {
    x += offset.x;
    y += offset.y;
  }

  if (centerOnCoordinates) {
    x -= parseInt(element.offsetWidth, 10) / 2;
    y -= parseInt(element.offsetHeight, 10) / 2;
  }

  const translate = "translate3d(" + x + "px," + y + "px, 0)";

  for (let i = 0; i < TRANSFORM_CSS_VENDOR_PREFIXES.length; i++) {
    const transformProp = TRANSFORM_CSS_VENDOR_PREFIXES[i] + "transform";
    element.style[transformProp] = translate + " " + originalTransforms[i];
  }
}

function applyDragImageSnapback(sourceEl, dragImage, dragImageTransforms, transitionEndCb) {
  const cs = getComputedStyle(sourceEl);

  if (cs.visibility === "hidden" || cs.display === "none") {
    console.log("dnd-poly: source node is not visible. skipping snapback transition.");
    transitionEndCb();
    return;
  }

  dragImage.classList.add(CLASS_DRAG_IMAGE_SNAPBACK);
  const csDragImage = getComputedStyle(dragImage);
  const durationInS = parseFloat(csDragImage.transitionDuration);

  if (isNaN(durationInS) || durationInS === 0) {
    console.log("dnd-poly: no transition used - skipping snapback");
    transitionEndCb();
    return;
  }

  console.log("dnd-poly: starting dragimage snap back");
  const rect = sourceEl.getBoundingClientRect();
  const pnt = {
    x: rect.left,
    y: rect.top
  };
  pnt.x += document.body.scrollLeft || document.documentElement.scrollLeft;
  pnt.y += document.body.scrollTop || document.documentElement.scrollTop;
  pnt.x -= parseInt(cs.marginLeft, 10);
  pnt.y -= parseInt(cs.marginTop, 10);
  const delayInS = parseFloat(csDragImage.transitionDelay);
  const durationInMs = Math.round((durationInS + delayInS) * 1000);
  translateElementToPoint(dragImage, pnt, dragImageTransforms, undefined, false);
  setTimeout(transitionEndCb, durationInMs);
}

const DataTransfer = function () {
  function DataTransfer(_dataStore, _setDragImageHandler) {
    this._dataStore = _dataStore;
    this._setDragImageHandler = _setDragImageHandler;
    this._dropEffect = DROP_EFFECTS[0];
  }

  Object.defineProperty(DataTransfer.prototype, "dropEffect", {
    get: function () {
      return this._dropEffect;
    },
    set: function (value) {
      if (this._dataStore.mode !== 0 && ALLOWED_EFFECTS.indexOf(value) > -1) {
        this._dropEffect = value;
      }
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(DataTransfer.prototype, "types", {
    get: function () {
      if (this._dataStore.mode !== 0) {
        return Object.freeze(this._dataStore.types);
      }
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(DataTransfer.prototype, "effectAllowed", {
    get: function () {
      return this._dataStore.effectAllowed;
    },
    set: function (value) {
      if (this._dataStore.mode === 2 && ALLOWED_EFFECTS.indexOf(value) > -1) {
        this._dataStore.effectAllowed = value;
      }
    },
    enumerable: true,
    configurable: true
  });

  DataTransfer.prototype.setData = function (type, data) {
    if (this._dataStore.mode === 2) {
      if (type.indexOf(" ") > -1) {
        throw new Error("illegal arg: type contains space");
      }

      this._dataStore.data[type] = data;

      if (this._dataStore.types.indexOf(type) === -1) {
        this._dataStore.types.push(type);
      }
    }
  };

  DataTransfer.prototype.getData = function (type) {
    if (this._dataStore.mode === 1 || this._dataStore.mode === 2) {
      return this._dataStore.data[type] || "";
    }
  };

  DataTransfer.prototype.clearData = function (format) {
    if (this._dataStore.mode === 2) {
      if (format && this._dataStore.data[format]) {
        delete this._dataStore.data[format];

        const index = this._dataStore.types.indexOf(format);

        if (index > -1) {
          this._dataStore.types.splice(index, 1);
        }

        return;
      }

      this._dataStore.data = {};
      this._dataStore.types = [];
    }
  };

  DataTransfer.prototype.setDragImage = function (image, x, y) {
    if (this._dataStore.mode === 2) {
      this._setDragImageHandler(image, x, y);
    }
  };

  return DataTransfer;
}();

function tryFindDraggableTarget(event) {
  let el = event.target;

  do {
    if (el.draggable === false) {
      continue;
    }

    if (el.draggable === true) {
      return el;
    }

    if (el.getAttribute && el.getAttribute("draggable") === "true") {
      return el;
    }
  } while ((el = el.parentNode) && el !== document.body);
}

function determineDropEffect(effectAllowed, sourceNode) {
  if (!effectAllowed) {
    if (sourceNode.nodeType === 3 && sourceNode.tagName === "A") {
      return DROP_EFFECTS[3];
    }

    return DROP_EFFECTS[1];
  }

  if (effectAllowed === ALLOWED_EFFECTS[0]) {
    return DROP_EFFECTS[0];
  }

  if (effectAllowed.indexOf(ALLOWED_EFFECTS[1]) === 0 || effectAllowed === ALLOWED_EFFECTS[7]) {
    return DROP_EFFECTS[1];
  }

  if (effectAllowed.indexOf(ALLOWED_EFFECTS[4]) === 0) {
    return DROP_EFFECTS[3];
  }

  if (effectAllowed === ALLOWED_EFFECTS[6]) {
    return DROP_EFFECTS[2];
  }

  return DROP_EFFECTS[1];
}

function createDragEventFromTouch(targetElement, e, type, cancelable, window, dataTransfer, relatedTarget) {
  if (relatedTarget === void 0) {
    relatedTarget = null;
  }

  const touch = e.changedTouches[0];
  const dndEvent = new Event(type, {
    bubbles: true,
    cancelable: cancelable
  });
  dndEvent.dataTransfer = dataTransfer;
  dndEvent.relatedTarget = relatedTarget;
  dndEvent.screenX = touch.screenX;
  dndEvent.screenY = touch.screenY;
  dndEvent.clientX = touch.clientX;
  dndEvent.clientY = touch.clientY;
  dndEvent.pageX = touch.pageX;
  dndEvent.pageY = touch.pageY;
  const targetRect = targetElement.getBoundingClientRect();
  dndEvent.offsetX = dndEvent.clientX - targetRect.left;
  dndEvent.offsetY = dndEvent.clientY - targetRect.top;
  return dndEvent;
}

function dispatchDragEvent(dragEvent, targetElement, touchEvent, dataStore, dataTransfer, cancelable, relatedTarget) {
  if (cancelable === void 0) {
    cancelable = true;
  }

  if (relatedTarget === void 0) {
    relatedTarget = null;
  }

  console.log("dnd-poly: dispatching " + dragEvent);
  const leaveEvt = createDragEventFromTouch(targetElement, touchEvent, dragEvent, cancelable, document.defaultView, dataTransfer, relatedTarget);
  const cancelled = !targetElement.dispatchEvent(leaveEvt);
  dataStore.mode = 0;
  return cancelled;
}

function determineDragOperation(effectAllowed, dropEffect) {
  if (!effectAllowed || effectAllowed === ALLOWED_EFFECTS[7]) {
    return dropEffect;
  }

  if (dropEffect === DROP_EFFECTS[1]) {
    if (effectAllowed.indexOf(DROP_EFFECTS[1]) === 0) {
      return DROP_EFFECTS[1];
    }
  } else if (dropEffect === DROP_EFFECTS[3]) {
    if (effectAllowed.indexOf(DROP_EFFECTS[3]) === 0 || effectAllowed.indexOf("Link") > -1) {
      return DROP_EFFECTS[3];
    }
  } else if (dropEffect === DROP_EFFECTS[2]) {
    if (effectAllowed.indexOf(DROP_EFFECTS[2]) === 0 || effectAllowed.indexOf("Move") > -1) {
      return DROP_EFFECTS[2];
    }
  }

  return DROP_EFFECTS[0];
}

const DragOperationController = function () {
  function DragOperationController(_initialEvent, _config, _sourceNode, _dragOperationEndedCb) {
    this._initialEvent = _initialEvent;
    this._config = _config;
    this._sourceNode = _sourceNode;
    this._dragOperationEndedCb = _dragOperationEndedCb;
    this._dragOperationState = 0;
    this._immediateUserSelection = null;
    this._currentDropTarget = null;
    console.log("dnd-poly: setting up potential drag operation..");
    this._lastTouchEvent = _initialEvent;
    this._initialTouch = _initialEvent.changedTouches[0];
    this._touchMoveHandler = this._onTouchMove.bind(this);
    this._touchEndOrCancelHandler = this._onTouchEndOrCancel.bind(this);
    addDocumentListener("touchmove", this._touchMoveHandler, false);
    addDocumentListener("touchend", this._touchEndOrCancelHandler, false);
    addDocumentListener("touchcancel", this._touchEndOrCancelHandler, false);
  }

  DragOperationController.prototype._setup = function () {
    const _this = this;

    console.log("dnd-poly: starting drag and drop operation");
    this._dragOperationState = 1;
    this._currentDragOperation = DROP_EFFECTS[0];
    this._dragDataStore = {
      data: {},
      effectAllowed: undefined,
      mode: 3,
      types: []
    };
    this._currentHotspotCoordinates = {
      x: null,
      y: null
    };
    this._dragImagePageCoordinates = {
      x: null,
      y: null
    };
    let dragImageSrc = this._sourceNode;
    this._dataTransfer = new DataTransfer(this._dragDataStore, function (element, x, y) {
      dragImageSrc = element;

      if (typeof x === "number" || typeof y === "number") {
        _this._dragImageOffset = {
          x: x || 0,
          y: y || 0
        };
      }
    });
    this._dragDataStore.mode = 2;
    this._dataTransfer.dropEffect = DROP_EFFECTS[0];

    if (dispatchDragEvent("dragstart", this._sourceNode, this._lastTouchEvent, this._dragDataStore, this._dataTransfer)) {
      console.log("dnd-poly: dragstart cancelled");
      this._dragOperationState = 3;

      this._cleanup();

      return false;
    }

    updateCentroidCoordinatesOfTouchesIn("page", this._lastTouchEvent, this._dragImagePageCoordinates);

    const dragImage = this._config.dragImageSetup(dragImageSrc);

    this._dragImageTransforms = extractTransformStyles(dragImage);
    dragImage.style.position = "absolute";
    dragImage.style.left = "0px";
    dragImage.style.top = "0px";
    dragImage.style.zIndex = "999999";
    dragImage.classList.add(CLASS_DRAG_IMAGE);
    dragImage.classList.add(CLASS_DRAG_OPERATION_ICON);
    this._dragImage = dragImage;

    if (!this._dragImageOffset) {
      if (this._config.dragImageOffset) {
        this._dragImageOffset = {
          x: this._config.dragImageOffset.x,
          y: this._config.dragImageOffset.y
        };
      } else if (this._config.dragImageCenterOnTouch) {
        const cs = getComputedStyle(dragImageSrc);
        this._dragImageOffset = {
          x: 0 - parseInt(cs.marginLeft, 10),
          y: 0 - parseInt(cs.marginTop, 10)
        };
      } else {
        const targetRect = dragImageSrc.getBoundingClientRect();
        const cs = getComputedStyle(dragImageSrc);
        this._dragImageOffset = {
          x: targetRect.left - this._initialTouch.clientX - parseInt(cs.marginLeft, 10) + targetRect.width / 2,
          y: targetRect.top - this._initialTouch.clientY - parseInt(cs.marginTop, 10) + targetRect.height / 2
        };
      }
    }

    translateElementToPoint(this._dragImage, this._dragImagePageCoordinates, this._dragImageTransforms, this._dragImageOffset, this._config.dragImageCenterOnTouch);
    document.body.appendChild(this._dragImage);
    this._iterationIntervalId = window.setInterval(function () {
      if (_this._iterationLock) {
        console.log("dnd-poly: iteration skipped because previous iteration hast not yet finished.");
        return;
      }

      _this._iterationLock = true;

      _this._dragAndDropProcessModelIteration();

      _this._iterationLock = false;
    }, this._config.iterationInterval);
    return true;
  };

  DragOperationController.prototype._cleanup = function () {
    console.log("dnd-poly: cleanup");

    if (this._iterationIntervalId) {
      clearInterval(this._iterationIntervalId);
      this._iterationIntervalId = null;
    }

    removeDocumentListener("touchmove", this._touchMoveHandler);
    removeDocumentListener("touchend", this._touchEndOrCancelHandler);
    removeDocumentListener("touchcancel", this._touchEndOrCancelHandler);

    if (this._dragImage) {
      this._dragImage.parentNode.removeChild(this._dragImage);

      this._dragImage = null;
    }

    this._dragOperationEndedCb(this._config, this._lastTouchEvent, this._dragOperationState);
  };

  DragOperationController.prototype._onTouchMove = function (event) {
    const _this = this;

    if (isTouchIdentifierContainedInTouchEvent(event, this._initialTouch.identifier) === false) {
      return;
    }

    this._lastTouchEvent = event;

    if (this._dragOperationState === 0) {
      let startDrag = void 0;

      if (this._config.dragStartConditionOverride) {
        try {
          startDrag = this._config.dragStartConditionOverride(event);
        } catch (e) {
          console.error("dnd-poly: error in dragStartConditionOverride hook: " + e);
          startDrag = false;
        }
      } else {
        startDrag = event.touches.length === 1;
      }

      if (!startDrag) {
        this._cleanup();

        return;
      }

      if (this._setup() === true) {
        this._initialEvent.preventDefault();

        event.preventDefault();
      }

      return;
    }

    console.log("dnd-poly: moving draggable..");
    event.preventDefault();
    updateCentroidCoordinatesOfTouchesIn("client", event, this._currentHotspotCoordinates);
    updateCentroidCoordinatesOfTouchesIn("page", event, this._dragImagePageCoordinates);

    if (this._config.dragImageTranslateOverride) {
      try {
        let handledDragImageTranslate_1 = false;

        this._config.dragImageTranslateOverride(event, {
          x: this._currentHotspotCoordinates.x,
          y: this._currentHotspotCoordinates.y
        }, this._immediateUserSelection, function (offsetX, offsetY) {
          if (!_this._dragImage) {
            return;
          }

          handledDragImageTranslate_1 = true;
          _this._currentHotspotCoordinates.x += offsetX;
          _this._currentHotspotCoordinates.y += offsetY;
          _this._dragImagePageCoordinates.x += offsetX;
          _this._dragImagePageCoordinates.y += offsetY;
          translateElementToPoint(_this._dragImage, _this._dragImagePageCoordinates, _this._dragImageTransforms, _this._dragImageOffset, _this._config.dragImageCenterOnTouch);
        });

        if (handledDragImageTranslate_1) {
          return;
        }
      } catch (e) {
        console.log("dnd-poly: error in dragImageTranslateOverride hook: " + e);
      }
    }

    translateElementToPoint(this._dragImage, this._dragImagePageCoordinates, this._dragImageTransforms, this._dragImageOffset, this._config.dragImageCenterOnTouch);
  };

  DragOperationController.prototype._onTouchEndOrCancel = function (event) {
    if (isTouchIdentifierContainedInTouchEvent(event, this._initialTouch.identifier) === false) {
      return;
    }

    if (this._config.dragImageTranslateOverride) {
      try {
        this._config.dragImageTranslateOverride(undefined, undefined, undefined, function () {});
      } catch (e) {
        console.log("dnd-poly: error in dragImageTranslateOverride hook: " + e);
      }
    }

    if (this._dragOperationState === 0) {
      this._cleanup();

      return;
    }

    event.preventDefault();
    this._dragOperationState = event.type === "touchcancel" ? 3 : 2;
  };

  DragOperationController.prototype._dragAndDropProcessModelIteration = function () {
    const _this = this;

    const previousDragOperation = this._currentDragOperation;
    this._dragDataStore.mode = 3;
    this._dataTransfer.dropEffect = DROP_EFFECTS[0];
    const dragCancelled = dispatchDragEvent("drag", this._sourceNode, this._lastTouchEvent, this._dragDataStore, this._dataTransfer);

    if (dragCancelled) {
      console.log("dnd-poly: drag event cancelled.");
      this._currentDragOperation = DROP_EFFECTS[0];
    }

    if (dragCancelled || this._dragOperationState === 2 || this._dragOperationState === 3) {
      const dragFailed = this._dragOperationEnded(this._dragOperationState);

      if (dragFailed) {
        applyDragImageSnapback(this._sourceNode, this._dragImage, this._dragImageTransforms, function () {
          _this._finishDragOperation();
        });
        return;
      }

      this._finishDragOperation();

      return;
    }

    const newUserSelection = this._config.elementFromPoint(this._currentHotspotCoordinates.x, this._currentHotspotCoordinates.y);

    console.log("dnd-poly: new immediate user selection is: " + newUserSelection);
    const previousTargetElement = this._currentDropTarget;

    if (newUserSelection !== this._immediateUserSelection && newUserSelection !== this._currentDropTarget) {
      this._immediateUserSelection = newUserSelection;

      if (this._currentDropTarget !== null) {
        this._dragDataStore.mode = 3;
        this._dataTransfer.dropEffect = DROP_EFFECTS[0];
        dispatchDragEvent("dragexit", this._currentDropTarget, this._lastTouchEvent, this._dragDataStore, this._dataTransfer, false);
      }

      if (this._immediateUserSelection === null) {
        this._currentDropTarget = this._immediateUserSelection;
        console.log("dnd-poly: current drop target changed to null");
      } else {
        this._dragDataStore.mode = 3;
        this._dataTransfer.dropEffect = determineDropEffect(this._dragDataStore.effectAllowed, this._sourceNode);

        if (dispatchDragEvent("dragenter", this._immediateUserSelection, this._lastTouchEvent, this._dragDataStore, this._dataTransfer)) {
          console.log("dnd-poly: dragenter default prevented");
          this._currentDropTarget = this._immediateUserSelection;
          this._currentDragOperation = determineDragOperation(this._dataTransfer.effectAllowed, this._dataTransfer.dropEffect);
        } else {
          if (this._immediateUserSelection !== document.body) {
            this._currentDropTarget = document.body;
          }
        }
      }
    }

    if (previousTargetElement !== this._currentDropTarget && isDOMElement(previousTargetElement)) {
      console.log("dnd-poly: current drop target changed.");
      this._dragDataStore.mode = 3;
      this._dataTransfer.dropEffect = DROP_EFFECTS[0];
      dispatchDragEvent("dragleave", previousTargetElement, this._lastTouchEvent, this._dragDataStore, this._dataTransfer, false, this._currentDropTarget);
    }

    if (isDOMElement(this._currentDropTarget)) {
      this._dragDataStore.mode = 3;
      this._dataTransfer.dropEffect = determineDropEffect(this._dragDataStore.effectAllowed, this._sourceNode);

      if (dispatchDragEvent("dragover", this._currentDropTarget, this._lastTouchEvent, this._dragDataStore, this._dataTransfer) === false) {
        console.log("dnd-poly: dragover not prevented on possible drop-target.");
        this._currentDragOperation = DROP_EFFECTS[0];
      } else {
        console.log("dnd-poly: dragover prevented.");
        this._currentDragOperation = determineDragOperation(this._dataTransfer.effectAllowed, this._dataTransfer.dropEffect);
      }
    }

    console.log("dnd-poly: d'n'd iteration ended. current drag operation: " + this._currentDragOperation);

    if (previousDragOperation !== this._currentDragOperation) {
      this._dragImage.classList.remove(CLASS_PREFIX + previousDragOperation);
    }

    const currentDragOperationClass = CLASS_PREFIX + this._currentDragOperation;

    this._dragImage.classList.add(currentDragOperationClass);
  };

  DragOperationController.prototype._dragOperationEnded = function (state) {
    console.log("dnd-poly: drag operation end detected with " + this._currentDragOperation);
    const dragFailed = this._currentDragOperation === DROP_EFFECTS[0] || this._currentDropTarget === null || state === 3;

    if (dragFailed) {
      if (isDOMElement(this._currentDropTarget)) {
        this._dragDataStore.mode = 3;
        this._dataTransfer.dropEffect = DROP_EFFECTS[0];
        dispatchDragEvent("dragleave", this._currentDropTarget, this._lastTouchEvent, this._dragDataStore, this._dataTransfer, false);
      }
    } else {
      if (isDOMElement(this._currentDropTarget)) {
        this._dragDataStore.mode = 1;
        this._dataTransfer.dropEffect = this._currentDragOperation;

        if (dispatchDragEvent("drop", this._currentDropTarget, this._lastTouchEvent, this._dragDataStore, this._dataTransfer) === true) {
          this._currentDragOperation = this._dataTransfer.dropEffect;
        } else {
          this._currentDragOperation = DROP_EFFECTS[0];
        }
      }
    }

    return dragFailed;
  };

  DragOperationController.prototype._finishDragOperation = function () {
    console.log("dnd-poly: dragimage snap back transition ended");
    this._dragDataStore.mode = 3;
    this._dataTransfer.dropEffect = this._currentDragOperation;
    dispatchDragEvent("dragend", this._sourceNode, this._lastTouchEvent, this._dragDataStore, this._dataTransfer, false);
    this._dragOperationState = 2;

    this._cleanup();
  };

  return DragOperationController;
}();

const config = {
  iterationInterval: 150,
  tryFindDraggableTarget: tryFindDraggableTarget,
  dragImageSetup: createDragImage,
  elementFromPoint: function (x, y) {
    return document.elementFromPoint(x, y);
  }
};
let activeDragOperation;

function onTouchstart(e, composePath) {
  console.log("dnd-poly: global touchstart");

  if (activeDragOperation) {
    console.log("dnd-poly: drag operation already active");
    return;
  }

  const dragTarget = config.tryFindDraggableTarget(e, composePath);

  if (!dragTarget) {
    console.log("dnd-poly: no draggable at touchstart coordinates");
    return;
  }

  try {
    activeDragOperation = new DragOperationController(e, config, dragTarget, dragOperationEnded);
  } catch (err) {
    dragOperationEnded(config, e, 3);
    throw err;
  }
}

function onDelayTouchstart(evt) {
  console.log("dnd-poly: setup delayed dragstart..");
  const el = evt.target;
  const composePath = evt.composedPath();

  const heldItem = function () {
    console.log("dnd-poly: starting delayed drag..");
    end.off();
    cancel.off();
    move.off();
    scroll.off();
    onTouchstart(evt, composePath);
  };

  const onReleasedItem = function (event) {
    console.log("dnd-poly: aborting delayed drag because of " + event.type);
    end.off();
    cancel.off();
    move.off();
    scroll.off();

    if (el) {
      el.dispatchEvent(new CustomEvent(EVENT_DRAG_DRAGSTART_CANCEL, {
        bubbles: true,
        cancelable: true
      }));
    }

    clearTimeout(timer);
  };

  if (el) {
    el.dispatchEvent(new CustomEvent(EVENT_DRAG_DRAGSTART_PENDING, {
      bubbles: true,
      cancelable: true
    }));
  }

  const timer = window.setTimeout(heldItem, config.holdToDrag);
  const end = onEvt(el, "touchend", onReleasedItem);
  const cancel = onEvt(el, "touchcancel", onReleasedItem);
  const move = onEvt(el, "touchmove", onReleasedItem);
  const scroll = onEvt(window, "scroll", onReleasedItem, true);
}

function dragOperationEnded(_config, event, state) {
  if (state === 0) {
    console.log("dnd-poly: Drag never started. Last event was " + event.type);

    if (_config.defaultActionOverride) {
      try {
        _config.defaultActionOverride(event);

        if (event.defaultPrevented) {
          console.log("dnd-poly: defaultActionOverride has taken care of triggering the default action. preventing default on original event");
        }
      } catch (e) {
        console.log("dnd-poly: error in defaultActionOverride: " + e);
      }
    }
  }

  activeDragOperation = null;
}

function polyfill(override) {
  if (override) {
    Object.keys(override).forEach(function (key) {
      config[key] = override[key];
    });
  }

  if (!config.forceApply) {
    const detectedFeatures = detectFeatures();

    if (detectedFeatures.userAgentSupportingNativeDnD && detectedFeatures.draggable && detectedFeatures.dragEvents) {
      return false;
    }
  }

  console.log("dnd-poly: Applying mobile drag and drop polyfill.");

  if (config.holdToDrag) {
    console.log("dnd-poly: holdToDrag set to " + config.holdToDrag);
    addDocumentListener("touchstart", onDelayTouchstart, false);
  } else {
    addDocumentListener("touchstart", onTouchstart, false);
  }

  return true;
}

function tryFindDraggableTarget_override(event, composePath) {
  const cp = composePath || event.composedPath();

  for (let o of cp) {
    let el = o;

    do {
      if (el.draggable === false) {
        continue;
      }

      if (el.getAttribute && el.getAttribute("draggable") === "true") {
        return el;
      }
    } while ((el = el.parentNode) && el !== document.body);
  }
}

function elementFromPoint(x, y) {
  for (let o of this._path) {
    if (o.elementFromPoint) {
      let el = o.elementFromPoint(x, y);

      if (el) {
        while (el.shadowRoot) {
          el = el.shadowRoot.elementFromPoint(x, y);
        }

        return el;
      }
    }
  }
}

function dragStartConditionOverride(event) {
  this._path = event.composedPath();
  return true;
}

polyfill({
  tryFindDraggableTarget: tryFindDraggableTarget_override,
  elementFromPoint: elementFromPoint,
  dragStartConditionOverride: dragStartConditionOverride,
  holdToDrag: 500
});

/******************************************************************************
 *
 * Copyright (c) 2017, the Perspective Authors.
 *
 * This file is part of the Perspective library, distributed under the terms of
 * the Apache License 2.0.  The full license can be found in the LICENSE file.
 *
 */

/**
 * Instantiate a Template DOM object from an HTML text string.
 *
 * Params
 * ------
 * template : An HTML string representing a template.
 *
 * Returns
 * -------
 * A Template DOM object.
 */
function importTemplate(template) {
  const div = document.createElement("div");
  div.innerHTML = template;
  return Array.prototype.slice.call(div.children)[0];
}

function setTemplateContent(template) {
  // return early in browsers that have template tag support
  if (template.content) {
    return;
  }

  template.content = document.createDocumentFragment();
  let child;

  while (child = template.firstChild) {
    Node.prototype.appendChild.call(template.content, child);
  }
}
/**
 * A simple tool for creating Web Components v0.
 *
 * Params
 * ------
 * template : An HTML string representing a template.  Should have an 'id'
 *     attribute which will become the new Web Component's tag name.
 * proto : The new Web Component's prototype object, as per spec.
 */


function registerElement(templateString, styleString, proto) {
  const template = importTemplate(templateString);
  setTemplateContent(template);

  if (styleString) {
    template.innerHTML = `<style>${styleString.toString()}</style>` + template.innerHTML;
  }

  template.innerHTML = `<style id="psp_styles" scope="${template.getAttribute("id")}">test{}</style>` + template.innerHTML;

  const _perspective_element = class extends proto {
    attributeChangedCallback(name, old, value) {
      if (value === null) {
        value = "null";
      }

      if (name[0] !== "_" && old != value && !!Object.getOwnPropertyDescriptor(proto.prototype, name).set) {
        this[name] = value;
      }
    }

    connectedCallback() {
      if (this._initialized) {
        return;
      }

      this._initializing = true;
      var node = document.importNode(template.content, true);
      this.attachShadow({
        mode: "open"
      });
      this.shadowRoot.appendChild(node);

      if (super.connectedCallback) {
        super.connectedCallback();
      } // Call all attributes bound to setters on the proto


      for (let key of Object.getOwnPropertyNames(proto.prototype)) {
        if (key !== "connectedCallback") {
          if (this.hasAttribute(key) && key[0] !== "_" && !!Object.getOwnPropertyDescriptor(proto.prototype, key).set) {
            this[key] = this.getAttribute(key);
          }
        }
      }

      this._initializing = false;
      this._initialized = true;
    }

    static get observedAttributes() {
      return Object.getOwnPropertyNames(proto.prototype);
    }

  };

  for (let key of Object.getOwnPropertyNames(proto.prototype)) {
    let descriptor = Object.getOwnPropertyDescriptor(proto.prototype, key);

    if (descriptor && descriptor.set) {
      let old = descriptor.set;

      descriptor.set = function (val) {
        if (!this.hasAttribute(key) || this.getAttribute(key) !== val) {
          this.setAttribute(key, val);
          return;
        }

        if (!this._initializing && !this._initialized) {
          return;
        }

        old.call(this, val);
      };

      Object.defineProperty(proto.prototype, key, descriptor);
    }
  }

  let name = template.getAttribute("id");
  console.log(`Registered ${name}`);
  window.customElements.define(name, _perspective_element);
}
function bindTemplate(template, ...styleStrings) {
  const style = styleStrings.map(x => x.toString()).join("\n");
  return function (cls) {
    return registerElement(template, {
      toString: () => style
    }, cls);
  };
}
/**
 * A decorator for declaring a setter property of an HTMLElement descendent
 * class as serialized JSON.  Handles converting these types before invoking
 * the underlying function/
 *
 * @param {object} _default the default value to supply the setter when
 * undefined, removed or invalid.
 */

function _attribute(_default) {
  return function (cls, name, desc) {
    const old_set = desc.value;

    desc.set = function (x) {
      let attr = this.getAttribute(name);

      try {
        if (x === null || x === undefined || x === "") {
          x = _default();
        }

        if (typeof x !== "string") {
          x = JSON.stringify(x);
        }

        if (x !== attr) {
          attr = x;
        }

        attr = JSON.parse(attr);
      } catch (e) {
        console.warn(`Invalid value for attribute "${name}": ${x}`);
        attr = _default();
      }

      old_set.call(this, attr);
    };

    desc.get = function () {
      if (this.hasAttribute(name)) {
        return JSON.parse(this.getAttribute(name));
      } else {
        return _default();
      }
    };

    delete desc["value"];
    delete desc["writable"];
    return desc;
  };
}
const invertPromise = () => {
  let _resolve;

  const promise = new Promise(resolve => {
    _resolve = resolve;
  });
  promise.resolve = _resolve;
  return promise;
};
function throttlePromise(target, property, descriptor, clear = false) {
  if (typeof target === "boolean") {
    return function (target, property, descriptor) {
      return throttlePromise(target, property, descriptor, true);
    };
  } // Each call to `throttlePromise` has a unique `lock`


  const lock = Symbol("private lock");
  const _super = descriptor.value;

  async function throttleOnce(id) {
    if (id !== this[lock].gen) {
      // This invocation got de-duped with a later one, but it will
      // wake up first, so if there is not a lock acquired here, push
      // it to the back of the event queue.
      if (!this[lock].lock) {
        await new Promise(requestAnimationFrame);
      } // Now await the currently-processing invocation (which
      // occurred after than this one) and return.


      await this[lock].lock;
      return true;
    }
  } // Wrap the underlying function


  descriptor.value = async function (...args) {
    // Initialize the lock for this Object instance, if it has never been
    // initialized.
    this[lock] = this[lock] || {
      gen: 0
    }; // Assign this invocation a unique ID.

    let id = ++this[lock].gen;

    if (clear) {
      await new Promise(requestAnimationFrame);
    } // If the `lock` property is defined, a previous invocation is still
    // processing.


    if (this[lock].lock) {
      // `await` the previous call;  afterwards, the drawn state will be
      // updated but we need to draw again to incorporate this
      // invocation's state changes.
      await this[lock].lock; // We only want to execute the _last_ invocation, since each call
      // precludes the previous ones if they are still queue-ed.

      if (await throttleOnce.call(this, id)) {
        return;
      }
    } else if (clear) {
      // Even if the lock is clear, we need to debounce the queue-ed.
      const debounced = await throttleOnce.call(this, id);

      if (debounced) {
        return;
      }
    } // This invocation has made it to the render process, so "acquire" the
    // lock.


    this[lock].lock = invertPromise(); // Call the decorated function itself

    let result;

    try {
      result = await _super.call(this, ...args);
    } finally {
      // Errors can leave promises which depend on this behavior
      // dangling.
      const l = this[lock].lock;
      delete this[lock]["lock"]; // If this invocation is still the latest, clear the attribute
      // state.
      // TODO this is likely not he behavior we want for this event ..

      if (id === this[lock].gen && clear) {
        this.removeAttribute("updating");
        this.dispatchEvent(new Event("perspective-update-complete"));
      }

      l.resolve();
    }

    return result;
  }; // A function which clears the lock just like the main wrapper, but then
  // does nothing.


  descriptor.value.flush = async function (obj) {
    var _obj$lock;

    if ((_obj$lock = obj[lock]) !== null && _obj$lock !== void 0 && _obj$lock.lock) {
      var _obj$lock2;

      await obj[lock].lock;
      await new Promise(requestAnimationFrame);

      if ((_obj$lock2 = obj[lock]) !== null && _obj$lock2 !== void 0 && _obj$lock2.lock) {
        await obj[lock].lock;
      }
    }
  };

  return descriptor;
}
/**
 * Swap 2 HTMLElements in a container.
 * @param {HTMLElement} container
 * @param {HTMLElement} elem1
 * @param {HTMLElement} elem2
 */

function swap(container, ...elems) {
  if (elems[0] === elems[1]) return;
  if (elems.every(x => x.classList.contains("null-column"))) return;
  let [i, j] = elems.map(x => Array.prototype.slice.call(container.children).indexOf(x));

  if (j < i) {
    [i, j] = [j, i];
    elems = elems.reverse();
  }

  container.insertBefore(elems[1], elems[0]);

  if (j + 1 === container.children.length) {
    container.appendChild(elems[0]);
  } else {
    container.insertBefore(elems[0], container.children[j + 1]);
  }
}
const json_attribute = _attribute(() => ({}));
const array_attribute = _attribute(() => []);
/**
 * Given an expression, return its alias.
 *
 * @param {*} expression
 * @returns String
 */

function getExpressionAlias(expression) {
  const matches = expression.match(/\/\/(.+?)$/m);
  let alias; // Has an alias - use that to type check.

  if (matches && matches.length == 2) {
    alias = matches[1].trim();
    return alias;
  } else {
    return expression;
  }
}
/**
 * Adds an alias to the given expression and returns it.
 *
 * @param {*} expression
 * @returns String
 */
// export function addExpressionAlias(expression) {
//     let alias;
//     expression.length > 20
//         ? (alias =
//               expression
//                   .replace("\n", " ")
//                   .substr(0, 20)
//                   .trim() + "...")
//         : (alias = expression);
//     return `//${alias}\n${expression}`;
// }

/**
 * Given an alias and an array of string expressions, find the alias inside
 * the expressions array. This is important so we can map aliases back to
 * expressions inside _new_row.
 *
 * @param {String} alias
 * @param {Array<String>} expressions
 * @returns String
 */

function findExpressionByAlias(alias, expressions) {
  for (const expr of expressions) {
    const expr_alias = getExpressionAlias(expr);

    if (alias === expr_alias) {
      return expr;
    }
  }
}
/**
 * Given an expression, strips the alias and returns the expression.
 *
 * @param {String} expression
 * @returns String
 */

function getRawExpression(expression) {
  return expression.replace(/\/\/(.+)\n/, "");
}

const RENDERERS = {};
const renderers = new class {
  /**
   * Register a plugin with the <perspective-viewer> component.
   *
   * @param {string} name The logical unique name of the plugin.  This will be
   * used to set the component's `view` attribute.
   * @param {object} plugin An object with this plugin's prototype.
   *     Valid keys are:
   * @param {string} plugin.name The display name for this plugin.
   * @param {string} plugin.create (required) The creation function - may
   *     return a `Promise`.
   * @param {string} plugin.delete The deletion function.
   * @param {string} plugin.mode The selection mode - may be "toggle" or
   *     "select".
   */
  registerPlugin(name, plugin) {
    if (RENDERERS[name]) {
      throw new Error(`A perspective-viewer plugin "${name}" has already been registered`);
    }

    for (const id in RENDERERS) {
      const old_plugin = RENDERERS[id];

      if (old_plugin && old_plugin.name === plugin.name) {
        console.warn(`Conflicting plugin name "${plugin.name}", qualifying with id`);
        old_plugin.name = `${old_plugin.name} [${id}]`;
        plugin.name = `${plugin.name} [${name}]`;
      }
    }

    RENDERERS[name] = plugin;
  }

  getPlugin(name) {
    return RENDERERS[name];
  }

  getInstance() {
    return RENDERERS;
  }

}();
global.registerPlugin = renderers.registerPlugin;
global.getPlugin = renderers.getPlugin;

if (global.__perspective_plugins__) {
  global.__perspective_plugins__.forEach(([name, plugin]) => global.registerPlugin(name, plugin));
}

const template = csv => html`
        <pre style="margin:0;overflow:scroll;position:absolute;width:100%;height:100%">${csv}</pre>
    `;

function register_debug_plugin() {
  global.registerPlugin("debug", {
    name: "Debug",
    create: async function (div) {
      const csv = await this._view.to_csv({
        config: {
          delimiter: "|"
        }
      });

      const timer = this._render_time();

      render(template(csv), div);
      timer();
    },
    selectMode: "toggle",
    resize: function () {},
    delete: function () {}
  });
}

var css_248z = ".awesomplete [hidden] {\n    display: none;\n}\n\n.awesomplete .visually-hidden {\n    position: absolute;\n    clip: rect(0, 0, 0, 0);\n}\n\n.awesomplete {\n    display: inline-block;\n    position: relative;\n}\n\n.awesomplete > input {\n    display: block;\n}\n\n.awesomplete > ul {\n    position: absolute;\n    left: 0;\n    z-index: 1;\n    min-width: 100%;\n    box-sizing: border-box;\n    list-style: none;\n    padding: 0;\n    margin: 0;\n    background: #fff;\n}\n\n.awesomplete > ul:empty {\n    display: none;\n}\n\n.awesomplete > ul {\n\tborder-radius: .3em;\n\tmargin: .2em 0 0;\n\tbackground: hsla(0,0%,100%,.9);\n\tbackground: linear-gradient(to bottom right, white, hsla(0,0%,100%,.8));\n\tborder: 1px solid rgba(0,0,0,.3);\n\tbox-shadow: .05em .2em .6em rgba(0,0,0,.2);\n\ttext-shadow: none;\n}\n\n@supports (transform: scale(0)) {\n\t.awesomplete > ul {\n\t\ttransition: .3s cubic-bezier(.4,.2,.5,1.4);\n\t\ttransform-origin: 1.43em -.43em;\n\t}\n\t\n\t.awesomplete > ul[hidden],\n\t.awesomplete > ul:empty {\n\t\topacity: 0;\n\t\ttransform: scale(0);\n\t\tdisplay: block;\n\t\ttransition-timing-function: ease;\n\t}\n}\n\n\t/* Pointer */\n\t.awesomplete > ul:before {\n\t\tcontent: \"\";\n\t\tposition: absolute;\n\t\ttop: -.43em;\n\t\tleft: 1em;\n\t\twidth: 0; height: 0;\n\t\tpadding: .4em;\n\t\tbackground: white;\n\t\tborder: inherit;\n\t\tborder-right: 0;\n\t\tborder-bottom: 0;\n\t\t-webkit-transform: rotate(45deg);\n\t\ttransform: rotate(45deg);\n\t}\n\n\t.awesomplete > ul > li {\n\t\tposition: relative;\n\t\tpadding: .2em .5em;\n\t\tcursor: pointer;\n\t}\n\t\n\t.awesomplete > ul > li:hover {\n\t\tbackground: hsl(200, 40%, 80%);\n\t\tcolor: black;\n\t}\n\t\n\t.awesomplete > ul > li[aria-selected=\"true\"] {\n\t\tbackground: hsl(205, 40%, 40%);\n\t\tcolor: white;\n\t}\n\t\n\t\t.awesomplete mark {\n\t\t\tbackground: hsl(65, 100%, 50%);\n\t\t}\n\t\t\n\t\t.awesomplete li:hover mark {\n\t\t\tbackground: hsl(68, 100%, 41%);\n\t\t}\n\t\t\n\t\t.awesomplete li[aria-selected=\"true\"] mark {\n\t\t\tbackground: hsl(86, 100%, 21%);\n\t\t\tcolor: inherit;\n\t\t}\n";

var template$1 = "<!--\r\n   \r\n   Copyright (c) 2017, the Perspective Authors.\r\n   \r\n   This file is part of the Perspective library, distributed under the terms of\r\n   the Apache License 2.0.  The full license can be found in the LICENSE file.\r\n\r\n-->\r\n\r\n<template id=\"perspective-row\">\r\n    <div id=\"psp_row\">\r\n        <span class='is_visible'></span>\r\n        <div draggable='true' class=\"row_draggable\">\r\n            <span id='name' class=\"column_name\"></span>\r\n            <span id=\"sort_order\"></span>\r\n            <select id=\"column_aggregate\" class=\"string\"></select>\r\n            <select id=\"filter_operator\"></select>\r\n            <input id=\"filter_operand\" placeholder=\"Value\" />\r\n            <span id=\"row_exclamation\" hidden>&#x26A0;</span>\r\n            <span id='row_close'>&#x2715;</span>\r\n        </div>\r\n    </div>\r\n</template>";

var css_248z$1 = "/******************************************************************************\n *\n * Copyright (c) 2017, the Perspective Authors.\n *\n * This file is part of the Perspective library, distributed under the terms of\n * the Apache License 2.0.  The full license can be found in the LICENSE file.\n *\n */\n/******************************************************************************\n *\n * Copyright (c) 2017, the Perspective Authors.\n *\n * This file is part of the Perspective library, distributed under the terms of\n * the Apache License 2.0.  The full license can be found in the LICENSE file.\n *\n */\n:host {\n  display: block;\n}\n.dropping * {\n  pointer-events: none;\n}\n:host #psp_row {\n  display: var(--psp_row-display, flex);\n  margin: var(--psp_row-margin, 0);\n  overflow: visible;\n  align-items: var(--column_selector--align-items, center);\n  width: auto !important;\n  height: auto !important;\n  float: none !important;\n}\n:host .is_visible {\n  width: var(--column_selector--width, 20px);\n  min-width: var(--column_selector--width, 20px);\n  height: var(--is_visible--height, auto);\n  cursor: var(--is_visible--cursor, pointer);\n  font-size: var(--column_selector--font-size, 14px);\n  margin-top: -2px;\n  display: var(--is_visible-display, none);\n}\n:host #sort_order {\n  display: none;\n  font-family: var(--button--font-family, inherit);\n  margin-right: 4px;\n}\n:host #sort_order:before {\n  content: var(--row-sort-order--before, \"-\");\n}\n:host #sort_order:hover {\n  color: var(--active--color, inherit);\n}\n:host #filter_operand {\n  font-family: inherit;\n  font-size: 12px;\n  display: var(--filter_operand-display, none);\n  margin: 0;\n  padding: 0px;\n  height: 19px;\n  color: inherit;\n  outline: none;\n  border-color: var(--inactive--color, #C5C9D0);\n}\n:host #filter_operator {\n  margin: 0 0 0 8px;\n  display: var(--filter_operator-display, none);\n  height: 17px;\n}\n:host #filter_operator:hover {\n  color: var(--active--color, inherit);\n}\n:host #sort_order {\n  cursor: pointer;\n  width: 10px;\n}\n:host select {\n  margin-left: 15px;\n  padding-right: 15px;\n  cursor: pointer;\n}\n@keyframes expand2 {\n  from {\n    transform: translateX(10px);\n  }\n}\n@keyframes expand3 {\n  from {\n    transform: scale(0.9);\n  }\n}\n:host(:hover) .is_visible {\n  color: var(--active--color, --column-selector--color);\n}\n:host {\n  border: 0px solid rgba(0, 0, 0, 0);\n}\n:host #row_close {\n  display: var(--row_close-display, inline);\n  cursor: pointer;\n  min-width: 5px;\n  max-width: 5px;\n  margin-right: 3px;\n  flex-grow: 0;\n  font-size: 10px;\n  margin-left: 3px;\n}\n:host .is_visible:before {\n  content: var(--is_visible--before, none);\n}\n:host .is_visible {\n  color: var(--column-selector--color, #999);\n  font-family: var(--column-selector--font-family, Arial) !important;\n}\n:host #sort_order {\n  display: var(--sort_order-display, none);\n  padding: var(--sort_order-padding, 0);\n}\n:host #row_exclamation {\n  color: red;\n}\n:host #row_close {\n  color: inherit;\n  font-size: 10px;\n}\n:host #row_close:hover {\n  color: var(--active--color, inherit);\n}\n:host .row_draggable select {\n  font-family: inherit;\n  border: none;\n}\n:host .row_draggable select:focus {\n  outline: none;\n}\n:host select::-ms-expand {\n  display: none;\n}\n:host select {\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  -ms-appearance: none;\n  appearance: none;\n  background: var(--select--background, url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgNC45IDEwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0LjkgMTA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojQUFBQUFBO30KPC9zdHlsZT4KPHRpdGxlPmFycm93czwvdGl0bGU+Cjxwb2x5Z29uIGNsYXNzPSJzdDAiIHBvaW50cz0iMS40LDQuNyAyLjUsMy4yIDMuNSw0LjcgIi8+Cjxwb2x5Z29uIGNsYXNzPSJzdDAiIHBvaW50cz0iMy41LDUuMyAyLjUsNi44IDEuNCw1LjMgIi8+Cjwvc3ZnPg==) no-repeat 95% 50%);\n  background-color: var(--select--background-color, white);\n  color: inherit;\n  border-radius: 5px;\n  height: 21px;\n  margin-top: 3px;\n  padding: var(--column_type--padding, 0px 0px 0px 5px);\n  font-size: 12px;\n  font-weight: 300;\n  font-family: inherit;\n}\n:host .awesomplete > ul {\n  border-radius: 0px;\n  margin: 0px;\n  border: none;\n  transition: none !important;\n  background: var(--plugin--background, #fff) !important;\n}\n:host .awesomplete > ul:before {\n  content: none;\n}\n:host .awesomplete > input,\n:host input {\n  border-color: #ccc;\n  border-width: 0 0 1px 0;\n  box-sizing: border-box;\n  background-color: transparent;\n}\n:host .row_draggable {\n  animation: var(--row_draggable--animation, expand2 0.5s ease-out);\n  cursor: move;\n  border-style: solid;\n  background-color: var(--row_draggable-background-color, none);\n  overflow: var(--row_draggable-overflow, visible);\n  border-color: var(--row_draggable-border-color, none);\n  border-width: var(--row_draggable-border-width, 0);\n  padding: var(--row_draggable--padding, 0);\n  font-size: 12px;\n  flex-grow: 1;\n  color: inherit;\n  transition: height 0.2s;\n  box-sizing: border-box;\n  height: var(--row_draggable-height, 21px);\n  min-height: var(--row_draggable-height, 21px);\n  display: var(--row_draggable-display, flex);\n  align-items: var(--row-draggable--align-items);\n  flex-direction: var(--row-draggable--flex-direction, column);\n  justify-content: var(--row_draggable--justify-content, center);\n  margin: var(--row_draggable--margin, 0);\n  transition: var(--row_draggable--transition, none);\n}\n:host .row_draggable * {\n  opacity: var(--row_draggable_children-opacity, 1);\n}\n:host .row_draggable select {\n  margin: 0px 0px 0px 27px;\n}\n:host ul {\n  transition: background-color 0.2s, border-color 0.2s;\n}\n:host(.null-column) .is_visible {\n  opacity: 0 !important;\n}\n:host(.null-column) .row_draggable {\n  background-color: var(--null--background, transparent) !important;\n  box-shadow: var(--null--box-shadow, none);\n  border-width: 0 0 1px 0 !important;\n  border-color: transparent !important;\n}\n:host([drop-target]) .row_draggable {\n  background-color: var(--active--background, rgba(38, 112, 169, 0.3)) !important;\n  box-shadow: var(--null--box-shadow, none);\n  border-width: 0 0 1px 0 !important;\n  border-color: transparent !important;\n}\n:host .integer:before,\n:host .float:before {\n  content: var(--float--column-type--content, var(--column-type--content, \"123\"));\n  color: var(--float--column-type--color, var(--column-type--color, #016bc6));\n}\n:host .string:before {\n  content: var(--string--column-type--content, var(--column-type--content, \"abc\"));\n  color: var(--string--column-type--color, var(--column-type--color, #fe9292));\n}\n:host .boolean:before {\n  content: var(--boolean--column-type--content, var(--column-type--content, \"t/f\"));\n  color: var(--boolean--column-type--color, var(--column-type--color, #999999));\n}\n:host .date:before {\n  content: var(--date--column-type--content, var(--column-type--content, \"mdy\"));\n  color: var(--date--column-type--color, var(--column-type--color, #999999));\n}\n:host .datetime:before {\n  content: var(--datetime--column-type--content, var(--column-type--content, \"mdy\"));\n  color: var(--datetime--column-type--color, var(--column-type--color, #999999));\n}\n:host .column_name {\n  overflow: hidden;\n  max-width: var(--column_name-max-width, none);\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n:host span#name:before {\n  font-family: var(--interface-monospace--font-family, monospace);\n  position: relative;\n  display: inline-block;\n  padding: var(--column_type--padding, 0px 5px);\n  min-width: 18px;\n  display: var(--name-before-display, none);\n  width: var(--column_type--width, auto);\n  font-weight: 200;\n}\n:host #column_aggregate {\n  display: var(--column_aggregate-display, none);\n  font-size: 10px;\n  font-family: inherit;\n  width: 88%;\n  height: 20px;\n}\n:host span#name {\n  flex: var(--column-name--flex, 0 1 auto);\n  width: 100%;\n  white-space: nowrap;\n  margin: var(--column_name-margin, 0);\n}\n";

var _dec, _class;

function _CustomElement$1() {
  return Reflect.construct(HTMLElement, [], this.__proto__.constructor);
}
Object.setPrototypeOf(_CustomElement$1.prototype, HTMLElement.prototype);
Object.setPrototypeOf(_CustomElement$1, HTMLElement);
const SPAN = document.createElement("span");
SPAN.style.visibility = "hidden";
SPAN.style.fontFamily = "monospace";
SPAN.style.fontSize = "12px";
SPAN.style.position = "absolute";

function get_text_width(text, max = 0) {
  // FIXME get these values form the stylesheet
  SPAN.innerHTML = text;
  document.body.appendChild(SPAN);
  const width = `${Math.max(max, SPAN.offsetWidth) + 10}px`;
  document.body.removeChild(SPAN);
  return width;
} // Eslint complains here because we don't do anything, but actually we globally
// register this class as a CustomElement


// eslint-disable-next-line no-unused-vars
(_dec = bindTemplate(template$1, {
  toString: () => css_248z$1 + "\n" + css_248z
}), _dec(_class = class Row extends _CustomElement$1 {
  set name(n) {
    const elem = this.shadowRoot.querySelector("#name");
    elem.innerHTML = this.getAttribute("name");
  }

  _option_template(agg, name) {
    return html`
            <option value="${agg}" data-desc="${name}">${name || agg}</option>
        `;
  }

  _select_template(category, type) {
    const items = perspective[category][type] || [];
    const weighted_options = html`
            <optgroup label="weighted mean">
                ${this._weights.map(x => this._option_template(JSON.stringify(["weighted mean", x]), x))}
            </optgroup>
        `;
    const has_weighted_mean = category === "TYPE_AGGREGATES" && (type === "integer" || type === "float");
    return html`
            ${items.map(x => this._option_template(x))} ${has_weighted_mean ? weighted_options : nothing}
        `;
  }

  set_weights(xs) {
    this._weights = xs;
  }

  set type(t) {
    const elem = this.shadowRoot.querySelector("#name");
    const type = this.getAttribute("type");
    if (!type) return;
    const type_config = get_type_config(type);

    if (type_config.type) {
      elem.classList.add(type_config.type);
    }

    elem.classList.add(type);
    const agg_dropdown = this.shadowRoot.querySelector("#column_aggregate");
    const filter_dropdown = this.shadowRoot.querySelector("#filter_operator");
    render(this._select_template("TYPE_AGGREGATES", type_config.type || type), agg_dropdown);
    render(this._select_template("TYPE_FILTERS", type_config.type || type), filter_dropdown);

    if (!this.hasAttribute("aggregate")) {
      this.aggregate = type_config.aggregate;
    } else {
      this.aggregate = this.getAttribute("aggregate");
    }

    if (this.hasAttribute("filter")) {
      this.filter = this.getAttribute("filter");
    }

    const filter_operand = this.shadowRoot.querySelector("#filter_operand");

    this._callback = event => this._update_filter(event);

    filter_operand.addEventListener("keyup", this._callback.bind(this));
  }

  choices(choices) {
    const filter_operand = this.shadowRoot.querySelector("#filter_operand");
    const filter_operator = this.shadowRoot.querySelector("#filter_operator");
    const selector = new Awesomplete(filter_operand, {
      label: this.getAttribute("name"),
      list: choices,
      minChars: 0,
      autoFirst: true,
      filter: function (text, input) {
        return Awesomplete.FILTER_CONTAINS(text, input.match(/[^,]*$/)[0]);
      },
      item: function (text, input) {
        return Awesomplete.ITEM(text, input.match(/[^,]*$/)[0]);
      },
      replace: function (text) {
        const before = this.input.value.match(/^.+,\s*|/)[0];

        if (filter_operator.value === "in" || filter_operator.value === "not in") {
          this.input.value = before + text + ", ";
        } else {
          this.input.value = before + text;
        }
      }
    });

    if (filter_operand.value === "") {
      selector.evaluate();
    }

    filter_operand.focus();

    this._filter_operand.addEventListener("focus", () => {
      if (filter_operand.value.trim().length === 0) {
        selector.evaluate();
      }
    });

    filter_operand.addEventListener("awesomplete-selectcomplete", this._callback);
  }

  set filter(f) {
    const filter_dropdown = this.shadowRoot.querySelector("#filter_operator");
    const filter = JSON.parse(this.getAttribute("filter"));

    if (filter_dropdown.value !== filter.operator) {
      filter_dropdown.value = filter.operator || get_type_config(this.getAttribute("type")).filter_operator;
    }

    filter_dropdown.style.width = get_text_width(filter_dropdown.value);
    const filter_input = this.shadowRoot.querySelector("#filter_operand");
    const operand = filter.operand ? filter.operand.toString() : "";

    if (!this._initialized) {
      filter_input.value = operand;
    }

    if (filter_dropdown.value === FILTER_OPERATORS.isNull || filter_dropdown.value === FILTER_OPERATORS.isNotNull) {
      filter_input.style.display = "none";
    } else {
      filter_input.style.display = "inline-block";
      filter_input.style.width = get_text_width(operand, 30);
    }
  }

  set aggregate(a) {
    const agg_dropdown = this.shadowRoot.querySelector("#column_aggregate");
    const aggregate = this.getAttribute("aggregate");

    if (agg_dropdown.value !== aggregate && this.hasAttribute("type")) {
      const type = this.getAttribute("type");
      agg_dropdown.value = aggregate || get_type_config(type).aggregate;
    }

    this._blur_agg_dropdown();
  }

  _update_filter(event) {
    const filter_operand = this.shadowRoot.querySelector("#filter_operand");
    const filter_operator = this.shadowRoot.querySelector("#filter_operator");
    let val = filter_operand.value;
    const type = this.getAttribute("type");

    switch (type) {
      case "float":
        val = parseFloat(val);
        break;

      case "integer":
        val = parseInt(val);
        break;

      case "boolean":
        val = val.toLowerCase().indexOf("true") > -1;
        break;
    }

    if (filter_operator.value === FILTER_OPERATORS.isIn || filter_operator.value === FILTER_OPERATORS.isNotIn) {
      val = val.split(",").map(x => x.trim());
    }

    this.setAttribute("filter", JSON.stringify({
      operator: filter_operator.value,
      operand: val
    }));
    this.dispatchEvent(new CustomEvent("filter-selected", {
      detail: event
    }));
  }

  _set_data_transfer(event) {
    let data;

    if (this.hasAttribute("filter")) {
      const {
        operator,
        operand
      } = JSON.parse(this.getAttribute("filter"));
      data = [this.getAttribute("name"), operator, operand, this.getAttribute("type"), this.getAttribute("aggregate")];
    } else {
      data = [this.getAttribute("name"), get_type_config(this.getAttribute("type")).filter_operator, undefined, this.getAttribute("type"), this.getAttribute("aggregate")];
    }

    if (this.hasAttribute("expression") && this.hasAttribute("title")) {
      // Add the expression to drag-data so it automatically
      // resolves inside the expression editor.
      data.push(this.getAttribute("title"));
    }

    event.dataTransfer.setData("text/plain", JSON.stringify(data));
    this.dispatchEvent(new CustomEvent("row-drag"));
  }

  _register_ids() {
    this._li = this.shadowRoot.querySelector(".row_draggable");
    this._visible = this.shadowRoot.querySelector(".is_visible");
    this._row_close = this.shadowRoot.querySelector("#row_close");
    this._agg_dropdown = this.shadowRoot.querySelector("#column_aggregate");
    this._sort_order = this.shadowRoot.querySelector("#sort_order");
    this._filter_operand = this.shadowRoot.querySelector("#filter_operand");
    this._filter_operator = this.shadowRoot.querySelector("#filter_operator");
    this._column_aggregate_category = this.shadowRoot.querySelector("#column_aggregate_category");
  }

  _blur_agg_dropdown() {
    this._agg_dropdown.blur();

    if (this._agg_dropdown.value[0] === "[") {
      for (const option of this._agg_dropdown.querySelectorAll("optgroup option")) {
        const name = option.getAttribute("data-desc");
        option.innerHTML = `mean by ${name}`;
      }
    }
  }

  _focus_agg_dropdown() {
    for (const option of this._agg_dropdown.querySelectorAll("optgroup option")) {
      const name = option.getAttribute("data-desc");
      option.innerHTML = `by ${name}`;
    }
  }

  _register_callbacks() {
    this._li.addEventListener("dragstart", this._set_data_transfer.bind(this));

    this._li.addEventListener("dragend", () => {
      this.dispatchEvent(new CustomEvent("row-dragend"));
    });

    this._visible.addEventListener("mousedown", event => this.dispatchEvent(new CustomEvent("visibility-clicked", {
      detail: event
    })));

    this._row_close.addEventListener("mousedown", event => this.dispatchEvent(new CustomEvent("close-clicked", {
      detail: event
    })));

    this._agg_dropdown.addEventListener("focus", this._focus_agg_dropdown.bind(this));

    this._agg_dropdown.addEventListener("change", event => {
      this._blur_agg_dropdown();

      const value = this._agg_dropdown.value;
      this.setAttribute("aggregate", value);
      this.dispatchEvent(new CustomEvent("aggregate-selected", {
        detail: event
      }));
    });

    this._sort_order.addEventListener("click", event => {
      this.dispatchEvent(new CustomEvent("sort-order", {
        detail: event
      }));
    });

    const debounced_filter = debounce(event => this._update_filter(event), 50);

    this._filter_operator.addEventListener("change", () => {
      this._filter_operand.focus();

      this._filter_operator.style.width = get_text_width(this._filter_operator.value);
      const filter_input = this.shadowRoot.querySelector("#filter_operand");
      filter_input.style.width = get_text_width("" + this._filter_operand.value, 30);
      debounced_filter();
    });
  }

  connectedCallback() {
    this._register_ids();

    this._register_callbacks();
  }

}) || _class);

var template$2 = "<!--\r\n   \r\n   Copyright (c) 2017, the Perspective Authors.\r\n   \r\n   This file is part of the Perspective library, distributed under the terms of\r\n   the Apache License 2.0.  The full license can be found in the LICENSE file.\r\n\r\n-->\r\n\r\n<template id=\"perspective-viewer\">\r\n\r\n    <perspective-vieux id=\"app\">\r\n\r\n        <div slot=\"side_panel\" id='side_panel' class=\"column fixed noselect\">\r\n            <div id=\"vis_selector_container\">\r\n                <select id=\"vis_selector\">\r\n                </select>\r\n            </div>\r\n            <div id=\"columns_container\" style=\"visibility: hidden\">\r\n                <ul id='active_columns'></ul>\r\n                <div id=\"sub_columns\">\r\n                    <ul id='inactive_columns'></ul>\r\n                    <div id=\"side_panel__actions\" style=\"visibility: hidden\">\r\n                        <div id=\"add-expression\" class=\"side_panel-action\"><span class=\"psp-icon psp-icon__add\"></span><span class=\"psp-title__columnName\">New Column</span></div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <div slot=\"top_panel\" id='top_panel'>\r\n            <div class=\"rrow\">\r\n                <div id=\"row_pivots\">\r\n                    <div class=\"psp-text-field\">\r\n                        <ul class=\"psp-text-field__input\" for=\"row-pivots\"></ul>\r\n                        <label for=\"row_pivots\"></label>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <span id=\"transpose_button\" class=\"rrow centered\" title=\"Transpose Pivots\">&#x21C4;</span>\r\n            <div class=\"rrow\">\r\n                <div id=\"column_pivots\">\r\n                    <div class=\"psp-text-field\">\r\n                        <ul class=\"psp-text-field__input\" for=\"column-pivots\"></ul>\r\n                        <label for=\"column_pivots\"></label>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"rrow\">\r\n                <div id=\"sort\">\r\n                    <div class=\"psp-text-field\">\r\n                        <ul class=\"psp-text-field__input\" for=\"sort\"></ul>\r\n                        <label for=\"sort\"></label>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"rrow\" style='flex-grow:3;height:auto;flex:1 1 400px;max-width:none'>\r\n                <div id=\"filters\">\r\n                    <div class=\"psp-text-field\">\r\n                        <ul class=\"psp-text-field__input\" for='filters'></ul>\r\n                        <label for=\"filters\"></label>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <div slot=\"main_panel\" id=\"pivot_chart_container\">\r\n            <div class=\"plugin_information plugin_information--warning hidden\" id=\"plugin_information--size\">\r\n                <span class=\"plugin_information__text\" id=\"plugin_information_count\">Estimated rendering</span>\r\n                <span class=\"plugin_information__actions\">\r\n                    <span class=\"plugin_information__action\">Render all points</span>\r\n                </span>\r\n            </div>\r\n            <div id=\"pivot_chart\"></div>\r\n        </div>\r\n\r\n    </perspective-vieux>\r\n</template>";

var css_248z$2 = "/******************************************************************************\n *\n * Copyright (c) 2017, the Perspective Authors.\n *\n * This file is part of the Perspective library, distributed under the terms of\n * the Apache License 2.0.  The full license can be found in the LICENSE file.\n *\n */\n/******************************************************************************\n *\n * Copyright (c) 2017, the Perspective Authors.\n *\n * This file is part of the Perspective library, distributed under the terms of\n * the Apache License 2.0.  The full license can be found in the LICENSE file.\n *\n */\n:host #app #top_panel #row_pivots label:before {\n  content: var(--row_pivots--before, \"Row Pivots\");\n}\n:host #app #top_panel #column_pivots label:before {\n  content: var(--column_pivots--before, \"Column Pivots\");\n}\n:host #app #top_panel #sort label:before {\n  content: \"Sort\";\n}\n:host #app #top_panel #filters label:before {\n  content: \"Filter\";\n}\n:host #app #side_panel #active_columns perspective-row:before {\n  font-size: 10px;\n  margin-left: var(--column_selector--width, 20px);\n  left: 1px;\n  padding: var(--column_type--padding, 0px 0px 0px 5px);\n  color: var(--inactive--color, #666);\n  position: absolute;\n  margin-top: -15px;\n}\n/******************************************************************************\n *\n * Copyright (c) 2017, the Perspective Authors.\n *\n * This file is part of the Perspective library, distributed under the terms of\n * the Apache License 2.0.  The full license can be found in the LICENSE file.\n *\n */\n:host ::-webkit-scrollbar,\n:host ::shadow ::-webkit-scrollbar {\n  width: 12px;\n}\n:host ::-webkit-scrollbar-track,\n:host ::shadow ::-webkit-scrollbar-track {\n  background: none;\n}\n:host ::-webkit-scrollbar {\n  width: 8px;\n  height: 8px;\n}\n:host ::-webkit-scrollbar-thumb {\n  background-color: var(--scrollbar--background-color, #E0E4E9);\n}\n:host ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n}\n:host ::-webkit-scrollbar-corner {\n  background-color: rgba(0, 0, 0, 0);\n}\n:host #inactive_columns,\n:host #active_columns {\n  -webkit-mask-image: linear-gradient(black, black), linear-gradient(to top, transparent 10%, black 90%);\n  -webkit-mask-position: -8px 0px, bottom right;\n  -webkit-mask-size: 100% 100%, 8px 1000%;\n  -webkit-mask-repeat: no-repeat;\n  transition: -webkit-mask-position 0.3s;\n}\n:host #inactive_columns:hover,\n:host #active_columns:hover {\n  -webkit-mask-position: -8px 0px, top right;\n}\n.button {\n  padding: var(--button--padding, 12px 14px 24px 8px);\n}\n@keyframes expand {\n  from {\n    opacity: 0.5;\n  }\n}\n:host {\n  position: relative;\n  display: inline-block;\n  overflow: hidden;\n  word-wrap: \"normal\";\n  --d3fc-series: rgba(31, 119, 180, 0.5);\n  --d3fc-series-1: #0366d6;\n  --d3fc-series-2: #ff7f0e;\n  --d3fc-series-3: #2ca02c;\n  --d3fc-series-4: #d62728;\n  --d3fc-series-5: #9467bd;\n  --d3fc-series-6: #8c564b;\n  --d3fc-series-7: #e377c2;\n  --d3fc-series-8: #7f7f7f;\n  --d3fc-series-9: #bcbd22;\n  --d3fc-series-10: #17becf;\n  --d3fc-full--gradient: linear-gradient(#4d342f 0%, #e4521b 22.5%, #feeb65 42.5%, #f0f0f0 50%, #dcedc8 57.5%, #42b3d5 67.5%, #1a237e 100%);\n  --d3fc-positive--gradient: linear-gradient(#dcedc8 0%, #42b3d5 35%, #1a237e 100%);\n  --d3fc-negative--gradient: linear-gradient(#feeb65 100%, #e4521b 70%, #4d342f 0%);\n}\n:host #pivot_chart {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  display: grid;\n  justify-content: stretch;\n}\n:host .hidden {\n  display: none;\n}\n:host .psp-icon:hover {\n  cursor: pointer;\n}\n:host .psp-icon__add {\n  display: flex;\n  width: 20px;\n  min-width: 20px;\n  margin-top: -2px;\n  height: 0px;\n  font-family: var(--column-add--font-family, inherit);\n}\n:host .psp-icon__add:before {\n  font-feature-settings: \"liga\";\n  content: var(--column-add--before, \"+\");\n}\n:host .psp-title__columnName {\n  display: flex;\n  margin-left: 24px;\n  margin-top: 3px;\n  font-size: 12px;\n  font-weight: 300;\n}\n:host .side_panel-action:hover {\n  cursor: pointer;\n}\n:host * {\n  box-sizing: border-box;\n  line-height: 1.42857143;\n}\n:host #app #side_panel {\n  width: 100%;\n}\n:host #app {\n  display: flex;\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n:host #app.hide_message #drop_target {\n  display: none;\n}\n:host .chart {\n  padding: 15px;\n}\n:host #pivot_chart_container {\n  flex-grow: 1;\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  border: var(--plugin--border, none);\n}\n:host .config {\n  display: flex;\n}\n:host #row_pivots #psp_row,\n:host #column_pivots #psp_row,\n:host #sort #psp_row,\n:host #filters #psp_row {\n  display: inline;\n}\n:host .psp-text-field ul {\n  min-height: 20px;\n}\n:host #active_columns perspective-row {\n  animation: expand 0.3s ease-out;\n  --column-selector--color: var(--active--color, #999);\n  --is_visible--before: var(--active-column-selector--content, \"\\25CF\");\n}\n:host #inactive_columns perspective-row {\n  animation: expand 0.3s ease-out;\n  --column-selector--color: var(--inactive-column-selector--color, #999);\n  --is_visible--before: var(--inactive-column-selector--content, \"\\25CB\");\n  --row_draggable--animation: none;\n}\n:host #inactive_columns perspective-row:hover {\n  transition: none;\n  opacity: 1;\n}\n:host #top_panel perspective-row {\n  animation: expand 0.3s ease-out;\n  --column-name--flex: 1;\n}\n:host #active_columns,\n:host #inactive_columns {\n  list-style: none;\n  padding: 0px;\n  width: 100%;\n  margin: var(--column-container--margin, 8px 0px 0px 0px);\n  overflow-y: overlay;\n  overflow-x: hidden;\n  position: relative;\n}\n:host #inactive_columns perspective-row {\n  opacity: var(--inactive-column--opacity, 1);\n  transition: opacity 0.3s;\n}\n:host #inactive_columns perspective-row.active {\n  opacity: 0;\n  height: 0 !important;\n  overflow: hidden;\n}\n:host .columns_horizontal #sub_columns.collapse #side_panel__actions {\n  margin-top: 0px;\n}\n:host .columns_horizontal .collapse #sub_columns #side_panel__actions {\n  margin-top: 0px;\n}\n:host #sub_columns {\n  display: flex;\n  flex-direction: column;\n  overflow-x: hidden;\n  width: 100%;\n  flex: 0 100 auto;\n}\n:host #sub_columns.collapse {\n  flex: 0 1 auto;\n  flex-shrink: 0;\n  min-height: 0px;\n}\n:host #app.columns_horizontal #sub_columns {\n  flex: 0 1 50%;\n}\n:host #app.columns_horizontal #sub_columns #inactive_columns {\n  flex: 0 1 auto;\n}\n:host #app:not(.columns_horizontal) #columns_container:not(.collapse) #active_columns {\n  max-height: min(calc(100% - 95px), 60%);\n}\n:host #columns_container.collapse #sub_columns {\n  flex: 0 1 auto;\n  flex-shrink: 0;\n  min-height: 0px;\n}\n:host .column {\n  display: flex;\n  list-style: none;\n  flex-direction: column;\n  flex: 1;\n}\n:host .rrow {\n  display: flex;\n  flex-grow: 1;\n  min-height: 24px;\n  align-items: center;\n  max-width: 400px;\n  list-style: none;\n  min-width: 140px;\n  margin: var(--column-drop-container--margin, 5px 10px 0px 0px);\n}\n:host .rrow > div {\n  display: flex;\n  min-height: 24px;\n  flex-direction: column;\n  justify-content: flex-end;\n}\n:host #top_panel > .rrow > * {\n  width: 100%;\n  padding: 12px 0px 12px 0px;\n  margin: -12px 0px -12px 0px;\n}\n:host .rrow #psp_row {\n  white-space: nowrap;\n}\n:host #sort perspective-row {\n  --sort_order-display: inline;\n  --sort_order-padding: 0 0 0 4px;\n}\n:host #sort perspective-row[sort-order=\"asc\"] {\n  --row-sort-order--before: var(--sort-order-asc--before, \"\\2191\");\n}\n:host #sort perspective-row[sort-order=\"desc\"] {\n  --row-sort-order--before: var(--sort-order-desc--before, \"\\2193\");\n}\n:host #sort perspective-row[sort-order=\"none\"] {\n  --row-sort-order--before: var(--sort-order-none--before, \"-\");\n}\n:host #sort perspective-row[sort-order=\"asc abs\"] {\n  --row-sort-order--before: var(--sort-order-asc-abs--before, \"\\21E7\");\n}\n:host #sort perspective-row[sort-order=\"desc abs\"] {\n  --row-sort-order--before: var(--sort-order-desc-abs--before, \"\\21E9\");\n}\n:host #sort perspective-row[sort-order=\"col asc\"] {\n  --row-sort-order--before: var(--sort-order-col-asc--before, \"\\2192\");\n}\n:host #sort perspective-row[sort-order=\"col desc\"] {\n  --row-sort-order--before: var(--sort-order-col-desc--before, \"\\2190\");\n}\n:host #sort perspective-row[sort-order=\"col asc abs\"] {\n  --row-sort-order--before: var(--sort-order-col-asc-abs--before, \"\\21E8\");\n}\n:host #sort perspective-row[sort-order=\"col desc abs\"] {\n  --row-sort-order--before: var(--sort-order-col-desc-abs--before, \"\\21E6\");\n}\n:host #top_panel perspective-row {\n  padding: 0px 10px 0px 0px;\n}\n:host #top_panel perspective-row::after {\n  content: \",\";\n  line-height: 26px;\n  padding-left: 4px;\n}\n:host #top_panel perspective-row:last-child::after {\n  display: none;\n  content: \"\" !important;\n}\n:host label {\n  white-space: nowrap;\n  display: inline-block;\n  vertical-align: middle;\n  margin-bottom: 0px;\n}\n:host #drop_target {\n  position: absolute;\n  left: 0px;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  padding: 30px;\n}\n:host #drop_target_inner {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n:host #drop_target_inner h3 {\n  font-weight: 300;\n}\n:host .button {\n  cursor: pointer;\n  font-size: 16px;\n  font-weight: normal;\n}\n:host ul {\n  padding: 0px;\n  margin: 0;\n  font-size: 12px;\n}\n:host select::-ms-expand {\n  display: none;\n}\n:host select {\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  -ms-appearance: none;\n  appearance: none;\n  background: var(--select--background, url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgNC45IDEwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0LjkgMTA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojQUFBQUFBO30KPC9zdHlsZT4KPHRpdGxlPmFycm93czwvdGl0bGU+Cjxwb2x5Z29uIGNsYXNzPSJzdDAiIHBvaW50cz0iMS40LDQuNyAyLjUsMy4yIDMuNSw0LjcgIi8+Cjxwb2x5Z29uIGNsYXNzPSJzdDAiIHBvaW50cz0iMy41LDUuMyAyLjUsNi44IDEuNCw1LjMgIi8+Cjwvc3ZnPg==) no-repeat 95% 50%);\n  background-color: #fff;\n  color: inherit;\n  border-radius: 5px;\n  height: 21px;\n  margin-top: 3px;\n  padding: var(--select--padding, 0px 0px 0px 6px);\n  font-size: 12px;\n  font-weight: 300;\n  font-family: inherit;\n}\n:host select option {\n  background: var(--select--background-color, #ffffff);\n}\n:host input {\n  padding: 0 10px 0 10px;\n}\n:host .centered {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n:host #top_panel {\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: flex-start;\n  padding: var(--top_panel--padding, 5px 0px 10px 0px);\n  max-width: 1000px;\n  z-index: 1;\n}\n:host #top_panel perspective-row {\n  margin-bottom: -1px;\n  display: var(--top-panel-row--display, inline-block);\n  --psp_row-display: inline-block;\n}\n:host #side_panel {\n  position: relative;\n  flex: 0 0 auto;\n  padding: var(--side_panel--padding, 10px 2px 0px 11px);\n}\n:host #side_panel > div {\n  display: flex;\n}\n:host #vis_selector_container {\n  min-height: 29px;\n  margin-left: var(--column_selector--width, 20px);\n  overflow: hidden;\n}\n:host #vis_selector {\n  flex-grow: 1;\n}\n:host #transpose_button {\n  cursor: pointer;\n  min-width: 5px;\n  max-width: 5px;\n  flex-grow: 0;\n  color: var(--inactive--color, inherit);\n  font-family: Arial;\n  font-size: 12px;\n  user-select: none;\n}\n:host #transpose_button:hover {\n  color: var(--active--color, inherit);\n}\n:host #resize_bar {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  width: 8px;\n  cursor: col-resize;\n}\n";

var css_248z$3 = "/******************************************************************************\n *\n * Copyright (c) 2017, the Perspective Authors.\n *\n * This file is part of the Perspective library, distributed under the terms of\n * the Apache License 2.0.  The full license can be found in the LICENSE file.\n *\n */\n/******************************************************************************\n *\n * Copyright (c) 2017, the Perspective Authors.\n *\n * This file is part of the Perspective library, distributed under the terms of\n * the Apache License 2.0.  The full license can be found in the LICENSE file.\n *\n */\n:host ::-webkit-scrollbar,\n:host ::shadow ::-webkit-scrollbar {\n  width: 12px;\n}\n:host ::-webkit-scrollbar-track,\n:host ::shadow ::-webkit-scrollbar-track {\n  background: none;\n}\n:host ::-webkit-scrollbar {\n  width: 8px;\n  height: 8px;\n}\n:host ::-webkit-scrollbar-thumb {\n  background-color: var(--scrollbar--background-color, #E0E4E9);\n}\n:host ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n}\n:host ::-webkit-scrollbar-corner {\n  background-color: rgba(0, 0, 0, 0);\n}\n:host #inactive_columns,\n:host #active_columns {\n  -webkit-mask-image: linear-gradient(black, black), linear-gradient(to top, transparent 10%, black 90%);\n  -webkit-mask-position: -8px 0px, bottom right;\n  -webkit-mask-size: 100% 100%, 8px 1000%;\n  -webkit-mask-repeat: no-repeat;\n  transition: -webkit-mask-position 0.3s;\n}\n:host #inactive_columns:hover,\n:host #active_columns:hover {\n  -webkit-mask-position: -8px 0px, top right;\n}\n.psp-text-field {\n  position: relative;\n  background-color: var(--column-drop-container--background, white);\n  border-width: 0;\n  border-bottom-width: 1px;\n  border-style: solid;\n  border-color: var(--inactive--color, #ccc);\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-end;\n  min-height: 24px;\n  transition: border-color 0.3s ease-out, background-size 0.3s ease-out;\n  background-size: 100% 200%;\n}\n:host(.dragging) .psp-text-field.dropping {\n  border-bottom-width: 2px;\n  border-style: solid;\n  border-color: var(--active--color, #1a7da1);\n}\n:host(.dragging) .psp-text-field {\n  border-bottom-width: 1px;\n  border-style: solid;\n  border-color: var(--active--color, #1a7da1);\n  background: var(--input-dragover--background, linear-gradient(to top, #cbe7f9, transparent 25%));\n  background-size: 100% 100%;\n}\n.psp-text-field > .psp-text-field__input {\n  border: 0px;\n  line-height: 20px;\n  vertical-align: bottom;\n  padding-bottom: 0px;\n  display: none;\n}\n.psp-text-field__input + label {\n  width: 0px;\n  height: var(--column--height, auto);\n  line-height: 17px;\n  box-sizing: border-box;\n  font-weight: 300;\n  color: var(--inactive--color, #B4B7BE);\n  white-space: nowrap;\n  padding: var(--column-drop-container--padding, 0px 0px 2px 10px);\n  font-size: 12px;\n  display: inline-block;\n  transition: font-size 0.3s, margin 0.3s;\n}\n.dropping .psp-text-field__input,\n.psp-text-field__input:not(:empty) {\n  display: block !important;\n}\n.dropping .psp-text-field__input::after {\n  content: \"|\";\n  width: 0px;\n  overflow: visible;\n  margin-top: -1px;\n  position: absolute;\n}\n.dropping * {\n  pointer-events: none;\n}\n.dropping .psp-text-field label,\n.psp-text-field__input:not(:empty) + label {\n  position: absolute;\n  top: 0px;\n  margin: var(--column-drop-label--margin, 0);\n  font-size: var(--column-drop-label--font-size, 12px);\n  display: var(--column-drop-label--display, none);\n}\n.dropping perspective-row.inserting {\n  border-top: 25px solid rgba(0, 0, 0, 0);\n}\n.dropping perspective-row.postserting {\n  border-bottom: 25px solid rgba(0, 0, 0, 0);\n}\n/* These rules needs to be strictly ordered to avoid a bug in IE/ShadyCSS */\n:host perspective-row {\n  height: var(--column--height, 21px);\n  --row_draggable-height: var(--column--height, 21px);\n}\n:host([row-pivots]) #columns_container #active_columns {\n  min-height: var(--active-column--height, 41px);\n}\n:host([row-pivots]) #columns_container #active_columns perspective-row {\n  height: var(--active-column--height, 41px);\n  min-height: var(--active-column--height, 41px);\n  --row_draggable-height: var(--active-column--height, 41px);\n  --column_aggregate-display: inline-block;\n  --is_visible--height: var(--active-column-selector--height, auto);\n}\n:host {\n  font-family: Arial, sans-serif;\n  background-color: #F2F4F6;\n  color: #161616;\n}\n:host #app.columns_horizontal #columns_container {\n  flex-direction: row-reverse;\n}\n:host #app.columns_horizontal #active_columns,\n:host #app.columns_horizontal #inactive_columns {\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n}\n:host #app.columns_horizontal #active_columns {\n  flex: 0 1 50%;\n}\n:host #app.columns_horizontal #sub_columns {\n  flex-shrink: 1;\n  /* TODO broken */\n}\n:host #app.columns_horizontal #sub_columns perspective-row {\n  --column_name-margin: 0 25px 0 0;\n}\n:host #app.columns_horizontal #side_panel #divider {\n  display: none;\n}\n:host #app.columns_horizontal perspective-expression-editor {\n  max-height: none;\n  margin-right: 24px;\n  width: auto;\n}\n:host #side_panel perspective-row {\n  --name-before-display: inline-block;\n  --is_visible-display: inline-block;\n  --row_draggable--padding: 0px 8px 0px 0px;\n  --row_draggable--margin: 0px 8px 0px 0px;\n  --row_close-display: none;\n  --column_name-max-width: 180px;\n}\n:host #top_panel perspective-row {\n  --row_draggable-display: inline-flex;\n  --row-draggable--flex-direction: row;\n  --row-draggable--align-items: center;\n}\n:host #columns_container {\n  flex-direction: column;\n  height: calc(100% - 29px);\n}\n:host #columns_container #active_columns {\n  flex: 0 1 auto;\n  min-height: var(--column--height, 21px);\n}\n:host #columns_container #active_columns perspective-row {\n  margin-bottom: 2px;\n  --row_draggable-background-color: var(--column--background, white);\n  --row_draggable-border-color: var(--inactive--color, #C5C9D0);\n  --row_draggable-border-width: 0 0 1px 0;\n  --row_draggable-overflow: hidden;\n  --row_draggable--justify-content: space-evenly;\n}\n:host #columns_container #active_columns perspective-row:last-child {\n  --row_draggable-border-color: var(--row_draggable-last-child-border-color, var(--inactive--color, #C5C9D0));\n}\n:host #columns_container #active_columns perspective-row[drop-target] {\n  --row_draggable_children-opacity: 0;\n}\n:host #columns_container #active_columns perspective-row.null-column {\n  --row_draggable_children-opacity: 0;\n  pointer-events: none;\n}\n:host #columns_container #active_columns.one_lock perspective-row:first-child,\n:host #columns_container #active_columns.two_lock perspective-row:first-child {\n  --active--color: var(--inactive--color, #ccc);\n  --is_visible--cursor: normal;\n}\n:host #columns_container #active_columns.two_lock perspective-row:nth-child(2) {\n  --active--color: var(--inactive--color, #ccc);\n  --is_visible--cursor: normal;\n}\n:host #columns_container #active_columns perspective-row:only-child {\n  --active--color: var(--inactive--color, #ccc);\n  --is_visible--cursor: normal;\n}\n:host #columns_container #inactive_columns perspective-row:not(.active) {\n  --row_draggable-border-width: 0 0 1px 0;\n  margin-bottom: 2px;\n  --row_draggable-border-color: transparent;\n}\n:host #columns_container #active_columns,\n:host #columns_container #inactive_columns {\n  border: none !important;\n}\n:host ul {\n  transition: background-color 0.2s, border-color 0.2s;\n  outline: none;\n}\n:host #side_panel #side_panel__actions {\n  display: flex;\n  flex-direction: column;\n  flex-shrink: 1000;\n  justify-content: flex-start;\n  position: relative;\n  width: 100%;\n  margin: var(--column-container--margin, 8px);\n  min-height: 36px;\n}\n:host #side_panel #side_panel__actions #add-expression {\n  padding: 6px 0px;\n  margin: -6px 0 0 0;\n}\n:host #side_panel #side_panel__actions #add-expression.expr_editor_open {\n  background: rgba(0, 0, 0, 0.05);\n}\n:host #side_panel #side_panel__actions #add-computed-expression:hover {\n  background-color: rgba(0, 0, 0, 0.05);\n  border: 5px solid transparent;\n  border-left-width: 0px;\n  border-right-width: 0px;\n  margin-top: -5px;\n  margin-bottom: -5px;\n}\n:host #side_panel #side_panel__actions button.side_panel-action {\n  align-items: center;\n  align-content: center;\n  background: none;\n  border: none;\n  display: flex;\n  flex-direction: row;\n  font-size: 12px;\n  padding-right: 10px;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n}\n:host #side_panel #side_panel__actions button.side_panel-action span {\n  margin-left: 5px;\n  font-size: 15px;\n}\n:host #side_panel #side_panel__actions button.side_panel-action:hover {\n  cursor: pointer;\n}\n:host .noselect {\n  -webkit-touch-callout: none;\n  /* iOS Safari */\n  -webkit-user-select: none;\n  /* Safari */\n  -khtml-user-select: none;\n  /* Konqueror HTML */\n  -moz-user-select: none;\n  /* Firefox */\n  -ms-user-select: none;\n  /* Internet Explorer/Edge */\n  user-select: none;\n  /* Non-prefixed version, currently supported by Chrome and Opera */\n}\n:host #pivot_chart {\n  background-color: var(--plugin--background, white);\n}\n:host #drop_target {\n  border: var(--plugin--border, none);\n}\n:host #filters perspective-row {\n  margin: 0 0px 0 0;\n  --filter_operator-display: inline-block;\n  --filter_operand-display: inline-block;\n}\n:host .plugin_information {\n  color: var(--warning--color, inherit);\n  display: flex;\n  position: absolute;\n  flex-direction: row;\n  justify-content: flex-start;\n  padding: 0.5rem;\n  width: 100%;\n  z-index: 10000;\n  transition: opacity 0.3s ease-out;\n  opacity: 1;\n}\n:host .plugin_information.hidden {\n  display: none;\n  opacity: 0;\n}\n:host .plugin_information.plugin_information--warning {\n  background: #ffca28;\n}\n:host .plugin_information .plugin_information__text {\n  font-size: 12px;\n  margin-right: 0.25rem;\n  display: flex;\n  flex-wrap: wrap;\n  align-items: center;\n}\n:host .plugin_information .plugin_information__text:before {\n  content: var(--overflow_hint--before);\n  font-family: var(--overflow_hint--font-family);\n  color: var(--overflow_hint--color);\n  padding: var(--overflow_hint--padding);\n  font-size: 16px;\n}\n:host .plugin_information .plugin_information__action {\n  font-size: 12px;\n  text-decoration: underline;\n  cursor: pointer;\n  margin-right: 0.25rem;\n}\n:host .plugin_information .plugin_information__actions {\n  margin-left: auto;\n  display: flex;\n  align-items: center;\n  flex-direction: row;\n  justify-content: flex-start;\n}\n:host .plugin_information .plugin_information--overflow-hint-percent {\n  font-weight: 700;\n}\n:host .plugin_information .plugin_information--overflow-hint {\n  white-space: nowrap;\n}\n:host #drop_target {\n  background: var(--plugin--background, #fff);\n}\n:host #drop_target_inner h3 {\n  color: #aaa;\n  font-weight: 300;\n}\n:host #close_button:before {\n  font-family: var(--button--font-family, Arial);\n  font-feature-settings: \"liga\";\n  content: var(--close_button--before, \"Close\");\n}\n:host ul {\n  border-bottom-width: 1px;\n  border-style: solid;\n  border-color: var(--inactive--color, #C5C9D0);\n  border-top-width: 0px;\n  border-left-width: 0px;\n  border-right-width: 0px;\n  font-size: 12px;\n  padding: var(--column-drop-container--padding, 0px 10px 0px 10px);\n}\n:host select {\n  border-radius: 0;\n  background-color: var(--select--background-color, white);\n  border-bottom-width: 1px;\n  border-style: solid;\n  border-color: var(--inactive--color, #C5C9D0);\n  border-top-width: 0px;\n  border-left-width: 0px;\n  border-right-width: 0px;\n}\n:host select:focus {\n  outline: none;\n}\n:host input {\n  border-bottom-width: 1px;\n  border-style: solid;\n  border-color: var(--inactive--color, #C5C9D0);\n  border-top-width: 0px;\n  border-left-width: 0px;\n  border-right-width: 0px;\n}\n:host input::placeholder {\n  color: var(--inactive--color, #ccc);\n}\n:host option[value=\"\"] {\n  color: white !important;\n}\n:host #app {\n  background-color: inherit;\n}\n";

function calc_index(event) {
  if (this._active_columns.children.length == 0) {
    return 0;
  } else {
    let is_last_null = false;

    for (let cidx in this._active_columns.children) {
      var _child$classList;

      let child = this._active_columns.children[cidx];
      is_last_null = is_last_null || (child === null || child === void 0 ? void 0 : (_child$classList = child.classList) === null || _child$classList === void 0 ? void 0 : _child$classList.contains("null-column"));

      if (child.offsetTop + child.offsetHeight > event.offsetY + this._active_columns.scrollTop) {
        return parseInt(cidx);
      }
    }

    let last_index = this._active_columns.children.length;

    if (is_last_null) {
      last_index--;
    }

    return last_index;
  }
}

function dragend(event) {
  let div = event.target.getRootNode().host;
  let parent = div;

  if (parent.tagName === "PERSPECTIVE-VIEWER") {
    parent = event.target.parentElement;
  } else {
    parent = div.parentElement;
  }

  let idx = Array.prototype.slice.call(parent.children).indexOf(div.tagName === "PERSPECTIVE-ROW" ? div : event.target);
  let attr_name = parent.getAttribute("for");

  if (this.hasAttribute(attr_name)) {
    let attr_value = JSON.parse(this.getAttribute(attr_name));
    attr_value.splice(idx, 1);

    if (attr_value.length === 0) {
      this.removeAttribute(attr_name);
    } else {
      this.setAttribute(attr_name, JSON.stringify(attr_value));
    }
  }
}
function drop(ev) {
  ev.preventDefault();
  ev.currentTarget.classList.remove("dropping");
  DRAG_COUNT_MAP = new WeakMap();

  if (this._drop_target_hover) {
    this._drop_target_hover.removeAttribute("drop-target");
  }

  let data = ev.dataTransfer.getData("text");
  if (!data) return;
  data = JSON.parse(data); // Update the columns attribute

  let name = ev.currentTarget.querySelector("ul").getAttribute("for") || ev.currentTarget.getAttribute("id").replace("_", "-");
  let columns = JSON.parse(this.getAttribute(name) || "[]");
  let data_index = columns.indexOf(data[0]);

  if (data_index !== -1) {
    columns.splice(data_index, 1);
  }

  const filtering = name.indexOf("filter") > -1;

  if (filtering) {
    this.setAttribute(name, JSON.stringify(columns.concat([data])));
  } else if (name.indexOf("sort") > -1) {
    this.setAttribute(name, JSON.stringify(columns.concat([[data[0]]])));
  } else {
    this.setAttribute(name, JSON.stringify(columns.concat([data[0]])));
  } // Deselect the dropped column


  if (this._plugin.deselectMode === "pivots" && this._get_visible_column_count() > 1 && name !== "sort" && !filtering) {
    for (let x of this.shadowRoot.querySelectorAll("#active_columns perspective-row")) {
      if (x.getAttribute("name") === data[0]) {
        this._active_columns.removeChild(x);

        break;
      }
    }

    this._update_column_view();
  }

  this._debounce_update();
}
function column_dragend(event) {
  let data = event.target.parentElement.parentElement;

  if (Array.prototype.slice(this._active_columns.children).indexOf(data) > -1 && this._get_visible_column_count() > 1 && event.dataTransfer.dropEffect !== "move") {
    this._active_columns.removeChild(data);

    this._update_column_view();
  }

  this._active_columns.classList.remove("dropping");
}
function column_dragleave(event) {
  let src = event.relatedTarget;

  while (src && src !== this._active_columns) {
    src = src.parentElement;
  }

  if (src === null) {
    this._active_columns.classList.remove("dropping");

    if (this._drop_target_null) {
      this._active_columns.replaceChild(this._drop_target_null, this._drop_target_hover);

      delete this._drop_target_null;
    }

    if (this._drop_target_hover.parentElement === this._active_columns) {
      this._active_columns.removeChild(this._drop_target_hover);
    }

    if (this._original_index !== -1) {
      this._active_columns.insertBefore(this._drop_target_hover, this._active_columns.children[this._original_index]);
    }

    this._drop_target_hover.removeAttribute("drop-target");
  }
}

function _unset_drop_target_null() {
  if (this._drop_target_null) {
    if (this._drop_target_null.parentElement === this._active_columns) {
      swap(this._active_columns, this._drop_target_hover, this._drop_target_null);
    } else {
      this._active_columns.replaceChild(this._drop_target_null, this._drop_target_hover);
    }

    delete this._drop_target_null;
  }
}

function column_swap(new_index) {
  _unset_drop_target_null.call(this);

  if (this._active_columns.children[new_index]) {
    if (this._drop_target_hover !== this._active_columns.children[new_index]) {
      this._drop_target_null = this._active_columns.children[new_index];
      swap(this._active_columns, this._active_columns.children[new_index], this._drop_target_hover);
    }
  }
}

function column_replace(new_index) {
  _unset_drop_target_null.call(this);

  if (this._active_columns.children[new_index]) {
    this._drop_target_null = this._active_columns.children[new_index];

    this._active_columns.replaceChild(this._drop_target_hover, this._active_columns.children[new_index]);
  }
}

function column_dragover(event) {
  var _this$_plugin$initial, _this$_plugin$initial2, _this$_plugin$initial3, _this$_plugin$initial4, _this$_plugin$initial5, _this$_plugin$initial6, _this$_plugin$initial7, _this$_plugin$initial8;

  event.preventDefault();
  event.dataTransfer.dropEffect = "move";

  if (!this._drop_target_hover.hasAttribute("drop-target")) {
    this._drop_target_hover.toggleAttribute("drop-target", true);
  }

  let new_index = calc_index.call(this, event);
  const current_index = Array.prototype.slice.call(this._active_columns.children).indexOf(this._drop_target_hover);
  const over_elem = this._active_columns.children[new_index];
  const to_replace = new_index < ((_this$_plugin$initial = this._plugin.initial) === null || _this$_plugin$initial === void 0 ? void 0 : (_this$_plugin$initial2 = _this$_plugin$initial.names) === null || _this$_plugin$initial2 === void 0 ? void 0 : _this$_plugin$initial2.length) - 1;
  const is_diff = this._drop_target_hover !== this._active_columns.children[new_index];
  const from_active = this._original_index !== -1;
  const from_replace = from_active && this._original_index < ((_this$_plugin$initial3 = this._plugin.initial) === null || _this$_plugin$initial3 === void 0 ? void 0 : (_this$_plugin$initial4 = _this$_plugin$initial3.names) === null || _this$_plugin$initial4 === void 0 ? void 0 : _this$_plugin$initial4.length) - 1;
  const from_append = from_active && this._original_index >= ((_this$_plugin$initial5 = this._plugin.initial) === null || _this$_plugin$initial5 === void 0 ? void 0 : (_this$_plugin$initial6 = _this$_plugin$initial5.names) === null || _this$_plugin$initial6 === void 0 ? void 0 : _this$_plugin$initial6.length) - 1;
  const from_required = from_active && this._original_index < ((_this$_plugin$initial7 = this._plugin.initial) === null || _this$_plugin$initial7 === void 0 ? void 0 : _this$_plugin$initial7.count);
  const to_required = new_index < ((_this$_plugin$initial8 = this._plugin.initial) === null || _this$_plugin$initial8 === void 0 ? void 0 : _this$_plugin$initial8.count);
  const to_null = !to_required && (over_elem === null || over_elem === void 0 ? void 0 : over_elem.classList.contains("null-column"));

  if (from_required && to_null) {
    _unset_drop_target_null.call(this);
  } else if (to_replace && from_append && is_diff) {
    var _this$_plugin$initial9, _this$_plugin$initial10, _this$_plugin$initial11, _this$_plugin$initial12, _this$_active_columns;

    _unset_drop_target_null.call(this);

    const from_last = this._original_index === ((_this$_plugin$initial9 = this._plugin.initial) === null || _this$_plugin$initial9 === void 0 ? void 0 : (_this$_plugin$initial10 = _this$_plugin$initial9.names) === null || _this$_plugin$initial10 === void 0 ? void 0 : _this$_plugin$initial10.length) - 1 && this._drop_target_hover === this._active_columns.children[this._original_index] && this._active_columns.children.length === ((_this$_plugin$initial11 = this._plugin.initial) === null || _this$_plugin$initial11 === void 0 ? void 0 : (_this$_plugin$initial12 = _this$_plugin$initial11.names) === null || _this$_plugin$initial12 === void 0 ? void 0 : _this$_plugin$initial12.length);

    if (from_last) {
      this._drop_target_null = this._active_columns.children[new_index];
      swap(this._active_columns, this._active_columns.children[new_index], this._drop_target_hover);
    } else if (!((_this$_active_columns = this._active_columns.children[new_index]) !== null && _this$_active_columns !== void 0 && _this$_active_columns.classList.contains("null-column"))) {
      this._drop_target_null = this._active_columns.children[new_index];

      this._active_columns.replaceChild(this._drop_target_hover, this._active_columns.children[new_index]);

      this._active_columns.insertBefore(this._drop_target_null, this._active_columns.children[this._original_index]);
    } else {
      if (this._drop_target_hover !== this._active_columns.children[new_index]) {
        this._drop_target_null = this._active_columns.children[new_index];

        this._active_columns.replaceChild(this._drop_target_hover, this._active_columns.children[new_index]);
      }
    }
  } else if (to_replace && from_active && is_diff) {
    column_swap.call(this, new_index);
  } else if (to_replace && !from_active && is_diff) {
    column_replace.call(this, new_index);
  } else if (!to_replace && from_replace && is_diff) {
    column_swap.call(this, new_index);
  } else if (to_null && from_active) {
    column_swap.call(this, new_index);
  } else if (to_null && !from_active) {
    column_replace.call(this, new_index);
  } else if (current_index < new_index) {
    if (new_index + 1 < this._active_columns.children.length) {
      if (!this._active_columns.children[new_index + 1].hasAttribute("drop-target")) {
        _unset_drop_target_null.call(this);

        this._active_columns.insertBefore(this._drop_target_hover, this._active_columns.children[new_index + 1]);
      }
    } else {
      if (!this._active_columns.children[this._active_columns.children.length - 1].hasAttribute("drop-target")) {
        _unset_drop_target_null.call(this);

        this._active_columns.appendChild(this._drop_target_hover);
      }
    }
  } else if (new_index < this._active_columns.children.length) {
    if (!this._active_columns.children[new_index].hasAttribute("drop-target")) {
      _unset_drop_target_null.call(this);

      this._active_columns.insertBefore(this._drop_target_hover, this._active_columns.children[new_index]);
    }
  } else {
    if (!this._active_columns.children[this._active_columns.children.length - 1].hasAttribute("drop-target")) {
      _unset_drop_target_null.call(this);

      this._active_columns.appendChild(this._drop_target_hover);
    }
  }
}
function column_drop(ev) {
  ev.preventDefault();
  delete this._drop_target_null;
  ev.currentTarget.classList.remove("dropping");
  DRAG_COUNT_MAP = new WeakMap();

  if (this._drop_target_hover.parentElement === this._active_columns) {
    this._drop_target_hover.removeAttribute("drop-target");
  }

  let data = ev.dataTransfer.getData("text");
  if (!data) return;

  this._update_column_view();
}
function dragover(ev) {
  ev.stopPropagation();
  ev.preventDefault();
  ev.dataTransfer.dropEffect = "move";
}
let DRAG_COUNT_MAP = new WeakMap();

function dragenterleave(event) {
  let dragHoverCount = DRAG_COUNT_MAP.get(event.currentTarget) || 0;
  event.type === "dragenter" ? dragHoverCount++ : dragHoverCount--;
  DRAG_COUNT_MAP.set(event.currentTarget, dragHoverCount);
  event.currentTarget.classList.toggle("dropping", dragHoverCount > 0);
  event.preventDefault();
}

const dragenter = dragenterleave;
const dragleave = dragenterleave;

/******************************************************************************
 *
 * Copyright (c) 2018, the Perspective Authors.
 *
 * This file is part of the Perspective library, distributed under the terms of
 * the Apache License 2.0.  The full license can be found in the LICENSE file.
 *
 */
class CancelTask {
  constructor(on_cancel, initial = false) {
    this._on_cancel = on_cancel;
    this._cancelled = false;
    this.initial = initial;
  }

  cancel() {
    if (!this._cancelled && this._on_cancel) {
      this._on_cancel();

      this._on_cancel = undefined;
    }

    this._cancelled = true;
  }

  get cancelled() {
    return this._cancelled;
  }

}

function _CustomElement$2() {
  return Reflect.construct(HTMLElement, [], this.__proto__.constructor);
}
Object.setPrototypeOf(_CustomElement$2.prototype, HTMLElement.prototype);
Object.setPrototypeOf(_CustomElement$2, HTMLElement);
class StateElement extends _CustomElement$2 {
  get _plugin() {
    let current_renderers = renderers.getInstance();
    let view = this.getAttribute("plugin");

    if (!view) {
      view = Object.keys(current_renderers)[0];
      this.setAttribute("plugin", view);
    }

    return current_renderers[view] || current_renderers[Object.keys(current_renderers)[0]];
  } // deprecate


  _get_view_dom_columns(selector, callback) {
    selector = selector || "#active_columns perspective-row";
    let columns = Array.prototype.slice.call(this.shadowRoot.querySelectorAll(selector));

    if (!callback) {
      return columns;
    }

    return columns.map(callback).filter(x => x);
  }

  _get_view_active_columns() {
    return Array.prototype.slice.call(this.shadowRoot.querySelectorAll("#active_columns perspective-row"));
  }

  _get_view_active_valid_columns() {
    return Array.prototype.slice.call(this.shadowRoot.querySelectorAll("#active_columns perspective-row")).filter(x => !x.classList.contains("null-column"));
  }

  _get_view_inactive_columns() {
    return Array.prototype.slice.call(this.shadowRoot.querySelectorAll("#inactive_columns perspective-row"));
  }

  _get_view_all_column_names() {
    return this._get_view_inactive_columns().map(x => x.getAttribute("name"));
  }

  _get_view_active_column_names() {
    return this._get_view_active_columns().map(x => x.getAttribute("name"));
  }

  _get_view_all_valid_column_names() {
    return this._get_view_all_column_names().filter(x => x);
  }

  _get_view_active_valid_column_names() {
    return this._get_view_active_column_names().filter(x => x);
  }

  _get_view_active_valid_column_count() {
    return this._get_view_active_valid_column_names().length;
  } // deprecate


  _get_view_columns({
    active = true
  } = {}) {
    let selector;

    if (active) {
      selector = "#active_columns perspective-row";
    } else {
      selector = "#inactive_columns perspective-row";
    }

    return this._get_view_dom_columns(selector, col => {
      return col.getAttribute("name");
    });
  }

  _get_view_aggregates(selector) {
    selector = selector || "#active_columns perspective-row";
    return this._get_view_dom_columns(selector, s => {
      let op = s.getAttribute("aggregate");

      if (op[0] === "[") {
        try {
          op = JSON.parse(op);
        } catch (e) {
          console.error(e);
        }
      }

      const column = s.getAttribute("name");
      return column && {
        op,
        column
      };
    });
  }

  _get_view_row_pivots() {
    return this._get_view_dom_columns("#row_pivots perspective-row", col => {
      return col.getAttribute("name");
    });
  }

  _get_view_column_pivots() {
    return this._get_view_dom_columns("#column_pivots perspective-row", col => {
      return col.getAttribute("name");
    });
  }

  _get_view_filter_nodes() {
    return this._get_view_dom_columns("#filters perspective-row");
  }

  _get_view_filters() {
    return this._get_view_dom_columns("#filters perspective-row", col => {
      let {
        operator,
        operand
      } = JSON.parse(col.getAttribute("filter"));
      return [col.getAttribute("name"), operator, operand];
    });
  }

  _get_view_sorts() {
    return this._get_view_dom_columns("#sort perspective-row", col => {
      let order = col.getAttribute("sort-order") || "asc";
      return [col.getAttribute("name"), order];
    });
  }

  _get_view_expressions() {
    return JSON.parse(this.getAttribute("expressions")) || [];
  }

  _get_visible_column_count() {
    return this._get_view_active_columns().length;
  }

  get_aggregate_attribute() {
    const aggs = JSON.parse(this.getAttribute("aggregates")) || {};
    const found = new Set();
    const new_aggs = Object.keys(aggs).map(col => {
      found.add(col);
      return {
        column: col,
        op: aggs[col]
      };
    });

    if (this._aggregate_defaults) {
      for (const column of Object.keys(this._aggregate_defaults)) {
        if (!found.has(column)) {
          new_aggs.push({
            column,
            op: this._aggregate_defaults[column]
          });
        }
      }
    }

    return new_aggs;
  }

}

var _dec$1, _class$1;
/******************************************************************************
 *
 *  Helpers
 *
 */

function numberWithCommas(x) {
  return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

let TYPE_ORDER = {
  integer: 2,
  string: 0,
  float: 3,
  boolean: 4,
  datetime: 1,
  date: 1
};

const column_sorter = schema => (a, b) => {
  const s1 = TYPE_ORDER[schema[a]];
  const s2 = TYPE_ORDER[schema[b]];
  let r = 0;

  if (s1 == s2) {
    r = a.toLowerCase() < b.toLowerCase() ? -1 : 1;
  } else {
    r = s1 < s2 ? -1 : 1;
  }

  return r;
};

function get_aggregate_defaults(columns, schema, expression_schema) {
  const aggregates = {};

  for (const col of columns) {
    let type = schema[col];

    if (!type) {
      type = expression_schema[col];
    }

    aggregates[col] = get_type_config(type).aggregate;
  }

  return aggregates;
}

function get_aggregates_with_defaults(aggregate_attribute, columns, schema, expression_schema) {
  const found = new Set();
  const aggregates = [];

  for (const col of aggregate_attribute) {
    let type = schema[col.column];

    if (!type) {
      type = expression_schema[col.column];
    }

    const type_config = get_type_config(type);
    found.add(col.column);

    if (type_config.type || type) {
      if (col.op === "" || TYPE_AGGREGATES[type_config.type || type].indexOf(col.op) === -1) {
        col.op = type_config.aggregate;
      }

      aggregates.push(col);
    } else {
      console.warn(`No column "${col.column}" found (specified in aggregates attribute).`);
    }
  } // Add columns detected from dataset.


  for (const col of columns) {
    if (!found.has(col)) {
      let type = schema[col];

      if (!type) {
        type = expression_schema[col.column];
      }

      aggregates.push({
        column: col,
        op: get_type_config(type).aggregate
      });
    }
  }

  return aggregates;
}

const _total_template = args => {
  if (args) {
    const x = numberWithCommas(args[0]);
    const y = numberWithCommas(args[1]);
    const total = Math.floor(args[0] / args[1] * 100);
    return html`
            <span title="${x} / ${y}" class="plugin_information--overflow-hint">&nbsp;<span class="plugin_information--overflow-hint-percent">${total}%</span>&nbsp;</span>
        `;
  }
};

const _nowrap_template = text => {
  if (text !== "") {
    return html`
            <span style="white-space:nowrap">${text}</span>
        `;
  }
};
/**
 * Render warning template tagged literal.
 * @param {*} strings
 * @param  {...[n, m]} args tuples of rationals to be formatted.
 */


const _warning = (strings, ...args) => strings.flatMap((str, idx) => [_nowrap_template(str), _total_template(args[idx])]).filter(x => x);
/******************************************************************************
 *
 * PerspectiveElement
 *
 */


let PerspectiveElement = (_dec$1 = throttlePromise(true), (_class$1 = class PerspectiveElement extends StateElement {
  /**
   * Given a {@link module:perspective~table}, load it into the
   * {@link module:perspective_viewer~PerspectiveViewer} and set the viewer's
   * state. If the `expressions` attribute is set on the viewer, this
   * method attempts to validate the expressions with the `Table` and
   * reconcile state.
   *
   * @param {*} table
   */
  async _load_table(table, resolve) {
    this.shadowRoot.querySelector("#app").classList.add("hide_message");

    this._clear_state();

    this._table = table;
    let [cols, schema] = await Promise.all([table.columns(), table.schema(true)]); // Initial col order never contains expressions

    this._initial_col_order = cols.slice(); // Grab expressions from the viewer and validate them so that
    // expressions do not crash the viewer/table.

    const expressions = this._get_view_expressions();

    const valid_expressions = [];
    let expression_schema = {};

    if (expressions.length > 0) {
      const valid_expression_alias = [];
      const validate_results = await table.validate_expressions(expressions);
      expression_schema = validate_results.expression_schema;

      for (const expression of expressions) {
        const alias = getExpressionAlias(expression);

        if (alias === undefined) {
          console.warn(`Not applying expression ${expression} as it does not have an alias set.`);
          continue;
        }

        if (expression_schema[alias]) {
          valid_expressions.push(expression);
          valid_expression_alias.push(alias);
        } else {
          console.error(`Could not validate expression "${alias}": ${validate_results.errors[alias]}`);
        }
      }

      cols = cols.concat(valid_expression_alias);
    }

    if (!this.hasAttribute("columns")) {
      this.setAttribute("columns", JSON.stringify(this._initial_col_order));
    }

    cols.sort(column_sorter(schema)); // Update aggregates

    const aggregate_attribute = this.get_aggregate_attribute();
    const aggregates = get_aggregates_with_defaults(aggregate_attribute, cols, schema, expression_schema);
    let shown = JSON.parse(this.getAttribute("columns")); //.filter(x => all_cols.indexOf(x) > -1);
    // At this point, cols contains both the table columns and the
    // validated expressions, so this should only filter on columns
    // that don't exist in either.

    const shown_is_invalid = shown.filter(x => cols.indexOf(x) > -1).length === 0;

    if (shown_is_invalid) {
      shown = this._initial_col_order;
    }

    this._aggregate_defaults = get_aggregate_defaults(cols, schema, expression_schema); // Clear the columns in the DOM before adding new ones

    this._clear_columns();

    for (const name of cols) {
      let aggregate = aggregates.find(a => a.column === name).op;
      let type = schema[name];

      if (!type) {
        type = expression_schema[name];
      }

      const expression = findExpressionByAlias(name, valid_expressions);

      const row = this._new_row(name, type, aggregate, null, null, expression);

      this._inactive_columns.appendChild(row);

      if (shown.includes(name)) {
        row.classList.add("active");
      }
    }

    while (shown.length < ((_this$_plugin$initial = this._plugin.initial) === null || _this$_plugin$initial === void 0 ? void 0 : (_this$_plugin$initial2 = _this$_plugin$initial.names) === null || _this$_plugin$initial2 === void 0 ? void 0 : _this$_plugin$initial2.length)) {
      var _this$_plugin$initial, _this$_plugin$initial2;

      shown.push(null);
    }

    for (const x of shown) {
      let type = schema[x];

      if (!type) {
        type = expression_schema[x];
      }

      const expression = findExpressionByAlias(x, valid_expressions);

      const active_row = this._new_row(x, type, undefined, undefined, undefined, expression);

      this._active_columns.appendChild(active_row);
    }

    if (cols.length === shown.filter(x => cols.indexOf(x) > -1).length) {
      this._columns_container.classList.add("collapse");
    } else {
      this._columns_container.classList.remove("collapse");
    }

    this._show_column_container();

    this._show_side_panel_actions(); // Filters need type information to populate e.g. the operator dropdown,
    // so reset them.


    if (this.hasAttribute("filters")) {
      this.filters = this.getAttribute("filters");
    } // Get an edit port from the table, and set it on the viewer so that
    // all grid edits use the specified port.


    this._edit_port = await table.make_port(); // Resolve the edit port lock, which allows for `get_edit_port` to be
    // called in arbitary order without ever returning a null value.

    this._edit_port_lock.resolve(this._edit_port);

    try {
      await this._debounce_update({
        force_update: true
      });
    } catch (e) {
      console.warn("Initial view failed, resetting UI state");
      await this.reset();
      throw e;
    }

    resolve();
  }

  async get_maxes() {
    // If the plugin is set to not render a warning, i.e. after the user
    // selects "Render all points", then return null for max_cols/max_rows.
    if (typeof this._plugin.max_columns !== "undefined" && this._plugin.render_warning === false) {
      return {
        max_cols: null,
        max_rows: null
      };
    }

    let max_cols, max_rows;
    const [schema, num_columns] = await Promise.all([this._view.schema(), this._view.num_columns()]);
    const schema_columns = Object.keys(schema || {}).length || 1;

    if (typeof this._plugin.max_columns !== "undefined") {
      const column_group_diff = this._plugin.max_columns % schema_columns;
      const column_limit = this._plugin.max_columns + column_group_diff;
      max_cols = column_limit < num_columns ? column_limit : undefined;
    }

    if (typeof this._plugin.max_cells !== "undefined") {
      max_rows = Math.ceil(max_cols ? this._plugin.max_cells / max_cols : this._plugin.max_cells / (num_columns || 1));
    }

    return {
      max_cols,
      max_rows
    };
  }

  async _warn_render_size_exceeded(max_cols, max_rows) {
    if (this._show_warnings && (max_cols || max_rows)) {
      const num_columns = await this._view.num_columns();
      const num_rows = await this._view.num_rows();
      const count = num_columns * num_rows;
      const columns_are_truncated = max_cols && max_cols < num_columns;
      const rows_are_truncated = max_rows && max_rows < num_rows;

      if (columns_are_truncated && rows_are_truncated) {
        this._plugin_information.classList.remove("hidden");

        const warning = _warning`Rendering ${[max_cols, num_columns]} of columns and ${[num_columns * max_rows, count]} of points.`;
        render(warning, this._plugin_information_message);
        return true;
      } else if (columns_are_truncated) {
        this._plugin_information.classList.remove("hidden");

        const warning = _warning`Rendering ${[max_cols, num_columns]} of columns.`;
        render(warning, this._plugin_information_message);
        return true;
      } else if (rows_are_truncated) {
        this._plugin_information.classList.remove("hidden");

        const warning = _warning`Rendering ${[num_columns * max_rows, count]} of points.`;
        render(warning, this._plugin_information_message);
        return true;
      } else {
        this._plugin_information.classList.add("hidden");
      }
    }

    return false;
  }
  /**
   * Calculates the optimal timeout in milliseconds for render events,
   * calculated by 5 frame moving average of this component's render
   * framerate, or explicit override attribute `"throttle"`.
   *
   * @private
   * @returns
   * @memberof PerspectiveElement
   */


  _calculate_throttle_timeout() {
    let timeout;
    const throttle = this.getAttribute("throttle");

    if (throttle === undefined || throttle === "null" || !this.hasAttribute("throttle")) {
      if (!this.__render_times || this.__render_times.length < 5) {
        return 0;
      }

      timeout = this.__render_times.reduce((x, y) => x + y, 0) / this.__render_times.length;
      timeout = Math.min(5000, timeout);
    } else {
      timeout = parseInt(throttle);

      if (isNaN(timeout) || timeout < 0) {
        console.warn(`Bad throttle attribute value "${throttle}".  Can be (non-negative integer) milliseconds.`);
        this.removeAttribute("throttle");
        return 0;
      }
    }

    return Math.max(0, timeout);
  }

  _view_on_update(limit_points) {
    if (!this._debounced) {
      this._debounced = setTimeout(async () => {
        this._debounced = undefined;

        const timer = this._render_time();

        if (this._task && !this._task.initial) {
          this._task.cancel();
        }

        const task = this._task = new CancelTask();
        const updater = this._plugin.update || this._plugin.create;

        try {
          if (limit_points) {
            const {
              max_cols,
              max_rows
            } = await this.get_maxes();

            if (!task.cancelled) {
              await this._warn_render_size_exceeded(max_cols, max_rows);
              await updater.call(this, this._datavis, this._view, task, max_cols, max_rows);
            }
          } else {
            await updater.call(this, this._datavis, this._view, task);
          }

          timer();
          task.cancel();
        } finally {
          this.dispatchEvent(new Event("perspective-view-update"));
        }
      }, this._calculate_throttle_timeout());
    }
  }

  async _validate_filters() {
    const filters = [];

    for (const node of this._get_view_filter_nodes()) {
      const operandNode = node.shadowRoot.getElementById("filter_operand");
      const exclamation = node.shadowRoot.getElementById("row_exclamation");
      const {
        operator,
        operand
      } = JSON.parse(node.getAttribute("filter"));
      const filter = [node.getAttribute("name"), operator, operand];

      if (await this._table.is_valid_filter(filter)) {
        filters.push(filter);
        operandNode.style.borderColor = "";
        exclamation.hidden = true;
      } else {
        operandNode.style.borderColor = "red";
        exclamation.hidden = false;
      }
    }

    return filters;
  }

  _is_config_changed(config) {
    const plugin_name = this.getAttribute("plugin");

    if (isEqual(config, this._previous_config) && plugin_name === this._previous_plugin_name) {
      return false;
    } else {
      this._previous_config = config;
      this._previous_plugin_name = plugin_name;
      return true;
    }
  }

  async _new_view({
    force_update = false,
    ignore_size_check = false,
    limit_points = true
  } = {}) {
    if (!this._table) return;

    this._check_responsive_layout();

    const row_pivots = this._get_view_row_pivots();

    const column_pivots = this._get_view_column_pivots();

    const filters = await this._validate_filters();

    const view_aggregates = this._get_view_aggregates();

    if (view_aggregates.length === 0) return;

    const sort = this._get_view_sorts();

    let columns = view_aggregates.map(x => x.column);
    let aggregates = {};

    for (const a of view_aggregates) {
      aggregates[a.column] = a.op;
    }

    for (const s of sort) {
      const name = s[0];

      if (columns.indexOf(name) === -1 && !(column_pivots.indexOf(s) > -1 || row_pivots.indexOf(s) > -1)) {
        const all = this.get_aggregate_attribute();
        const {
          column,
          op
        } = all.reduce((obj, y) => y.column === name ? y : obj);
        aggregates[column] = op;
      }
    }

    const expressions = this._get_view_expressions();

    const config = {
      filter: filters,
      row_pivots: row_pivots,
      column_pivots: column_pivots,
      aggregates: aggregates,
      columns: columns,
      sort: sort,
      expressions: expressions
    };

    if (this._task) {
      this._task.cancel();
    }

    if (this._view) {
      this._view.remove_update(this._view_updater);

      this._vieux.delete_view();

      this._view.delete();
    }

    try {
      this._view = await this._table.view(config);

      this._view_updater = () => this._view_on_update(limit_points);

      this._view.on_update(this._view_updater);
    } catch (e) {
      // Delete the view handle only if it exists - if this._view is
      // undefined, calling delete will throw its own "cannot read
      // property of undefined" error and squash the original, more
      // informative error message on why the view could not be created.
      if (this._view) this._view.delete();
      throw e;
    }

    this._vieux.set_view(this._view);

    const timer = this._render_time();

    const task = this._task = new CancelTask(() => {}, true);

    try {
      const {
        max_cols,
        max_rows
      } = await this.get_maxes();

      if (task.cancelled) {
        return;
      }

      if (!ignore_size_check) {
        await this._warn_render_size_exceeded(max_cols, max_rows);
      }

      if (limit_points) {
        await this._plugin.create.call(this, this._datavis, this._view, task, max_cols, max_rows, force_update);
      } else {
        await this._plugin.create.call(this, this._datavis, this._view, task, undefined, undefined, force_update);
      }
    } catch (err) {
      console.warn(err);
    } finally {
      if (!this.__render_times) {
        this.__render_times = [];
        this.dispatchEvent(new Event("perspective-view-update"));
      }

      timer();
      task.cancel();
    }
  }

  _check_loaded_table() {
    if (this._table && this._table_resolver) {
      const table = this._table;
      const resolve = this._table_resolver;
      delete this._table;
      delete this._table_resolver;

      this._load_table(table, resolve);
    }
  }

  _render_time() {
    const t = performance.now();
    return () => {
      this.__render_times.unshift(performance.now() - t);

      this.__render_times = this.__render_times.slice(0, 5);
    };
  }

  _restyle_plugin() {
    if (this._plugin.styleElement) {
      const task = this._task = new CancelTask();

      this._plugin.styleElement.call(this, this._datavis, this._view, task);
    }
  }

  _clear_state() {
    if (this._task) {
      this._task.cancel();
    }

    const all = [];

    if (this._view) {
      const view = this._view;
      this._view = undefined;
      all.push(view.delete());
      view.remove_update(this._view_updater);
      view.remove_delete();
    }

    return Promise.all(all);
  }

  _set_updating() {
    this.toggleAttribute("updating", true);
    let resolve;
    this._updating_promise = new Promise(_resolve => {
      resolve = () => {
        _resolve();
      };
    });
    return resolve;
  }

  async _update(ignore_size_check, force_update, limit_points) {
    await new Promise(setTimeout);
    await this._new_view({
      ignore_size_check,
      force_update,
      limit_points
    });
  }

  async _debounce_update({
    force_update = false,
    ignore_size_check = false,
    limit_points = true
  } = {}) {
    if (this._table) {
      let resolve = this._set_updating();

      await this._update(ignore_size_check, force_update, limit_points);
      resolve();
    }
  }

}, (_applyDecoratedDescriptor(_class$1.prototype, "_update", [_dec$1], Object.getOwnPropertyDescriptor(_class$1.prototype, "_update"), _class$1.prototype)), _class$1));

/**
 * Render `<option>` blocks
 * @param {*} names name objects
 */

const options = vals => {
  const opts = [];

  for (let name in vals) {
    opts.push(html`
            <option value="${name}">${vals[name].name || name}</option>
        `);
  }

  return opts;
};

class DomElement extends PerspectiveElement {
  _clear_columns() {
    this._inactive_columns.innerHTML = "";
    this._active_columns.innerHTML = "";
  }

  set_aggregate_attribute(aggs) {
    let is_set = false;
    let aggregates = aggs.reduce((obj, agg) => {
      if (this._aggregate_defaults[agg.column] !== agg.op) {
        obj[agg.column] = agg.op;
        is_set = true;
      }

      return obj;
    }, {});

    if (is_set) {
      this.setAttribute("aggregates", JSON.stringify(aggregates));
    } else {
      this.removeAttribute("aggregates");
    }
  }

  _get_type(name) {
    let all = this._get_view_inactive_columns();

    if (all.length > 0) {
      const type = all.find(x => x.getAttribute("name") === name);

      if (type) {
        return type.getAttribute("type");
      } else {
        return "integer";
      }
    } else {
      return "";
    }
  }

  _set_row_type(row) {
    const weights = this._get_view_inactive_columns().filter(x => x.getAttribute("type") === "integer" || x.getAttribute("type") === "float").map(x => x.getAttribute("name"));

    row.set_weights(weights);
    row.setAttribute("type", this._get_type(row.getAttribute("name")));
  } // Generates a new row in state + DOM


  _new_row(name, type, aggregate, filter, sort, expression) {
    let row = document.createElement("perspective-row");
    type = type || this._get_type(name);

    if (!aggregate) {
      let aggregates = this.get_aggregate_attribute();

      if (aggregates) {
        aggregate = aggregates.find(x => x.column === name);

        if (aggregate) {
          aggregate = aggregate.op;
        } else {
          aggregate = get_type_config(type).aggregate;
        }
      } else {
        aggregate = get_type_config(type).aggregate;
      }
    }

    if (filter) {
      row.setAttribute("filter", filter);

      if (type === "string" || type === "date" || type === "datetime") {
        // Get all unique values for the column - because all options
        // must be valid column names, recreate expressions if the
        // expression is in the filter.
        const expressions = this._get_view_expressions(); // either the expression string or undefined


        let expression = findExpressionByAlias(name, expressions); // If the filter is an expression, we need to recreate the
        // expression column.

        this._table.view({
          row_pivots: [name],
          columns: [],
          expressions: expression ? [expression] : []
        }).then(async view => {
          // set as a property so we can delete it after the
          // autocomplete choices are set.
          this._filter_view = view;
          let nrows = await view.num_rows();

          if (nrows < 100000) {
            // Autocomplete
            const json = await view.to_json({
              end_row: 10
            });
            row.choices(this._autocomplete_choices(json, type));
          } else {
            console.warn(`perspective-viewer did not generate autocompletion results - ${nrows} is greater than limit of 100,000 rows.`);
          }
        }).finally(() => {
          var _this$_filter_view;

          // Clean up the View on the Emscripten heap.
          (_this$_filter_view = this._filter_view) === null || _this$_filter_view === void 0 ? void 0 : _this$_filter_view.delete();
          delete this._filter_view;
        });
      }
    }

    if (sort) {
      row.setAttribute("sort-order", sort);
    } else {
      if (this._get_view_column_pivots().indexOf(name) > -1) {
        row.setAttribute("sort-order", "col asc");
      } else {
        row.setAttribute("sort-order", "asc");
      }
    }

    const weights = this._get_view_inactive_columns().filter(x => x.getAttribute("type") === "integer" || x.getAttribute("type") === "float").map(x => x.getAttribute("name"));

    row.set_weights(weights);

    if (name === null) {
      row.classList.add("null-column");
    } else {
      row.setAttribute("type", type);
      row.setAttribute("name", name);
    }

    row.setAttribute("aggregate", Array.isArray(aggregate) ? JSON.stringify(aggregate) : aggregate);
    row.addEventListener("visibility-clicked", this._column_visibility_clicked.bind(this));
    row.addEventListener("aggregate-selected", this._column_aggregate_clicked.bind(this));
    row.addEventListener("filter-selected", this._column_filter_clicked.bind(this));
    row.addEventListener("close-clicked", event => dragend.call(this, event.detail));
    row.addEventListener("sort-order", this._sort_order_clicked.bind(this));
    row.addEventListener("row-drag", () => {
      this.classList.add("dragging");
      this._original_index = Array.prototype.slice.call(this._active_columns.children).findIndex(x => x.getAttribute("name") === name);

      if (this._original_index !== -1) {
        this._drop_target_hover = this._active_columns.children[this._original_index];
        setTimeout(() => row.setAttribute("drop-target", true));
      } else {
        this._drop_target_hover = this._new_row(name, type, aggregate);
      }
    });
    row.addEventListener("row-dragend", () => {
      this.classList.remove("dragging");
    });

    if (expression) {
      row.classList.add("expression"); // used by the viewer to diff expression columns

      row.setAttribute("expression", expression); // expression without the newline alias - allows us to hover
      // and see the expression as typed by the user.

      const raw_expr = getRawExpression(expression);
      row.setAttribute("title", raw_expr);
    }

    return row;
  }
  /**
   * Add expression columns to the DOM.
   *
   * @param {*} expressions
   * @param {*} expression_schema
   */


  _update_expressions_view(expressions, expression_schema) {
    const columns = this._get_view_all_column_names();

    const active = this._get_view_active_column_names();

    if (expressions.length === 0) {
      return;
    }

    let added_count = 0;
    const attr = JSON.parse(this.getAttribute("columns")) || [];
    let reset_columns_attr = false;

    for (const expr of expressions) {
      // All expressions are guaranteed to have alias at this point. If
      // it does not, then skip the expression.
      const alias = getExpressionAlias(expr);

      if (alias === undefined) {
        console.warn(`Not applying expression ${expr} as it does not have an alias set.`);
        continue;
      } //
      // Check for whether the expression is in the attribute but
      // NOT in the DOM - occurs when restore is called and a race
      // condition between `expressions` and `columns` occurs.


      const should_reset = !columns.includes(alias) && attr.includes(alias);

      if (should_reset) {
        reset_columns_attr = true;
      } // If the column already exists or is already in the active DOM,
      // don't add it to the inactive DOM


      const should_add = !columns.includes(alias) && !active.includes(alias);

      if (!should_add) {
        continue;
      }

      let type = expression_schema[alias];

      const row = this._new_row(alias, type, null, null, null, expr);

      this._inactive_columns.insertBefore(row, this._inactive_columns.childNodes[0] || null);

      added_count++;
    }

    if (reset_columns_attr) {
      this._update_column_view(attr, true);
    } else {
      // Remove collapse so that new inactive columns show up
      if (added_count > 0 && this._inactive_columns.parentElement.classList.contains("collapse")) {
        this._inactive_columns.parentElement.classList.remove("collapse");
      }
    }
  }
  /**
   * Given two arrays of expressions, return an array of expressions that
   * are in the old set but not the new set, i.e. they should be removed
   * because they do not need to be included or re-calculated.
   *
   * @param {Array<String>} old_expressions
   * @param {Array<String>} old_expressions
   */


  _diff_expressions(old_expressions, new_expressions) {
    const to_remove = [];

    for (const expr of old_expressions) {
      if (!new_expressions.includes(expr)) {
        to_remove.push(expr);
      }
    }

    return to_remove;
  }
  /**
   * When the `expressions` attribute is set to null, undefined, or [] or
   * is unset, or when required, remove expression columns from the
   * viewer. If `expressions` is undefined, all expressions are removed,
   * otherwise the specified expressions will be removed.
   *
   * @param {Array<String>} expressions
   */


  _reset_expressions_view(expressions) {
    if (expressions) {
      // Only remove columns specified in `expressions`
      const columns = this._get_view_active_column_names().filter(x => !expressions.includes(x));

      const aggregates = this._get_view_aggregates().filter(x => !expressions.includes(x.column));

      const rp = this._get_view_row_pivots().filter(x => !expressions.includes(x));

      const cp = this._get_view_column_pivots().filter(x => !expressions.includes(x));

      const sort = this._get_view_sorts().filter(x => !expressions.includes(x[0]));

      const filters = this._get_view_filters().filter(x => !expressions.includes(x[0])); // Aggregates as an array is from the attribute API


      this.set_aggregate_attribute(aggregates);
      this.setAttribute("columns", JSON.stringify(columns));
      this.setAttribute("row-pivots", JSON.stringify(rp));
      this.setAttribute("column-pivots", JSON.stringify(cp));
      this.setAttribute("sort", JSON.stringify(sort));
      this.setAttribute("filters", JSON.stringify(filters));
    } else {
      // `expressions` is empty, so remove all columns that do not
      // exist on the underlying table.
      if (this._table) {
        this._table.columns().then(table_columns => {
          const columns = this._get_view_active_column_names().filter(x => table_columns.includes(x));

          const aggregates = this._get_view_aggregates().filter(x => table_columns.includes(x.column));

          const rp = this._get_view_row_pivots().filter(x => table_columns.includes(x));

          const cp = this._get_view_column_pivots().filter(x => table_columns.includes(x));

          const sort = this._get_view_sorts().filter(x => table_columns.includes(x[0]));

          const filters = this._get_view_filters().filter(x => table_columns.includes(x[0])); // Aggregates as an array is from the attribute API


          this.set_aggregate_attribute(aggregates);
          this.setAttribute("columns", JSON.stringify(columns));
          this.setAttribute("row-pivots", JSON.stringify(rp));
          this.setAttribute("column-pivots", JSON.stringify(cp));
          this.setAttribute("sort", JSON.stringify(sort));
          this.setAttribute("filters", JSON.stringify(filters));
        });
      } else {
        // this would happen if you tried to set expressions without
        // a table, and then restored/removed expressions/tried to apply
        // an invalid expression. In this case just reset the viewer.
        this.removeAttribute("columns");
        this.removeAttribute("row-pivots");
        this.removeAttribute("column-pivots");
        this.removeAttribute("sort");
        this.removeAttribute("filters");
        this.removeAttribute("aggregates");
      }
    } // Remove inactive expression columns from the DOM


    const inactive_expressions = this._get_view_inactive_columns().filter(x => x.classList.contains("expression"));

    for (const expr of inactive_expressions) {
      this._inactive_columns.removeChild(expr);
    } // Re-check on whether to collapse inactive columns


    const pop_cols = this._get_view_active_columns().filter(x => typeof x !== "undefined" && x !== null);

    const lis = this._get_view_inactive_columns();

    if (pop_cols.length === lis.length) {
      this._columns_container.classList.add("collapse");
    } else {
      this._columns_container.classList.remove("collapse");
    }
  }

  _update_column_view(columns, reset = false) {
    if (!columns) {
      columns = this._get_view_active_column_names();
    }

    if (this._plugin.initial && this._plugin.initial.names) {
      while (columns.length < this._plugin.initial.names.length) {
        columns.push(null);
      }
    } // If columns were not passed in, this is needed to keep the attribute
    // API in sync with DOM state.


    this.setAttribute("columns", JSON.stringify(columns));
    const pop_cols = columns.filter(x => typeof x !== "undefined" && x !== null);

    const lis = this._get_view_inactive_columns();

    if (pop_cols.length === lis.length) {
      this._columns_container.classList.add("collapse");
    } else {
      this._columns_container.classList.remove("collapse");
    }

    lis.forEach(x => {
      const index = pop_cols.indexOf(x.getAttribute("name"));

      if (index === -1) {
        x.classList.remove("active");
      } else {
        x.classList.add("active");
      }
    });

    if (reset) {
      this._update_column_list(columns, this._active_columns, (name, expressions) => {
        if (name === null) {
          return this._new_row(null);
        } else {
          const ref = lis.find(x => x.getAttribute("name") === name);

          if (ref) {
            const name = ref.getAttribute("name"); // either the expression string or undefined

            let expression = findExpressionByAlias(name, expressions);
            return this._new_row(name, ref.getAttribute("type"), undefined, undefined, undefined, expression);
          }
        }
      });
    }
  }

  _update_column_list(columns, container, callback, accessor) {
    accessor = accessor || ((x, y) => y.getAttribute("name") === x);

    const active_columns = Array.prototype.slice.call(container.children); // Make sure the `expression` class and attribute is set on expressions

    const expressions = this._get_view_expressions();

    for (let i = 0, j = 0; i < active_columns.length || j < columns.length; i++, j++) {
      const name = columns[j];
      const col = active_columns[i];
      const next_col = active_columns[i + 1];

      if (!col) {
        const node = callback(name, expressions);

        if (node) {
          container.appendChild(node);
        }
      } else if (typeof name === "undefined") {
        container.removeChild(col);
      } else if (accessor(name, col)) {
        this._set_row_type(col);
      } else {
        if (col.classList.contains("null-column")) {
          const node = callback(name, expressions);

          if (node) {
            container.replaceChild(node, col);
          }
        } else if (next_col && accessor(name, next_col)) {
          container.removeChild(col);
          i++; //  j--;
        } else {
          const node = callback(name, expressions);

          if (node) {
            container.insertBefore(node, col);
            i--;
          }
        }
      }
    }
  }

  _set_row_styles() {
    let style = "";

    if (this._plugin.initial && this._plugin.initial.names) {
      for (const nidx in this._plugin.initial.names) {
        const name = this._plugin.initial.names[nidx];
        style += `#active_columns perspective-row:nth-child(${parseInt(nidx) + 1}){margin-top:23px;}`;
        style += `#active_columns perspective-row:nth-child(${parseInt(nidx) + 1}):before{content:"${name}";}`;
      }
    }

    this.shadowRoot.querySelector("#psp_styles").innerHTML = style;
  }

  _show_column_container() {
    this.shadowRoot.querySelector("#columns_container").style.visibility = "visible";
  }

  _show_side_panel_actions() {
    this.shadowRoot.querySelector("#side_panel__actions").style.visibility = "visible";
  }

  _remove_null_columns(since_index = 0) {
    const elems = this._get_view_active_columns();

    while (++since_index < elems.length) {
      const elem = elems[since_index];

      if (elem.classList.contains("null-column")) {
        this.shadowRoot.querySelector("#active_columns").removeChild(elem);
      }
    }
  }

  _set_column_defaults() {
    const cols = this._get_view_inactive_columns();

    const active_cols = this._get_view_active_valid_columns();

    const valid_active_cols = this._get_view_active_valid_column_names();

    if (cols.length > 0) {
      if (this._plugin.initial) {
        let pref = [];
        let count = this._plugin.initial.count || 2;

        this._fill_numeric(active_cols, pref);

        this._fill_numeric(cols, pref);

        this._fill_numeric(cols, pref, true);

        pref = pref.slice(0, count);
        const labels = this._plugin.initial.names;

        while (labels && pref.length < labels.length) {
          pref.push(null);
        }

        this.setAttribute("columns", JSON.stringify(pref));
      } else if (this._plugin.selectMode === "select") {
        this.setAttribute("columns", JSON.stringify([cols[0].getAttribute("name")]));
      } else {
        this.setAttribute("columns", JSON.stringify(valid_active_cols));

        this._remove_null_columns();
      }
    }
  }

  _fill_numeric(cols, pref, bypass = false) {
    for (let col of cols) {
      let type = col.getAttribute("type");
      let name = col.getAttribute("name");

      if (bypass || ["float", "integer"].indexOf(type) > -1 && pref.indexOf(name) === -1) {
        pref.push(name);
      }
    }
  }

  async _check_responsive_layout() {
    if (this.shadowRoot) {
      const app = this.shadowRoot.querySelector("#app");

      if (this.clientHeight < 500 && this.clientWidth > 600 && this._get_view_columns({
        active: false
      }).length > this._get_view_columns().length) {
        if (!app.classList.contains("columns_horizontal")) {
          const old = this._persisted_side_panel_width;
          this._persisted_side_panel_width = this._side_panel.style.width;
          this._side_panel.style.width = old || "";
          app.classList.add("columns_horizontal");
        }
      } else if (app.classList.contains("columns_horizontal")) {
        const panel = this.shadowRoot.querySelector("#pivot_chart_container");
        panel.clientWidth + this._side_panel.clientWidth;
        const width = this._persisted_side_panel_width || panel.clientWidth + this._side_panel.clientWidth / 2;
        const height = panel.clientHeight + 50;
        await this._pre_resize(width, height, () => {
          const old = this._persisted_side_panel_width;
          this._persisted_side_panel_width = this._side_panel.style.width;
          this._side_panel.style.width = old || "";
          app.classList.remove("columns_horizontal");
        });
        return true;
      } // else if (this.clientWidth < 600 && this.clientHeight < 500) {
      // if (!app.classList.contains("responsive_collapse_2")) {
      //     app.classList.add("responsive_collapse_2");
      // }
      // } else if (app.classList.contains("responsive_collapse_2")) {
      // app.classList.remove("responsive_collapse_2");
      // }


      return false;
    }

    return false;
  } // setup functions


  _register_ids() {
    this._app = this.shadowRoot.querySelector("#app");
    this._aggregate_selector = this.shadowRoot.querySelector("#aggregate_selector");
    this._vis_selector = this.shadowRoot.querySelector("#vis_selector");
    this._filters = this.shadowRoot.querySelector("#filters");
    this._row_pivots = this.shadowRoot.querySelector("#row_pivots");
    this._column_pivots = this.shadowRoot.querySelector("#column_pivots");
    this._datavis = this.shadowRoot.querySelector("#pivot_chart");
    this._active_columns = this.shadowRoot.querySelector("#active_columns");
    this._inactive_columns = this.shadowRoot.querySelector("#inactive_columns");
    this._side_panel_actions = this.shadowRoot.querySelector("#side_panel__actions");
    this._add_expression_button = this.shadowRoot.querySelector("#add-expression");
    this._side_panel = this.shadowRoot.querySelector("#side_panel");
    this._top_panel = this.shadowRoot.querySelector("#top_panel");
    this._sort = this.shadowRoot.querySelector("#sort");
    this._transpose_button = this.shadowRoot.querySelector("#transpose_button");
    this._plugin_information = this.shadowRoot.querySelector(".plugin_information");
    this._plugin_information_action = this.shadowRoot.querySelector(".plugin_information__action");
    this._plugin_information_message = this.shadowRoot.querySelector("#plugin_information_count");
    this._columns_container = this.shadowRoot.querySelector("#columns_container");
    this._vieux = this.shadowRoot.querySelector("perspective-vieux");
  } // sets state, manipulates DOM


  _register_view_options() {
    let current_renderers = renderers.getInstance();
    render(options(current_renderers), this._vis_selector);
  }

  _autocomplete_choices(json, type) {
    const choices = [];
    const type_config = get_type_config(type);

    for (let i = 1; i < json.length; i++) {
      const row_path = json[i].__ROW_PATH__;

      if (Array.isArray(row_path) && row_path.length > 0 && row_path[0]) {
        let choice = row_path[0];

        if (type === "date" || type === "datetime") {
          choice = new Date(choice);
          choice = choice.toLocaleString("en-US", type_config.format);
        }

        choices.push(choice);
      }
    }

    return choices;
  }

}

class ActionElement extends DomElement {
  async _toggle_config(event) {
    if (!event || event.button !== 2) {
      this._show_config = !this._show_config;
      const panel = this.shadowRoot.querySelector("#pivot_chart_container");

      if (!this._show_config) {
        await this._pre_resize(panel.clientWidth + this._side_panel.clientWidth, panel.clientHeight + this._top_panel.clientHeight, () => {
          this._app.classList.remove("settings-open");

          this.removeAttribute("settings");
        }, () => this.dispatchEvent(new CustomEvent("perspective-toggle-settings", {
          detail: this._show_config
        })));
      } else {
        await this._post_resize(() => {
          this.toggleAttribute("settings", true);
        }, () => {
          this._app.classList.add("settings-open");

          this.dispatchEvent(new CustomEvent("perspective-toggle-settings", {
            detail: this._show_config
          }));
        });
      }
    }
  }
  /**
   * Given a targe `width` and `height`, pre-size the plugin before modifying
   * the HTML to reduce visual tearing.
   *
   * @private
   * @param {*} width
   * @param {*} height
   * @param {*} post Function to run once action is complete
   * @param {*} [pre=undefined] Function to run once visual effects have been
   * applied.  This may be before `post`, as pre-sizing will be delayed when
   * the target size is a sub-window of the current view.
   * @memberof ActionElement
   */


  async _pre_resize(width, height, post, pre = undefined) {
    this._datavis.style.width = `${width}px`;
    this._datavis.style.height = `${height}px`;

    try {
      if (!document.hidden && this.offsetParent) {
        await this._plugin.resize.call(this);
      }
    } finally {
      pre === null || pre === void 0 ? void 0 : pre();
      this._datavis.style.width = "100%";
      this._datavis.style.height = "100%";
      post();
    }
  }

  async _post_resize(post, pre) {
    pre === null || pre === void 0 ? void 0 : pre();

    try {
      if (!document.hidden && this.offsetParent) {
        await this._plugin.resize.call(this);
      }
    } finally {
      post();
    }
  }
  /**
   * Display the expressions editor.
   *
   * @param {*} event
   */


  _open_expression_editor(event) {
    event.stopImmediatePropagation();

    this._vieux._open_expression_editor(this._add_expression_button);

    this._add_expression_button.classList.toggle("expr_editor_open", true);
  }

  _close_expression_editor(event) {
    event.stopImmediatePropagation();

    this._add_expression_button.classList.toggle("expr_editor_open", false);
  }

  _save_expression(expression) {
    const expressions = this._get_view_expressions();

    expressions.push(expression);
    this.setAttribute("expressions", JSON.stringify(expressions));
  }

  async _type_check_expression(event) {
    const {
      expression,
      alias
    } = event.detail;

    const expressions = this._get_view_expressions();

    const is_duplicate = findExpressionByAlias(alias, expressions);

    if (expressions.includes(expression) || is_duplicate) {
      console.warn(`Cannot apply duplicate expression: "${expression}"`);
      const result = {
        expression_schema: {},
        errors: {}
      };
      result.errors[alias] = "Value Error - Cannot apply duplicate expression.";

      this._expression_editor.type_check_expression(result);

      return;
    }

    if (!expression || expression.length === 0) {
      this._expression_editor.type_check_expression({});

      return;
    }

    this._expression_editor.type_check_expression(await this._table.validate_expressions([expression]));
  }

  _column_visibility_clicked(ev) {
    const parent = ev.currentTarget;
    const is_active = parent.parentElement.getAttribute("id") === "active_columns";

    if (is_active) {
      var _this$_plugin$initial;

      const min_columns = ((_this$_plugin$initial = this._plugin.initial) === null || _this$_plugin$initial === void 0 ? void 0 : _this$_plugin$initial.count) || 1;

      if (this._get_view_active_valid_column_count() === min_columns) {
        return;
      }

      if (ev.detail.shiftKey) {
        for (let child of Array.prototype.slice.call(this._active_columns.children)) {
          if (child !== parent) {
            this._active_columns.removeChild(child);
          }
        }
      } else {
        var _this$_plugin$initial2, _this$_plugin$initial3, _this$_plugin$initial4;

        const index = Array.prototype.slice.call(this._active_columns.children).indexOf(parent);

        if (index < ((_this$_plugin$initial2 = this._plugin.initial) === null || _this$_plugin$initial2 === void 0 ? void 0 : _this$_plugin$initial2.count)) {
          return;
        } else if (index < ((_this$_plugin$initial3 = this._plugin.initial) === null || _this$_plugin$initial3 === void 0 ? void 0 : (_this$_plugin$initial4 = _this$_plugin$initial3.names) === null || _this$_plugin$initial4 === void 0 ? void 0 : _this$_plugin$initial4.length) - 1) {
          this._active_columns.insertBefore(this._new_row(null), parent);
        }

        this._active_columns.removeChild(parent);
      }
    } else {
      var _cols$i;

      if (ev.detail.shiftKey && this._plugin.selectMode === "toggle" || !ev.detail.shiftKey && this._plugin.selectMode === "select") {
        for (let child of Array.prototype.slice.call(this._active_columns.children)) {
          this._active_columns.removeChild(child);
        }
      }

      let row = this._new_row(parent.getAttribute("name"), parent.getAttribute("type"), undefined, undefined, undefined, parent.getAttribute("expression"));

      const cols = this._get_view_active_columns();

      let i = cols.length - 1;

      if (!cols[i] || !((_cols$i = cols[i]) !== null && _cols$i !== void 0 && _cols$i.classList.contains("null-column"))) {
        this._active_columns.appendChild(row);
      } else while (i-- > 0) {
        if (!cols[i].classList.contains("null-column")) {
          this._active_columns.replaceChild(row, cols[i + 1]);

          break;
        }
      }
    }

    this._check_responsive_layout();

    this._update_column_view();
  }

  _column_aggregate_clicked() {
    let aggregates = this.get_aggregate_attribute();

    let new_aggregates = this._get_view_aggregates();

    for (let aggregate of aggregates) {
      let updated_agg = new_aggregates.find(x => x.column === aggregate.column);

      if (updated_agg) {
        aggregate.op = updated_agg.op;
      }
    }

    this.set_aggregate_attribute(aggregates);

    this._update_column_view();

    this._debounce_update();
  }

  _column_filter_clicked() {
    let new_filters = this._get_view_filters();

    this._updating_filter = true;
    this.setAttribute("filters", JSON.stringify(new_filters));
    this._updating_filter = false;

    this._debounce_update();
  }

  _increment_sort(sort, column_sorting, abs_sorting) {
    let sort_orders = ["asc", "desc"];

    if (column_sorting) {
      sort_orders.push("col asc", "col desc");
    }

    if (abs_sorting) {
      sort_orders = sort_orders.map(x => `${x} abs`);
    }

    sort_orders.push("none");
    return sort_orders[(sort_orders.indexOf(sort) + 1) % sort_orders.length];
  }

  _sort_order_clicked(event) {
    const row = event.target;
    const abs_sorting = event.detail.shiftKey && row.getAttribute("type") !== "string";

    const new_sort_order = this._increment_sort(row.getAttribute("sort-order"), this._get_view_column_pivots().length > 0, abs_sorting);

    row.setAttribute("sort-order", new_sort_order);

    const sort = this._get_view_sorts();

    this.setAttribute("sort", JSON.stringify(sort));
  } // edits state


  _transpose() {
    const has_row = this.hasAttribute("row-pivots");
    const has_col = this.hasAttribute("column-pivots");

    if (has_row && has_col) {
      let row_pivots = this.getAttribute("row-pivots");
      this.setAttribute("row-pivots", this.getAttribute("column-pivots"));
      this.setAttribute("column-pivots", row_pivots);
    } else if (has_row) {
      let row_pivots = this.getAttribute("row-pivots");
      this.removeAttribute("row-pivots");
      this.setAttribute("column-pivots", row_pivots);
    } else if (has_col) {
      let column_pivots = this.getAttribute("column-pivots");
      this.removeAttribute("column-pivots");
      this.setAttribute("row-pivots", column_pivots);
    } else {
      this.removeAttribute("column-pivots");
      this.removeAttribute("row-pivots");
    }
  }

  _vis_selector_changed() {
    var _this$_plugin$initial5;

    this._plugin_information.classList.add("hidden");

    this.setAttribute("plugin", this._vis_selector.value);

    this._active_columns.classList.remove("one_lock", "two_lock");

    const classname = ["one_lock", "two_lock"][((_this$_plugin$initial5 = this._plugin.initial) === null || _this$_plugin$initial5 === void 0 ? void 0 : _this$_plugin$initial5.count) - 1];

    if (classname) {
      this._active_columns.classList.add(classname);
    }

    this._debounce_update();
  } // most of these are drag and drop handlers - how to clean up?


  _register_callbacks() {
    this._sort.addEventListener("drop", drop.bind(this));

    this._sort.addEventListener("dragend", dragend.bind(this));

    this._sort.addEventListener("dragenter", dragenter.bind(this));

    this._sort.addEventListener("dragover", dragover.bind(this));

    this._sort.addEventListener("dragleave", dragleave.bind(this));

    this._row_pivots.addEventListener("drop", drop.bind(this));

    this._row_pivots.addEventListener("dragend", dragend.bind(this));

    this._row_pivots.addEventListener("dragenter", dragenter.bind(this));

    this._row_pivots.addEventListener("dragover", dragover.bind(this));

    this._row_pivots.addEventListener("dragleave", dragleave.bind(this));

    this._column_pivots.addEventListener("drop", drop.bind(this));

    this._column_pivots.addEventListener("dragend", dragend.bind(this));

    this._column_pivots.addEventListener("dragenter", dragenter.bind(this));

    this._column_pivots.addEventListener("dragover", dragover.bind(this));

    this._column_pivots.addEventListener("dragleave", dragleave.bind(this));

    this._filters.addEventListener("drop", drop.bind(this));

    this._filters.addEventListener("dragend", dragend.bind(this));

    this._filters.addEventListener("dragenter", dragenter.bind(this));

    this._filters.addEventListener("dragover", dragover.bind(this));

    this._filters.addEventListener("dragleave", dragleave.bind(this));

    this._active_columns.addEventListener("drop", column_drop.bind(this));

    this._active_columns.addEventListener("dragenter", dragenter.bind(this));

    this._active_columns.addEventListener("dragend", column_dragend.bind(this));

    this._active_columns.addEventListener("dragover", column_dragover.bind(this));

    this._active_columns.addEventListener("dragleave", column_dragleave.bind(this));

    this._add_expression_button.addEventListener("click", this._open_expression_editor.bind(this));

    this._add_expression_button.addEventListener("-perspective-close-expression", this._close_expression_editor.bind(this));

    this._transpose_button.addEventListener("click", this._transpose.bind(this));

    this._vis_selector.addEventListener("change", this._vis_selector_changed.bind(this));

    this._vieux.addEventListener("perspective-vieux-reset", () => this.reset());

    this._vieux.addEventListener("perspective-vieux-resize", () => this._plugin.resize.call(this));

    this._vieux.addEventListener("-perspective-add-expression", ({
      detail
    }) => this._save_expression(detail));

    this._plugin_information_action.addEventListener("click", () => {
      this._debounce_update({
        ignore_size_check: true,
        limit_points: false
      });

      this._plugin_information.classList.add("hidden");

      this._plugin.render_warning = false;
    });
  }

}

var _dec$2, _class$2, _class2;
/**
 * Module for the `<perspective-viewer>` custom element.
 *
 * This module has no exports, but importing it has a side
 * effect: the {@link module:perspective_viewer~PerspectiveViewer} class is
 * registered as a custom element, after which it can be used as a standard DOM
 * element.
 *
 * The documentation in this module defines the instance structure of a
 * `<perspective-viewer>` DOM object instantiated typically, through HTML or any
 * relevent DOM method e.g. `document.createElement("perspective-viewer")` or
 * `document.getElementsByTagName("perspective-viewer")`.
 *
 * @module perspective-viewer
 */

const PERSISTENT_ATTRIBUTES = ["selectable", "editable", "plugin", "expressions", "row-pivots", "column-pivots", "aggregates", "filters", "sort", "columns"]; // There is no way to provide a default rejection handler within a promise and
// also not lock the await-er, so this module attaches a global handler to
// filter out cancelled query messages.

window.addEventListener("unhandledrejection", event => {
  var _event$reason;

  if (((_event$reason = event.reason) === null || _event$reason === void 0 ? void 0 : _event$reason.message) === "View method cancelled") {
    event.preventDefault();
  }
});
/**
 * The HTMLElement class for `<perspective-viewer>` custom element.
 *
 * This class is not exported, so this constructor cannot be invoked in the
 * typical manner; instead, instances of the class are created through the
 * Custom Elements DOM API.
 *
 * Properties of an instance of this class, such as
 * {@link module:perspective_viewer~PerspectiveViewer#columns}, are reflected on
 * the DOM element as Attributes, and should be accessed as such - e.g.
 * `instance.setAttribute("columns", JSON.stringify(["a", "b"]))`.
 *
 * @class PerspectiveViewer
 * @extends {HTMLElement}
 * @example
 * // Create a new `<perspective-viewer>`
 * const elem = document.createElement("perspective-viewer");
 * elem.setAttribute("columns", JSON.stringify(["a", "b"]));
 * document.body.appendChild(elem);
 *
 */

// eslint-disable-next-line no-unused-vars
(_dec$2 = bindTemplate(template$2, css_248z$2, css_248z$3), _dec$2(_class$2 = (_class2 = class PerspectiveViewer extends ActionElement {
  constructor() {
    super();
    this._show_config = true;
    this._show_warnings = true;
    this.__render_times = [];
    this._resize_handler = this.notifyResize.bind(this);
    this._edit_port = null;
    this._edit_port_lock = invertPromise();
    window.addEventListener("resize", this._resize_handler);
  }

  connectedCallback() {
    if (Object.keys(renderers.getInstance()).length === 0) {
      register_debug_plugin();
    }

    this.toggleAttribute("settings", false);

    this._register_ids();

    this._register_callbacks();

    this._register_view_options();

    this._check_loaded_table();
  }
  /**
   * Sets this `perspective.table.view`'s `sort` property, an Array of column
   * names.
   *
   * @kind member
   * @type {Array<String>} Array of arrays tuples of column name and
   * direction, where the possible values are "asc", "desc", "asc abs", "desc
   * abs" and "none".
   * @fires PerspectiveViewer#perspective-config-update
   * @example <caption>via Javascript DOM</caption>
   * let elem = document.getElementById('my_viewer');
   * elem.setAttribute('sort', JSON.stringify([["x","desc"]));
   * @example <caption>via HTML</caption>
   * <perspective-viewer sort='[["x","desc"]]'></perspective-viewer>
   */


  sort(sort) {
    if (sort === null || sort === undefined || sort.length === 0) {
      if (this.hasAttribute("sort")) {
        this.removeAttribute("sort");
      }

      sort = [];
    }

    var inner = this._sort.querySelector("ul");

    this._update_column_list(sort, inner, (s, expressions) => {
      let dir = "asc";

      if (Array.isArray(s)) {
        dir = s[1];
        s = s[0];
      } // either the whole expression string or undefined


      let expression = findExpressionByAlias(s, expressions);
      return this._new_row(s, false, false, false, dir, expression);
    }, (sort, node) => {
      if (Array.isArray(sort)) {
        return node.getAttribute("name") === sort[0] && node.getAttribute("sort-order") === sort[1];
      }

      return node.getAttribute("name") === sort;
    });

    this.dispatchEvent(new Event("perspective-config-update"));

    this._debounce_update();
  }
  /**
   * The set of visible columns.
   *
   * @kind member
   * @type {Array<String>}
   * @param {Array} columns An Array of strings, the names of visible columns.
   * @fires PerspectiveViewer#perspective-config-update
   * @example <caption>via Javascript DOM</caption>
   * let elem = document.getElementById('my_viewer');
   * elem.setAttribute('columns', JSON.stringify(["x", "y'"]));
   * @example <caption>via HTML</caption>
   * <perspective-viewer columns='["x", "y"]'></perspective-viewer>
   */


  columns(show) {
    if (show === null || show === undefined || show.length === 0) {
      if (this.hasAttribute("columns")) {
        if (this._initial_col_order) {
          this.setAttribute("columns", JSON.stringify(this._initial_col_order));
        } else {
          this.removeAttribute("columns");
        }
      }

      show = (this._initial_col_order || []).slice();
    }

    this._update_column_view(show, true);

    this.dispatchEvent(new Event("perspective-config-update"));

    this._debounce_update();
  }
  /**
   * DEPRECATED: use the expressions API instead.
   *
   * @kind member
   * @type {Array<Object>}
   * @param {Array<Object>} computed-columns DEPRECATED - use the
   * "expressions" API instead.
   * @deprecated
   */


  "computed-columns"() {
    console.error("[PerspectiveViewer] the `computed-columns` attribute is deprecated - use the `expressions` attribute instead.");
  }
  /**
   * Sets this `perspective.table.view`'s `expressions` property, which will
   * output new columns from the given expressions.
   *
   * @kind member
   * @type {Array<String>}
   * @param {Array<String>} expressions An array of string expressions to
   * be calculated by Perspective.
   * @fires PerspectiveViewer#perspective-config-update
   *
   * @example <caption>via Javascript DOM</caption>
   * let elem = document.getElementById('my_viewer');
   * elem.setAttribute('expressions', JSON.stringify(['"x" + ("y" + 20)']));
   * @example <caption>via HTML</caption>
   * <perspective-viewer expressions='[\'"x" + 10\']'></perspective-viewer>
   */


  expressions(expressions) {
    const resolve = this._set_updating();

    (async () => {
      if (expressions === null || expressions === undefined || expressions.length === 0) {
        // Remove expression columns from the DOM, and reset the config
        // to exclude all expression columns.
        if (this.hasAttribute("expressions")) {
          this.removeAttribute("expressions");

          this._reset_expressions_view();

          return;
        }

        resolve();
      }

      let expression_schema = {};

      if (this.table) {
        const validation_results = await this.table.validate_expressions(expressions);
        expression_schema = validation_results.expression_schema;
        const errors = validation_results.errors;
        const validated_expressions = {};
        /**
         * Clear the expressions attribute if the validation fails at
         * any point. This validation gets triggered in two scenarios:
         *
         * 1. When a user types an expression and clicks save,
         *  where the expression has already been checked. In
         *  this case, there should be no failure of the
         *  validation as the expression has already been
         *  checked and validated.
         *
         * 2. When a user calls setAttribute() or restore()
         *  with a config that contains expressions, in which case
         *  the existing expressions are cleared already, and so
         *  there is no need to preserve the array.
         */

        let clear_expressions = false;

        for (const expression of expressions) {
          let alias = getExpressionAlias(expression); // Each expression from the editor should already have
          // an alias set. While we can auto-generate aliases, we
          // would need to setAttribute again and risk entering an
          // infinite recursion, so just let it fall into the error
          // state and clear the expressions.

          if (expression_schema[alias]) {
            validated_expressions[alias] = expression;
          } else {
            if (alias === undefined) {
              console.warn(`Failed to set "expressions" attribute: "${expression}" does not have an alias, i.e: // Expression Alias \n "x" + "y"`);
            } else {
              // alias is guaranteed to be in the errors map
              console.warn(`Error in expression "${alias}": ${errors[alias]}\nFailed to set "expressions" attribute: expression "${expression}" is invalid.`);
            }

            clear_expressions = true;
          }
        }

        if (clear_expressions) {
          // recurses one level down but will not make any calls
          // to Perspective.
          this.setAttribute("expressions", null);
        } // Need to remove old expressions from the viewer DOM and
        // config so they don't mess up state. To do this, we need
        // to get the expression columns that are currently in the DOM,
        // as this callback runs after the attribute is already set
        // with the new value.


        const active_expressions = this._get_view_active_columns().filter(x => x.classList.contains("expression")).map(x => x.getAttribute("expression"));

        const inactive_expressions = this._get_view_inactive_columns().filter(x => x.classList.contains("expression")).map(x => x.getAttribute("expression"));

        const old_expressions = active_expressions.concat(inactive_expressions);

        const to_remove = this._diff_expressions(old_expressions, expressions);

        if (to_remove.length > 0) {
          this._reset_expressions_view(to_remove);
        }

        expressions = Object.values(validated_expressions);
        this.setAttribute("expressions", JSON.stringify(expressions));
      } else {
        console.warn(`Applying unvalidated expressions: ${expressions} because the viewer does not have a Table attached!`);
      }

      this._update_expressions_view(expressions, expression_schema);

      this.dispatchEvent(new Event("perspective-config-update"));
      await this._debounce_update();
      resolve();
    })();
  }
  /* eslint-enable max-len */

  /**
   * The set of column aggregate configurations.
   *
   * @kind member
   * @type {Object}
   * @param {Object} aggregates A dictionary whose keys are column names, and
   * values are valid aggregations. The `aggregates` attribute works as an
   * override; in lieu of a key for a column supplied by the developers, a
   * default will be selected and reflected to the attribute based on the
   * column's type.  See {@link perspective/src/js/defaults.js}
   * @fires PerspectiveViewer#perspective-config-update
   * @example <caption>via Javascript DOM</caption>
   * let elem = document.getElementById('my_viewer');
   * elem.setAttribute('aggregates', JSON.stringify({x: "distinct count"}));
   * @example <caption>via HTML</caption>
   * <perspective-viewer aggregates='{"x": "distinct count"}'>
   * </perspective-viewer>
   */


  aggregates(show) {
    if (show === null || show === undefined || Object.keys(show).length === 0) {
      if (this.hasAttribute("aggregates")) {
        this.removeAttribute("aggregates");
      }

      show = {};
    }

    let lis = this._get_view_dom_columns();

    lis.map(x => {
      let agg = show[x.getAttribute("name")];

      if (agg) {
        x.setAttribute("aggregate", Array.isArray(agg) ? JSON.stringify(agg) : agg);
      }
    });
    this.dispatchEvent(new Event("perspective-config-update"));

    this._debounce_update();
  }
  /**
   * The set of column filter configurations.
   *
   * @kind member
   * @type {Array<Array>} filters An Array of filter configs. A filter
   * config is an Array of three elements: * The column name. * The filter
   * operation as a String. See
   * {@link perspective/src/js/config/constants.js} * The filter argument, as
   * a String, float or Array<String> as the filter operation demands.
   * @fires PerspectiveViewer#perspective-config-update
   * @example <caption>via Javascript DOM</caption>
   * let filters = [
   *     ["x", "<", 3],
   *     ["y", "contains", "abc"]
   * ];
   * let elem = document.getElementById('my_viewer');
   * elem.setAttribute('filters', JSON.stringify(filters));
   * @example <caption>via HTML</caption>
   * <perspective-viewer filters='[["x", "<", 3], ["y", "contains", "abc"]]'>
   * </perspective-viewer>
   */


  filters(filters) {
    if (filters === null || filters === undefined || filters.length === 0) {
      if (this.hasAttribute("filters")) {
        this.removeAttribute("filters");
      }

      filters = [];
    }

    if (!this._updating_filter) {
      var inner = this._filters.querySelector("ul");

      this._update_column_list(filters, inner, (filter, expressions) => {
        const fterms = JSON.stringify({
          operator: filter[1],
          operand: filter[2]
        });
        const name = filter[0]; // either the whole expression string or undefined

        let expression = findExpressionByAlias(name, expressions);
        return this._new_row(name, undefined, undefined, fterms, undefined, expression);
      }, (filter, node) => node.getAttribute("name") === filter[0] && node.getAttribute("filter") === JSON.stringify({
        operator: filter[1],
        operand: filter[2]
      }));
    }

    this.dispatchEvent(new Event("perspective-config-update"));

    this._debounce_update();
  }
  /**
   * Sets the currently selected plugin, via its `name` field, and removes
   * any children the previous plugin may have left behind in the light DOM.
   *
   * @type {String}
   * @fires PerspectiveViewer#perspective-config-update
   */


  set plugin(v) {
    if (v === "null" || v === null || v === undefined) {
      this.setAttribute("plugin", this._vis_selector.options[0].value);
      return;
    }

    this.innerHTML = "";
    const plugin_names = Object.keys(renderers.getInstance());

    if (this.hasAttribute("plugin")) {
      let plugin = this.getAttribute("plugin");

      if (plugin_names.indexOf(plugin) === -1) {
        const guess_plugin = plugin_names.find(x => x.indexOf(plugin) > -1);

        if (guess_plugin) {
          console.warn(`Unknown plugin "${plugin}", using "${guess_plugin}"`);
          this.setAttribute("plugin", guess_plugin);
        } else {
          console.error(`Unknown plugin "${plugin}"`);
          this.setAttribute("plugin", this._vis_selector.options[0].value);
        }
      } else {
        if (this._vis_selector.value !== plugin) {
          this._vis_selector.value = plugin;

          this._vis_selector_changed();
        }

        this._set_row_styles();

        this._set_column_defaults();

        this.dispatchEvent(new Event("perspective-config-update"));
      }
    } else {
      this.setAttribute("plugin", this._vis_selector.options[0].value);
    }
  }
  /**
   * Sets this `perspective.table.view`'s `column_pivots` property.
   *
   * @kind member
   * @type {Array<String>} Array of column names
   * @fires PerspectiveViewer#perspective-config-update
   */


  "column-pivots"(pivots) {
    if (pivots === null || pivots === undefined || pivots.length === 0) {
      if (this.hasAttribute("column-pivots")) {
        this.removeAttribute("column-pivots");
      }

      pivots = [];
    }

    const inner = this._column_pivots.querySelector("ul");

    this._update_column_list(pivots, inner, (pivot, expressions) => {
      // either the whole expression string or undefined
      let expression = findExpressionByAlias(pivot, expressions);
      return this._new_row(pivot, undefined, undefined, undefined, undefined, expression);
    });

    this.dispatchEvent(new Event("perspective-config-update"));

    this._debounce_update();
  }
  /**
   * Sets this `perspective.table.view`'s `row_pivots` property.
   *
   * @kind member
   * @type {Array<String>} Array of column names
   * @fires PerspectiveViewer#perspective-config-update
   */


  "row-pivots"(pivots) {
    if (pivots === null || pivots === undefined || pivots.length === 0) {
      if (this.hasAttribute("row-pivots")) {
        this.removeAttribute("row-pivots");
      }

      pivots = [];
    }

    const inner = this._row_pivots.querySelector("ul");

    this._update_column_list(pivots, inner, (pivot, expressions) => {
      // either the whole expression string or undefined
      let expression = findExpressionByAlias(pivot, expressions);
      return this._new_row(pivot, undefined, undefined, undefined, undefined, expression);
    });

    this.dispatchEvent(new Event("perspective-config-update"));

    this._debounce_update();
  }
  /**
   * Determines whether this viewer is editable or not (though it is
   * ultimately up to the plugin as to whether editing is implemented).
   *
   * @kind member
   * @type {Boolean} Is this viewer editable?
   * @fires PerspectiveViewer#perspective-config-update
   */


  set editable(x) {
    if (x === "null") {
      if (this.hasAttribute("editable")) {
        this.removeAttribute("editable");
      }
    } else {
      this.toggleAttribute("editable", true);
    }

    this._debounce_update({
      force_update: true
    });

    this.dispatchEvent(new Event("perspective-config-update"));
  }
  /**
   * Determines the render throttling behavior. Can be an integer, for
   * millisecond window to throttle render event; or, if `undefined`,
   * will try to determine the optimal throttle time from this component's
   * render framerate.
   *
   * @kind member
   * @type {Number|String} The throttle rate - milliseconds (integer), or the
   * enum "adaptive" for a dynamic throttle based on render time.
   * @example
   * <!-- Only draws at most 1 frame/sec. -->
   * <perspective-viewer throttle="1000"></perspective-viewer>
   */


  set throttle(x) {
    if (x === "null") {
      if (this.hasAttribute("throttle")) {
        this.removeAttribute("throttle");
      }
    } // Returns the throttle time, but also perform validaiton - we only want
    // the latter here.


    this._calculate_throttle_timeout();
  }
  /*
   * Determines whether row selections is enabled on this viewer (though it is
   * ultimately up to the plugin as to whether selectable is implemented).
   *
   * @kind member
   * @type {Boolean} Is this viewer editable?
   * @fires PerspectiveViewer#perspective-config-update
   */


  set selectable(x) {
    if (x === "null") {
      if (this.hasAttribute("selectable")) {
        this.removeAttribute("selectable");
      }
    } else {
      this.toggleAttribute("selectable", true);
    }

    this._debounce_update({
      force_update: true
    });

    this.dispatchEvent(new Event("perspective-config-update"));
  }
  /**
   * This element's `perspective.table` instance.
   *
   * @readonly
   */


  get table() {
    return this._table;
  }
  /**
   * This element's `perspective.table.view` instance. The instance itself
   * will change after every `PerspectiveViewer#perspective-config-update`
   * event.
   *
   * @readonly
   */


  get view() {
    return this._view;
  }
  /**
   * Load data. If `load` or `update` have already been called on this
   * element, its internal `perspective.table` will also be deleted.
   *
   * @async
   * @param {any} data The data to load, as a `perspective.Table` or
   * `Promise<perspective.Table>`.
   * @returns {Promise<void>} A promise which resolves once the data is loaded
   * and a `perspective.view` has been created.
   * @fires module:perspective_viewer~PerspectiveViewer#perspective-click
   * PerspectiveViewer#perspective-view-update
   * ]);
   * @example <caption>Load perspective.table</caption>
   * const my_viewer = document.getElementById('#my_viewer');
   * const tbl = await perspective.table("x,y\n1,a\n2,b");
   * my_viewer.load(tbl);
   * @example <caption>Load Promise<perspective.table></caption>
   * const my_viewer = document.getElementById('#my_viewer');
   * const tbl = async () => perspective.table("x,y\n1,a\n2,b");
   * my_viewer.load(tbl);
   */


  async load(data) {
    let table;

    const resolve = this._set_updating();

    if (data instanceof Promise) {
      this._vieux.load(data);

      table = await data;
    } else {
      if (data.type === "table") {
        this._vieux.load(Promise.resolve(data));

        table = data;
      } else {
        resolve();
        throw new Error(`Unrecognized input type ${typeof data}.  Please use a \`perspective.Table()\``);
      }
    }

    if (this.isConnected) {
      await this._load_table(table, resolve);
    } else {
      this._table = table;
      this._table_resolve = resolve;
    }
  }
  /**
   * Determine whether to reflow the viewer and redraw.
   *
   */


  async notifyResize(immediate) {
    const resized = await this._check_responsive_layout();

    if (!resized && !document.hidden && this.offsetParent) {
      await this._plugin.resize.call(this, immediate);
    }
  }
  /**
   * Duplicate an existing `<perspective-element>`, including data and view
   * settings.  The underlying `perspective.table` will be shared between both
   * elements
   *
   * @param {any} widget A `<perspective-viewer>` instance to clone.
   */


  clone(widget) {
    const resolve = this._set_updating();

    this._load_table(widget.table, resolve);

    this.restore(widget.save());
  }
  /**
   * Deletes this element and clears it's internal state (but not its
   * user state).  This (or the underlying `perspective.view`'s equivalent
   * method) must be called in order for its memory to be reclaimed, as well
   * as the reciprocal method on the `perspective.table` which this viewer is
   * bound to.
   *
   * @returns {Promise<Boolean>} Whether or not this call resulted in the
   * underlying `perspective.table` actually being deleted.
   */


  delete() {
    let x = this._clear_state();

    if (this._plugin.delete) {
      this._plugin.delete.call(this);
    }

    window.removeEventListener("resize", this._resize_handler);
    return x;
  }
  /**
   * Restyles the elements and to pick up any style changes
   */


  restyleElement() {
    this._restyle_plugin();
  }
  /**
   * Serialize this element's attribute/interaction state.
   *
   * @returns {object} a serialized element.
   */


  save() {
    let obj = {};
    const cols = new Set(PERSISTENT_ATTRIBUTES);

    for (let key = 0; key < this.attributes.length; key++) {
      let attr = this.attributes[key];

      if (cols.has(attr.name)) {
        if (attr.value === "") {
          obj[attr.name] = true;
        } else if (attr.name !== "plugin" && attr.value !== undefined && attr.value !== null) {
          obj[attr.name] = JSON.parse(attr.value);
        } else {
          obj[attr.name] = attr.value;
        }

        cols.delete(attr.name);
      }
    }

    for (const col of cols) {
      obj[col] = null;
    }

    if (this._plugin.save) {
      obj.plugin_config = this._plugin.save.call(this);
    }

    return obj;
  }
  /**
   * Restore this element to a state as generated by a reciprocal call to
   * `save` or `serialize`.
   *
   * @param {Object|String} config returned by `save` or `serialize`.
   * @returns {Promise<void>} A promise which resolves when the changes have
   * been applied.
   */


  async restore(config) {
    if (typeof config === "string") {
      config = JSON.parse(config);
    }

    for (const key of PERSISTENT_ATTRIBUTES) {
      if (config.hasOwnProperty(key)) {
        let val = config[key];

        if (val === true) {
          this.toggleAttribute(key, true);
        } else if (val !== undefined && val !== null && val !== false) {
          if (typeof val !== "string") {
            val = JSON.stringify(val);
          }

          this.setAttribute(key, val);
        } else {
          this.removeAttribute(key);
        }
      }
    }

    if (this._plugin.restore && config.plugin_config) {
      this._plugin.restore.call(this, config.plugin_config);
    }

    await this._debounce_update();
  }
  /**
   * Flush any pending attribute modifications to this element.
   *
   * @returns {Promise<void>} A promise which resolves when the current
   * attribute state has been applied.
   */


  async flush() {
    await Promise.all([this._updating_promise || Promise.resolve(), this.notifyResize.flush(this)]);
  }
  /**
   * Reset's this element's view state and attributes to default.  Does not
   * delete this element's `perspective.table` or otherwise modify the data
   * state.
   */


  reset() {
    var _this$_plugin$restore;

    this.removeAttribute("row-pivots");
    this.removeAttribute("column-pivots");
    this.removeAttribute("filters");
    this.removeAttribute("sort");
    this.removeAttribute("expressions");

    if (this._initial_col_order) {
      this.setAttribute("columns", JSON.stringify(this._initial_col_order));
    } else {
      this.removeAttribute("columns");
    }

    this.setAttribute("plugin", Object.keys(renderers.getInstance())[0]);
    (_this$_plugin$restore = this._plugin.restore) === null || _this$_plugin$restore === void 0 ? void 0 : _this$_plugin$restore.call(this, {});
    this.dispatchEvent(new Event("perspective-config-update"));
  }
  /**
   * Download this element's data as a CSV file.
   *
   * @param {Boolean} [flat=false] Whether to use the element's current view
   * config, or to use a default "flat" view.
   * @memberof PerspectiveViewer
   */


  async download(flat = false) {
    const {
      download_flat,
      download
    } = await wasm;

    if (flat) {
      await download_flat(this._table);
    } else {
      await download(this._view);
    }
  }
  /**
   * Copies this element's view data (as a CSV) to the clipboard.  This method
   * must be called from an event handler, subject to the browser's
   * restrictions on clipboard access.  See
   * {@link https://www.w3.org/TR/clipboard-apis/#allow-read-clipboard}.
   */


  async copy(flat = false) {
    const {
      copy_flat,
      copy
    } = await wasm;

    if (flat) {
      await copy_flat(this._table);
    } else {
      await copy(this._view);
    }
  }
  /**
   * Opens/closes the element's config menu.
   *
   * @async
   */


  async toggleConfig(force) {
    await this._vieux.toggle_config(force);
  }
  /**
   * Returns a promise that resolves to the element's edit port ID, used
   * internally when edits are made using DataGrid.
   *
   * @async
   */


  async getEditPort() {
    return this._edit_port_lock;
  }

}, (_applyDecoratedDescriptor(_class2.prototype, "sort", [array_attribute], Object.getOwnPropertyDescriptor(_class2.prototype, "sort"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "columns", [array_attribute], Object.getOwnPropertyDescriptor(_class2.prototype, "columns"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "computed-columns", [array_attribute], Object.getOwnPropertyDescriptor(_class2.prototype, "computed-columns"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "expressions", [array_attribute], Object.getOwnPropertyDescriptor(_class2.prototype, "expressions"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "aggregates", [json_attribute], Object.getOwnPropertyDescriptor(_class2.prototype, "aggregates"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "filters", [array_attribute], Object.getOwnPropertyDescriptor(_class2.prototype, "filters"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "column-pivots", [array_attribute], Object.getOwnPropertyDescriptor(_class2.prototype, "column-pivots"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "row-pivots", [array_attribute], Object.getOwnPropertyDescriptor(_class2.prototype, "row-pivots"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "notifyResize", [throttlePromise], Object.getOwnPropertyDescriptor(_class2.prototype, "notifyResize"), _class2.prototype)), _class2)) || _class$2);
/**
 * `perspective-click` is fired whenever underlying `view`'s grid or chart are
 * clicked providing a detail that includes a `config`, `column_names` and
 * `row`.
 *
 * @event module:perspective_viewer~PerspectiveViewer#perspective-click
 * @type {object}
 * @property {Array} column_names - Includes a list of column names.
 * @property {object} config - Contains a property `filters` that can be applied
 * to a `<perspective-viewer>` through the use of `restore()` updating it to
 * show the filtered subset of data..
 * @property {Array} row - Includes the data row.
 */

/**
 * `perspective-config-update` is fired whenever an configuration attribute has
 * been modified, by the user or otherwise.
 *
 * @event module:perspective_viewer~PerspectiveViewer#perspective-config-update
 * @type {String}
 */

/**
 * `perspective-view-update` is fired whenever underlying `view`'s data has
 * updated, including every invocation of `load` and `update`.
 *
 * @event module:perspective_viewer~PerspectiveViewer#perspective-view-update
 * @type {String}
 */
//# sourceMappingURL=viewer.js.map
