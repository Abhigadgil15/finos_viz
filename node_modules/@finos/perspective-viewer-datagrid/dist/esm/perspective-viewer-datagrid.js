import 'core-js/modules/web.dom-collections.iterator.js';
import { registerPlugin } from '@finos/perspective-viewer/src/js/utils.js';
import 'regular-table';
import { get_type_config } from '@finos/perspective/dist/esm/config/index.js';
import chroma from 'chroma-js';
import 'core-js/modules/es.array.reduce.js';
import 'core-js/modules/es.string.replace.js';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

const PLUGIN_SYMBOL = Symbol("Plugin Symbol");
let MENU = undefined;
function activate_plugin_menu(regularTable, target, column_max) {
  MENU = MENU || document.createElement("perspective-column-style");
  const target_meta = regularTable.getMeta(target);
  const column_name = target_meta.column_header[target_meta.column_header.length - 1];
  const column_type = this._schema[column_name];
  const default_config = {
    gradient: column_max,
    pos_color: this._pos_color[0],
    neg_color: this._neg_color[0]
  };

  if (column_type === "float") {
    default_config.fixed = 2;
  } else if (column_type === "integer") {
    default_config.fixed = 0;
  } else {
    this._open_column_styles_menu.pop();

    regularTable.draw();
    return;
  }

  const scroll_handler = () => MENU.blur();

  const update_handler = event => {
    const config = event.detail;

    if (config.pos_color) {
      config.pos_color = [config.pos_color, ...chroma(config.pos_color).rgb()];
      config.neg_color = [config.neg_color, ...chroma(config.neg_color).rgb()];
    }

    regularTable[PLUGIN_SYMBOL] = regularTable[PLUGIN_SYMBOL] || {};
    regularTable[PLUGIN_SYMBOL][column_name] = config;
    regularTable.draw({
      preserve_width: true
    });
    regularTable.parentElement.dispatchEvent(new Event("perspective-config-update"));
  };

  const blur_handler = async () => {
    regularTable.removeEventListener("regular-table-scroll", scroll_handler);
    MENU.removeEventListener("perspective-column-style-change", update_handler);
    MENU.removeEventListener("blur", blur_handler);

    this._open_column_styles_menu.pop();

    await regularTable.draw();
    regularTable.parentElement.dispatchEvent(new Event("perspective-config-update"));
  };

  MENU.addEventListener("perspective-column-style-change", update_handler);
  MENU.addEventListener("blur", blur_handler);
  regularTable.addEventListener("regular-table-scroll", scroll_handler); // Get the current column style config

  const pset = regularTable[PLUGIN_SYMBOL] || {};
  const config = Object.assign({}, pset[column_name] = pset[column_name] || {});

  if (config.pos_color) {
    config.pos_color = config.pos_color[0];
    config.neg_color = config.neg_color[0];
  } // open the menu


  MENU.open(target, config, default_config);
}

// the color of a heatmap cell over the background.

function rgbaToRgb([r, g, b, a], source = [255, 255, 255]) {
  function f(i, c) {
    return ((1 - a) * (source[i] / 255) + a * (c / 255)) * 255;
  }

  return [f(0, r), f(1, g), f(2, b)];
} // Chroma does this but why bother?

function infer_foreground_from_background([r, g, b]) {
  // TODO Implement dark/light themes.
  return Math.sqrt(r * r * 0.299 + g * g * 0.587 + b * b * 0.114) > 130 ? "#161616" : "#ffffff";
}

function styleListener(regularTable) {
  const header_depth = regularTable._view_cache.config.row_pivots.length - 1;
  let group_headers = Array.from(regularTable.children[0].children[0].children);
  let [col_headers] = group_headers.splice(group_headers.length - 1, 1);
  const plugins = regularTable[PLUGIN_SYMBOL] || {};

  for (const td of col_headers === null || col_headers === void 0 ? void 0 : col_headers.children) {
    var _metadata$column_head, _metadata$column_head2;

    const metadata = regularTable.getMeta(td);
    const column_name = (_metadata$column_head = metadata.column_header) === null || _metadata$column_head === void 0 ? void 0 : _metadata$column_head[((_metadata$column_head2 = metadata.column_header) === null || _metadata$column_head2 === void 0 ? void 0 : _metadata$column_head2.length) - 1];

    const sort = this._config.sort.find(x => x[0] === column_name);

    let needs_border = metadata.row_header_x === header_depth;
    const is_corner = typeof metadata.x === "undefined";
    needs_border = needs_border || (metadata.x + 1) % this._config.columns.length === 0;
    td.classList.toggle("psp-header-border", needs_border);
    td.classList.toggle("psp-header-group", false);
    td.classList.toggle("psp-header-leaf", true);
    td.classList.toggle("psp-is-top", false);
    td.classList.toggle("psp-header-corner", is_corner);
    td.classList.toggle("psp-header-sort-asc", !!sort && sort[1] === "asc");
    td.classList.toggle("psp-header-sort-desc", !!sort && sort[1] === "desc");
    td.classList.toggle("psp-header-sort-col-asc", !!sort && sort[1] === "col asc");
    td.classList.toggle("psp-header-sort-col-desc", !!sort && sort[1] === "col desc");
    let type = get_psp_type.call(this, metadata);
    const is_numeric = type === "integer" || type === "float";
    const float_val = is_numeric && metadata.user;
    td.classList.toggle("psp-align-right", is_numeric);
    td.classList.toggle("psp-align-left", !is_numeric);
    td.classList.toggle("psp-positive", float_val > 0);
    td.classList.toggle("psp-negative", float_val < 0);
    td.classList.toggle("psp-menu-open", this._open_column_styles_menu[0] === metadata._virtual_x);
    td.classList.toggle("psp-menu-enabled", is_numeric && !is_corner); // Color plugin
    // const plugin = plugins[column_name];
    // if (plugin?.pos_color !== undefined) {
    //     const [, r, g, b] = plugin.pos_color;
    //     const foreground = infer_foreground_from_background([r, g, b]);
    //     td.style.backgroundColor = plugin.pos_color[0];
    //     td.style.color = foreground;
    // } else {
    //     td.style.backgroundColor = "";
    //     td.style.color = "";
    // }
  }

  const m = [];
  let marked = new Set();
  const table = regularTable.children[0];

  for (let y = 0; y < group_headers.length; y++) {
    let row = table.rows[y];
    const tops = new Set();

    for (let x = 0; x < row.cells.length; x++) {
      const td = row.cells[x];
      td.style.backgroundColor = "";
      const metadata = regularTable.getMeta(td);
      let needs_border = metadata.row_header_x === header_depth || metadata.x >= 0;
      td.classList.toggle("psp-align-right", false);
      td.classList.toggle("psp-align-left", false);
      td.classList.toggle("psp-header-group", true);
      td.classList.toggle("psp-header-leaf", false);
      td.classList.toggle("psp-header-border", needs_border);
      td.classList.toggle("psp-header-group-corner", typeof metadata.x === "undefined");
      let cell = row.cells[x],
          xx = x,
          tx,
          ty;

      for (; m[y] && m[y][xx]; ++xx);

      tops.add(xx);

      for (tx = xx; tx < xx + cell.colSpan; ++tx) {
        for (ty = y; ty < y + cell.rowSpan; ++ty) {
          if (!m[ty]) m[ty] = [];
          m[ty][tx] = true;
        }
      }

      cell.classList.toggle("psp-is-top", y === 0 || !marked.has(tx));
    }

    marked = tops;
  } // this._cached_range = this._cached_range || {};


  for (const tr of regularTable.children[0].children[1].children) {
    for (const td of tr.children) {
      var _metadata$column_head3, _metadata$column_head4;

      const metadata = regularTable.getMeta(td);
      const column_name = (_metadata$column_head3 = metadata.column_header) === null || _metadata$column_head3 === void 0 ? void 0 : _metadata$column_head3[((_metadata$column_head4 = metadata.column_header) === null || _metadata$column_head4 === void 0 ? void 0 : _metadata$column_head4.length) - 1];
      const plugin = plugins[column_name];
      let type = get_psp_type.call(this, metadata);
      const is_numeric = type === "integer" || type === "float";

      if (is_numeric) {
        const is_positive = metadata.user > 0;
        const is_negative = metadata.user < 0;

        const [hex, r, g, b] = (() => {
          if ((plugin === null || plugin === void 0 ? void 0 : plugin.pos_color) !== undefined) {
            return is_positive ? plugin.pos_color : is_negative ? plugin.neg_color : ["", 0, 0, 0];
          } else {
            return is_positive ? this._pos_color : is_negative ? this._neg_color : ["", 0, 0, 0];
          }
        })();

        if ((plugin === null || plugin === void 0 ? void 0 : plugin.color_mode) === "background") {
          const source = this._plugin_background;
          const foreground = infer_foreground_from_background(rgbaToRgb([r, g, b, 1], source));
          td.style.color = foreground;
          td.style.backgroundColor = hex;
        } else if ((plugin === null || plugin === void 0 ? void 0 : plugin.color_mode) === "gradient") {
          const a = Math.max(0, Math.min(1, Math.abs(metadata.user / plugin.gradient)));
          const source = this._plugin_background;
          const foreground = infer_foreground_from_background(rgbaToRgb([r, g, b, a], source));
          td.style.color = foreground;
          td.style.backgroundColor = `rgba(${r},${g},${b},${a})`;
        } else if ((plugin === null || plugin === void 0 ? void 0 : plugin.color_mode) === "foreground") {
          td.style.backgroundColor = "";
          td.style.color = hex;
        } else {
          td.style.backgroundColor = "";
          td.style.color = "";
        }
      } else {
        td.style.backgroundColor = "";
        td.style.color = "";
      }

      const is_th = td.tagName === "TH";

      if (is_th) {
        const is_not_empty = !!metadata.value && metadata.value.toString().trim().length > 0;
        const is_leaf = metadata.row_header_x >= this._config.row_pivots.length;
        const next = regularTable.getMeta({
          dx: 0,
          dy: metadata.y - metadata.y0 + 1
        });
        const is_collapse = next && next.row_header && typeof next.row_header[metadata.row_header_x + 1] !== "undefined";
        td.classList.toggle("psp-tree-label", is_not_empty && !is_leaf);
        td.classList.toggle("psp-tree-label-expand", is_not_empty && !is_leaf && !is_collapse);
        td.classList.toggle("psp-tree-label-collapse", is_not_empty && !is_leaf && is_collapse);
        td.classList.toggle("psp-tree-leaf", is_not_empty && is_leaf);
      }

      const float_val = is_numeric && metadata.user;
      td.classList.toggle("psp-align-right", !is_th && is_numeric);
      td.classList.toggle("psp-align-left", is_th || !is_numeric);
      td.classList.toggle("psp-positive", float_val > 0);
      td.classList.toggle("psp-negative", float_val < 0);
    }
  }
}

function get_psp_type(metadata) {
  if (metadata.x >= 0) {
    const column_path = this._column_paths[metadata.x];
    const column_path_parts = column_path.split("|");
    return this._schema[column_path_parts[column_path_parts.length - 1]];
  } else {
    const column_path = this._config.row_pivots[metadata.row_header_x - 1];
    return this._table_schema[column_path];
  }
}

async function sortHandler(regularTable, event, target) {
  const meta = regularTable.getMeta(target);
  const column_name = meta.column_header[meta.column_header.length - 1];
  const sort_method = event.shiftKey ? append_sort : override_sort;
  const sort = sort_method.call(this, column_name);
  regularTable.dispatchEvent(new CustomEvent("regular-table-psp-sort", {
    detail: {
      sort
    }
  }));
}

function append_sort(column_name) {
  const sort = [];
  let found = false;

  for (const sort_term of this._config.sort) {
    const [_column_name, _sort_dir] = sort_term;

    if (_column_name === column_name) {
      found = true;
      const term = create_sort.call(this, column_name, _sort_dir);

      if (term) {
        sort.push(term);
      }
    } else {
      sort.push(sort_term);
    }
  }

  if (!found) {
    sort.push([column_name, "desc"]);
  }

  return sort;
}

function override_sort(column_name) {
  for (const [_column_name, _sort_dir] of this._config.sort) {
    if (_column_name === column_name) {
      const sort = create_sort.call(this, column_name, _sort_dir);
      return sort ? [sort] : [];
    }
  }

  return [[column_name, "desc"]];
}

function create_sort(column_name, sort_dir) {
  const is_col_sortable = this._config.column_pivots.length > 0;
  const order = is_col_sortable ? ROW_COL_SORT_ORDER : ROW_SORT_ORDER;
  const inc_sort_dir = sort_dir ? order[sort_dir] : "desc";

  if (inc_sort_dir) {
    return [column_name, inc_sort_dir];
  }
}

const ROW_SORT_ORDER = {
  desc: "asc",
  asc: undefined
};
const ROW_COL_SORT_ORDER = {
  desc: "asc",
  asc: "col desc",
  "col desc": "col asc",
  "col asc": undefined
};

async function expandCollapseHandler(regularTable, event) {
  const meta = regularTable.getMeta(event.target);
  const is_collapse = event.target.classList.contains("psp-tree-label-collapse");

  if (event.shiftKey && is_collapse) {
    this._view.set_depth(meta.row_header.filter(x => x !== undefined).length - 2);
  } else if (event.shiftKey) {
    this._view.set_depth(meta.row_header.filter(x => x !== undefined).length - 1);
  } else if (is_collapse) {
    this._view.collapse(meta.y);
  } else {
    this._view.expand(meta.y);
  }

  this._num_rows = await this._view.num_rows();
  this._num_columns = await this._view.num_columns();
  regularTable.draw();
}

async function mousedownListener(regularTable, event) {
  if (event.which !== 1) {
    return;
  }

  let target = event.target;

  while (target.tagName !== "TD" && target.tagName !== "TH") {
    target = target.parentElement;

    if (!regularTable.contains(target)) {
      return;
    }
  }

  if (target.classList.contains("psp-tree-label") && event.offsetX < 26) {
    expandCollapseHandler.call(this, regularTable, event);
    event.stopImmediatePropagation();
    return;
  }

  const rect = target.getBoundingClientRect();

  if (target.classList.contains("psp-menu-enabled") && event.clientY - rect.top > 16) {
    var _meta$column_header, _meta$column_header2;

    const meta = regularTable.getMeta(target);
    const column_name = (_meta$column_header = meta.column_header) === null || _meta$column_header === void 0 ? void 0 : _meta$column_header[((_meta$column_header2 = meta.column_header) === null || _meta$column_header2 === void 0 ? void 0 : _meta$column_header2.length) - 1];
    const [, max] = await this._view.get_min_max(column_name);

    this._open_column_styles_menu.unshift(meta._virtual_x);

    regularTable.draw();
    activate_plugin_menu.call(this, regularTable, target, max);
    event.preventDefault();
    event.stopImmediatePropagation();
  } else if (target.classList.contains("psp-header-leaf") && !target.classList.contains("psp-header-corner")) {
    sortHandler.call(this, regularTable, event, target);
    event.stopImmediatePropagation();
  }
}

function clickListener(regularTable, event) {
  if (event.which !== 1) {
    return;
  }

  let target = event.target;

  while (target.tagName !== "TD" && target.tagName !== "TH") {
    target = target.parentElement;

    if (!regularTable.contains(target)) {
      return;
    }
  }

  if (target.classList.contains("psp-tree-label") && event.offsetX < 26) {
    event.stopImmediatePropagation();
  } else if (target.classList.contains("psp-header-leaf") && !target.classList.contains("psp-header-corner")) {
    event.stopImmediatePropagation();
  }
}

const FORMATTERS = {};
const FORMATTER_CONS = {
  datetime: Intl.DateTimeFormat,
  date: Intl.DateTimeFormat,
  integer: Intl.NumberFormat,
  float: Intl.NumberFormat
};
const formatters = FORMATTERS;

function _format(parts, val, plugins = {}, use_table_schema = false) {
  if (val === null) {
    return "-";
  }

  const title = parts[parts.length - 1];
  const plugin = plugins[title];
  const type = use_table_schema && this._table_schema[title] || this._schema[title] || "string";
  const is_numeric = type === "integer" || type === "float";
  const is_plugin_override = is_numeric && plugin && plugin.fixed !== undefined;
  let formatter_key = is_plugin_override ? `${type}${plugin.fixed}` : type;

  if (FORMATTERS[formatter_key] === undefined) {
    const type_config = get_type_config(type);

    if (is_plugin_override) {
      const opts = {
        minimumFractionDigits: plugin.fixed,
        maximumFractionDigits: plugin.fixed
      };
      FORMATTERS[formatter_key] = new FORMATTER_CONS[type]("en-us", opts);
    } else if (FORMATTER_CONS[type] && type_config.format) {
      FORMATTERS[formatter_key] = new FORMATTER_CONS[type]("en-us", type_config.format);
    } else {
      FORMATTERS[formatter_key] = false;
    }
  }

  return FORMATTERS[formatter_key] ? FORMATTERS[formatter_key].format(val) : val;
}

function* _tree_header(paths = [], row_headers, regularTable) {
  const plugins = regularTable[PLUGIN_SYMBOL];

  for (let path of paths) {
    path = ["TOTAL", ...path];
    const last = path[path.length - 1];
    path = path.slice(0, path.length - 1).fill("");

    const formatted = _format.call(this, [row_headers[path.length - 1]], last, plugins, true);

    path = path.concat({
      toString: () => formatted
    });
    path.length = row_headers.length + 1;
    yield path;
  }
}

async function dataListener(regularTable, x0, y0, x1, y1) {
  let columns = {};

  if (x1 - x0 > 0 && y1 - y0 > 0) {
    columns = await this._view.to_columns({
      start_row: y0,
      start_col: x0,
      end_row: y1,
      end_col: x1,
      id: true
    });
    this._ids = columns.__ID__;
  }

  const data = [],
        metadata = [];
  const column_headers = [];

  for (const path of this._column_paths.slice(x0, x1)) {
    const path_parts = path.split("|");
    const column = columns[path] || new Array(y1 - y0).fill(null);
    data.push(column.map(x => _format.call(this, path_parts, x, regularTable[PLUGIN_SYMBOL])));
    metadata.push(column);
    column_headers.push(path_parts);
  }

  return {
    num_rows: this._num_rows,
    num_columns: this._column_paths.length,
    row_headers: Array.from(_tree_header.call(this, columns.__ROW_PATH__, this._config.row_pivots, regularTable)),
    column_headers,
    data,
    metadata
  };
}

function get_rule(regular, tag, def) {
  let color = window.getComputedStyle(regular).getPropertyValue(tag).trim();

  if (color.length > 0) {
    return color;
  } else {
    return def;
  }
}

async function createModel(regular, table, view, extend = {}) {
  const config = await view.get_config(); // Extract the entire expression string as typed by the user, so we can
  // feed it into `validate_expressions` and get back the data types for
  // each column without it being affected by a pivot.

  const expressions = config.expressions.map(expr => expr[1]);
  const [table_schema, validated_expressions, num_rows, schema, expression_schema, column_paths] = await Promise.all([table.schema(), table.validate_expressions(expressions), view.num_rows(), view.schema(), view.expression_schema(), view.column_paths()]);

  const _plugin_background = chroma(get_rule(regular, "--plugin--background", "#FFFFFF")).rgb();

  let _pos_color = get_rule(regular, "--rt-pos-cell--color", "#0000ff");

  _pos_color = [_pos_color, ...chroma(_pos_color).rgb()];

  let _neg_color = get_rule(regular, "--rt-neg-cell--color", "#ff0000");

  _neg_color = [_neg_color, ...chroma(_neg_color).rgb()];
  const model = Object.assign(extend, {
    _view: view,
    _table: table,
    _table_schema: { ...table_schema,
      ...validated_expressions.expression_schema
    },
    _config: config,
    _num_rows: num_rows,
    _schema: { ...schema,
      ...expression_schema
    },
    _ids: [],
    _open_column_styles_menu: [],
    _plugin_background,
    _pos_color,
    _neg_color,
    _column_paths: column_paths.filter(path => {
      return path !== "__ROW_PATH__" && path !== "__ID__";
    })
  });
  regular.setDataListener(dataListener.bind(model, regular));
  return model;
}
async function configureRegularTable(regular, model) {
  regular.addStyleListener(styleListener.bind(model, regular));
  regular.addEventListener("mousedown", mousedownListener.bind(model, regular));
  regular.addEventListener("click", clickListener.bind(model, regular));
  await regular.draw();
}

var css_248z = "regular-table{padding-top:12px;padding-left:12px;padding-bottom:0;padding-right:0;scrollbar-color:transparent transparent;scrollbar-width:thin;outline:none}regular-table:hover{scrollbar-color:rgba(0,0,0,0.3) transparent}regular-table{font-family:\"Open Sans\"}regular-table div[tabindex]{outline:none}regular-table > div{position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden}regular-table th{text-align:center}regular-table thead tr:not(:last-child) th{overflow:hidden;max-width:0px}regular-table thead tr:last-child .rt-float,\nregular-table tbody .rt-float{text-align:right}regular-table thead .rt-integer,\nregular-table tbody .rt-integer{text-align:right}regular-table tbody th{text-align:left}regular-table span.rt-tree-container{display:flex;align-items:center;height:100%}regular-table thead .rt-string,\nregular-table tbody .rt-string,\nregular-table thead .rt-date,\nregular-table tbody .rt-date,\nregular-table thead .rt-datetime,\nregular-table tbody .rt-datetime{text-align:left}regular-table thead tr:last-child th{border-bottom:1px solid #ddd}regular-table th{position:relative}regular-table tr th span.rt-tree-group{margin-left:5px;margin-right:15px;border-left:1px solid #eee;height:100%}regular-table td,\nregular-table th{white-space:nowrap;font-size:12px;padding-right:5px;padding-left:5px;padding-top:0px;padding-bottom:0px;height:19px}regular-table tr:hover td{background:#eee;opacity:1}regular-table tr:hover{color:#333}regular-table table *{box-sizing:border-box}regular-table table{position:absolute;overflow:hidden;color:#666;outline:none}regular-table span.rt-row-header-icon{color:#AAA;padding-right:4px;font-family:\"Material Icons\"}regular-table span.rt-column-header-icon{font-size:10px;padding-left:3px;display:inline-block;width:10px;font-family:\"Material Icons\"}regular-table span.rt-row-header-icon:hover{color:#1a7da1;text-shadow:0px 0px 3px #1a7da1}regular-table .rt-selected td{background-color:#eee}regular-table .rt-cell-clip{overflow:hidden;text-overflow:ellipsis}regular-table td span.rt-group-name,\nregular-table th span.rt-group-name{margin-right:-5px;padding-right:5px;padding-left:8px;flex:1;height:100%}regular-table th span.rt-group-name{text-align:left}regular-table td th span.rt-group-leaf,\nregular-table th span.rt-group-leaf{margin-left:16px;height:100%}regular-table .rt-column-resize{height:100%;width:10px;position:absolute;top:0;right:0;cursor:col-resize}regular-table::-webkit-scrollbar,\nregular-table::-webkit-scrollbar-corner{background-color:transparent;height:12px;width:12px}regular-table::-webkit-scrollbar-thumb{background-clip:content-box;background-color:rgba(0,0,0,0);border-radius:5px}regular-table::-webkit-scrollbar-thumb:horizontal{border-bottom:2px solid transparent;border-top:2px solid transparent}regular-table::-webkit-scrollbar-thumb:vertical{border-left:2px solid transparent;border-right:2px solid transparent}regular-table:hover::-webkit-scrollbar-thumb{background-color:rgba(0,0,0,0.15)}regular-table::-webkit-scrollbar-thumb:hover{background-color:rgba(0,0,0,0.3)}.psp-header-border:not(.psp-is-top):not(.psp-header-leaf){box-shadow:1px 0px var(--pv-divider--color,#EAEDEF)}.psp-header-group{box-shadow:0px 10px 0 -9px var(--pv-divider--color,#EAEDEF)}.psp-is-top{box-shadow:5px 4px 0px -4px var(--pv-divider--color,#EAEDEF)}.psp-is-top.psp-header-group:not(.psp-header-group-corner){box-shadow:5px 4px 0px -4px var(--pv-divider--color,#EAEDEF),0px 10px 0 -9px var(--pv-divider--color,#EAEDEF)}.psp-header-border.psp-header-group:not(.psp-is-top):not(.psp-header-group-corner){box-shadow:1px 0px var(--pv-divider--color,#EAEDEF),0px 10px 0 -9px var(--pv-divider--color,#EAEDEF)}.psp-header-leaf.psp-header-border{box-shadow:5px -4px 0px -4px var(--pv-divider--color,#EAEDEF)}tr:only-child th{box-shadow:none!important}regular-table tbody tr:hover th.psp-tree-leaf:not(.psp-row-selected):not(.psp-row-subselected),\nregular-table tbody tr:hover th.psp-tree-label:not(.psp-row-selected):not(.psp-row-subselected),\nregular-table tbody tr:hover td:not(.psp-row-selected):not(.psp-row-subselected){border-color:var(--rt-hover--border-color,#C5C9D0)!important;background-color:transparent;box-shadow:0px -2px 0px rgba(0,0,0,0.05),0px -4px 0px rgba(0,0,0,0.01),0px 1px 0px var(--rt-hover--border-color,#C5C9D0),0px 3px 0px rgba(0,0,0,0.05),0px 5px 0px rgba(0,0,0,0.01)}regular-table tbody tr:hover + tr th.psp-tree-leaf:not(.psp-row-selected):not(.psp-row-subselected),\nregular-table tbody tr:hover + tr th.psp-tree-label:not(.psp-row-selected):not(.psp-row-subselected),\nregular-table tbody tr:hover + tr td:not(.psp-row-selected):not(.psp-row-subselected){border-top-color:transparent}regular-table tbody tr th:first-child:not(:empty),\nregular-table tbody tr th:first-child:empty + th:not(:empty),\nregular-table tbody tr th:first-child:empty ~ th:empty + th:not(:empty),\nregular-table tbody tr td:first-child{border-left-width:1px;border-left-color:transparent}regular-table tbody tr th:last-child,\nregular-table tbody tr td:last-child{border-right-width:1px;border-right-color:transparent}regular-table tbody tr:hover{color:#161616}regular-table tbody tr:hover th:first-child:not(:empty),\nregular-table tbody tr:hover th:first-child:empty + th:not(:empty),\nregular-table tbody tr:hover th:first-child:empty ~ th:empty + th:not(:empty),\nregular-table tbody tr:hover td:first-child{border-left-color:var(--rt-hover--border-color,#C5C9D0)!important}regular-table tbody tr:hover th:last-child,\nregular-table tbody tr:hover td:last-child{border-right-color:var(--rt-hover--border-color,#C5C9D0)!important}perspective-viewer[settings] regular-table .psp-header-leaf{height:36px;vertical-align:top;padding-top:2px}perspective-viewer[settings] regular-table .psp-header-leaf:not(.psp-header-corner):before{font-family:\"Material Icons\";content:\"menu\";position:absolute;width:calc(100% - 8px);left:5px;bottom:0px;color:var(--inactive--color,#B4B7BE)}perspective-viewer[settings] regular-table .psp-header-leaf.psp-menu-enabled:not(.psp-header-corner):before{color:inherit;cursor:pointer}perspective-viewer[settings] regular-table .psp-header-leaf.psp-menu-open:not(.psp-header-corner){pointer-events:none}perspective-viewer[settings] regular-table .psp-header-leaf.psp-menu-open:not(.psp-header-corner):before{content:\"expand_less\"}perspective-viewer[settings] regular-table .psp-header-leaf.psp-menu-enabled:hover:before{color:#338DCD}perspective-viewer[settings] regular-table .psp-header-leaf .rt-column-resize{height:18px}.psp-row-selected,\n:hover .psp-row-selected,\n:hover th.psp-tree-leaf.psp-row-selected,\n:hover th.psp-tree-label.psp-row-selected{color:white!important;background-color:#EA7319!important;border-color:#EA7319!important}.psp-row-selected.psp-tree-label:not(:hover):before{color:white}.psp-row-subselected,\n:hover .psp-row-subselected,\n:hover th.psp-tree-leaf.psp-row-subselected,\n:hover th.psp-tree-label.psp-row-subselected{background:rgba(234,115,25,0.2)!important}.psp-error{color:red}td:focus{outline:#666;outline-style:dotted;outline-width:1px}perspective-viewer.dragging regular-table{pointer-events:none}.psp-header-border:last-child{border-right-width:0px}.psp-header-sort-desc:after{font-family:\"Material Icons\";font-size:10px;content:\"arrow_downward\"}.psp-header-sort-asc:after{font-family:\"Material Icons\";font-size:10px;content:\"arrow_upward\"}.psp-header-sort-col-desc:after{font-family:\"Material Icons\";font-size:10px;content:\"arrow_back\"}.psp-header-sort-col-asc:after{font-family:\"Material Icons\";font-size:10px;content:\"arrow_forward\"}tbody th:last-of-type{border-right:1px solid #eaedef;overflow:hidden;text-overflow:ellipsis}tbody th:empty{background-image:linear-gradient(to right,transparent 9px,#eee 10px,transparent 11px);background-repeat:no-repeat;min-width:20px;max-width:20px;pointer-events:none}.psp-tree-label{max-width:0px;min-width:0px}.psp-tree-label:before{color:#ccc;font-family:\"Material Icons\";padding-right:11px;vertical-align:-1px}.psp-tree-label-expand:before{content:\"add\"}.psp-tree-label-collapse:before{content:\"remove\"}.psp-tree-label:hover:before{color:#338DCD;text-shadow:0px 0px 5px #338DCD}regular-table thead tr:last-child th{border-bottom-width:0px}.psp-tree-leaf{padding-left:24px}.psp-align-right{text-align:right}.psp-align-left{text-align:left}.psp-positive:not(:focus){color:var(--rt-pos-cell--color,#338DCD)}.psp-negative:not(:focus){color:var(--rt-neg-cell--color,#FF5942)}regular-table table{user-select:none;color:#161616;border-collapse:separate}regular-table table th{font-weight:400}regular-table table td,\nregular-table table th{border-color:#eaedef;height:23px}regular-table table .psp-header-leaf{border-bottom-width:0px}regular-table table td,\nregular-table table th.psp-tree-label,\nregular-table table th.psp-tree-label,\nregular-table table th.psp-tree-leaf,\nregular-table table tbody tr:first-child th{border-style:solid;border-width:0px;border-top-width:1px}regular-table table tbody th:empty{background-position:0px -10px}";

/******************************************************************************
 *
 * Copyright (c) 2017, the Perspective Authors.
 *
 * This file is part of the Perspective library, distributed under the terms of
 * the Apache License 2.0.  The full license can be found in the LICENSE file.
 *
 */
async function getCellConfig({
  _view,
  _config
}, row_idx, col_idx) {
  const row_pivots = _config.row_pivots;
  const column_pivots = _config.column_pivots;
  const start_row = row_idx >= 0 ? row_idx : 0;
  const end_row = start_row + 1;
  const r = await _view.to_json({
    start_row,
    end_row
  });
  const row_paths = r.map(x => x.__ROW_PATH__);
  const row_pivots_values = row_paths[0] || [];
  const row_filters = row_pivots.map((pivot, index) => {
    const pivot_value = row_pivots_values[index];
    return pivot_value ? [pivot, "==", pivot_value] : undefined;
  }).filter(x => x);
  const column_index = row_pivots.length > 0 ? col_idx + 1 : col_idx;
  const column_paths = Object.keys(r[0])[column_index];
  const result = {
    row: r[0]
  };
  let column_filters = [];

  if (column_paths) {
    const column_pivot_values = column_paths.split("|");
    result.column_names = [column_pivot_values[column_pivot_values.length - 1]];
    column_filters = column_pivots.map((pivot, index) => {
      const pivot_value = column_pivot_values[index];
      return pivot_value ? [pivot, "==", pivot_value] : undefined;
    }).filter(x => x).filter(([,, value]) => value !== "__ROW_PATH__");
  }

  const filters = _config.filter.concat(row_filters).concat(column_filters);

  result.config = {
    filters
  };
  return result;
}

const selected_rows_map = new WeakMap();

async function selectionListener(regularTable, viewer, event) {
  const meta = regularTable.getMeta(event.target);
  if (!viewer.hasAttribute("selectable")) return;
  if (event.handled) return;

  if (event.which !== 1) {
    return;
  }

  if (!meta) {
    return;
  }

  const id = this._ids[meta.y - meta.y0];

  if (meta && meta.y >= 0) {
    const selected = selected_rows_map.get(regularTable);
    const key_match = !!selected && selected.reduce((agg, x, i) => agg && x === id[i], true);
    const is_deselect = !!selected && id.length === selected.length && key_match;
    let filters = [];

    if (is_deselect) {
      selected_rows_map.delete(regularTable);
    } else {
      selected_rows_map.set(regularTable, id);
      filters = await getCellConfig(this, meta.y, meta.x);
      filters = filters.config.filters;
    }

    await regularTable.draw();
    event.handled = true;
    viewer.dispatchEvent(new CustomEvent("perspective-select", {
      bubbles: true,
      composed: true,
      detail: {
        selected: !is_deselect,
        config: {
          filters
        }
      }
    }));
  }
}

function selectionStyleListener(regularTable, viewer) {
  if (!viewer.hasAttribute("selectable")) return;
  const has_selected = selected_rows_map.has(regularTable);
  const selected = selected_rows_map.get(regularTable);

  for (const td of regularTable.querySelectorAll("td")) {
    if (!has_selected) {
      td.classList.toggle("psp-row-selected", false);
      td.classList.toggle("psp-row-subselected", false);
    } else {
      const meta = regularTable.getMeta(td);
      const id = this._ids[meta.y - meta.y0];
      const key_match = selected.reduce((agg, x, i) => agg && x === id[i], true);
      td.classList.toggle("psp-row-selected", id.length === selected.length && key_match);
      td.classList.toggle("psp-row-subselected", id.length !== selected.length && key_match);
    }
  }

  for (const th of regularTable.querySelectorAll("tbody th")) {
    const meta = regularTable.getMeta(th);
    const id = this._ids[meta.y - meta.y0];

    if (!has_selected || !!id[meta.row_header_x]) {
      th.classList.toggle("psp-row-selected", false);
      th.classList.toggle("psp-row-subselected", false);
    } else {
      const key_match = selected.reduce((agg, x, i) => agg && x === id[i], true);
      th.classList.toggle("psp-row-selected", id.length === selected.length && key_match);
      th.classList.toggle("psp-row-subselected", id.length !== selected.length && key_match);
    }
  }
}

function configureRowSelectable(table, viewer) {
  table.addStyleListener(selectionStyleListener.bind(this, table, viewer));
  table.addEventListener("mousedown", selectionListener.bind(this, table, viewer));
}
async function deselect(regularTable) {
  selected_rows_map.delete(regularTable);

  for (const td of regularTable.querySelectorAll("td,th")) {
    td.classList.toggle("psp-row-selected", false);
    td.classList.toggle("psp-row-subselected", false);
  }
}

/******************************************************************************
 *
 * Copyright (c) 2017, the Perspective Authors.
 *
 * This file is part of the Perspective library, distributed under the terms of
 * the Apache License 2.0.  The full license can be found in the LICENSE file.
 *
 */

async function clickListener$1(table, viewer, event) {
  const meta = table.getMeta(event.target);
  if (!meta) return;
  const {
    x,
    y
  } = meta;
  const {
    row,
    column_names,
    config
  } = await getCellConfig(this, y, x);
  viewer.dispatchEvent(new CustomEvent("perspective-click", {
    bubbles: true,
    composed: true,
    detail: {
      row,
      column_names,
      config
    }
  }));
}

function configureClick(table, viewer) {
  table.addEventListener("click", clickListener$1.bind(this, table, viewer));
}

/******************************************************************************
 *
 * Copyright (c) 2017, the Perspective Authors.
 *
 * This file is part of the Perspective library, distributed under the terms of
 * the Apache License 2.0.  The full license can be found in the LICENSE file.
 *
 */
const selected_position_map = new WeakMap();

function lock(body) {
  let lock;
  return async function (...args) {
    if (!!lock && (await lock) && !!lock) {
      return;
    }

    let resolve;
    lock = new Promise(x => resolve = x);
    await body.apply(this, args);
    lock = undefined;
    resolve();
  };
}

function getPos() {
  if (this.isContentEditable) {
    let _range = document.getSelection().getRangeAt(0);

    let range = _range.cloneRange();

    range.selectNodeContents(this);
    range.setEnd(_range.endContainer, _range.endOffset);
    return range.toString().length;
  } else {
    return this.target.selectionStart;
  }
}

function write(table, model, active_cell) {
  const meta = table.getMeta(active_cell);
  const type = model._schema[model._column_paths[meta.x]];

  if (meta) {
    let text = active_cell.textContent;
    const id = model._ids[meta.y - meta.y0];

    if (type === "float" || type === "integer") {
      text = parseFloat(text.replace(/,/g, ""));

      if (isNaN(text)) {
        return false;
      }
    } else if (type === "date" || type === "datetime") {
      text = Date.parse(text);

      if (isNaN(text)) {
        return false;
      }
    }

    const msg = {
      __INDEX__: id,
      [model._column_paths[meta.x]]: text
    };

    model._table.update([msg], {
      port_id: model._edit_port
    });

    return true;
  }
}

function isEditable(viewer) {
  const has_pivots = this._config.row_pivots.length === 0 && this._config.column_pivots.length === 0;
  const selectable = viewer.hasAttribute("selectable");
  const editable = viewer.hasAttribute("editable");
  return has_pivots && !selectable && editable;
}

const moveSelection = lock(async function (table, active_cell, dx, dy) {
  const meta = table.getMeta(active_cell);
  const num_columns = this._column_paths.length;
  const num_rows = this._num_rows;
  const selected_position = selected_position_map.get(table);

  if (!selected_position) {
    return;
  }

  if (meta.x + dx < num_columns && 0 <= meta.x + dx) {
    selected_position.x = meta.x + dx;
  }

  if (meta.y + dy < num_rows && 0 <= meta.y + dy) {
    selected_position.y = meta.y + dy;
  }

  const xmin = Math.max(meta.x0 - 10, 0);
  const xmax = Math.min(meta.x0 + 10, num_columns);
  const ymin = Math.max(meta.y0 - 5, 0);
  const ymax = Math.min(meta.y0 + 10, num_rows);
  let x = meta.x0 + dx,
      y = meta.y0 + dy;

  while (!focusStyleListener(table) && x >= xmin && x < xmax && y >= ymin && y < ymax) {
    await table.scrollToCell(x, y, num_columns, num_rows);
    selected_position_map.set(table, selected_position);
    x += dx;
    y += dy;
  }
}); // Styles

function editableStyleListener(table, viewer) {
  // Independently check "editable" and `isEditable()`, so we can skip
  // the styler entirely if editing was disabled at the time of element
  // creation, but toggle in when e.g. pivots or selectable will
  // affect editability.
  if (!viewer.hasAttribute("editable")) {
    return;
  }

  const edit = isEditable.call(this, viewer);

  for (const td of table.querySelectorAll("td")) {
    td.toggleAttribute("contenteditable", edit);
  }
}

const focusStyleListener = table => {
  const tds = table.querySelectorAll("td");
  const selected_position = selected_position_map.get(table);

  if (selected_position) {
    for (const td of tds) {
      const meta = table.getMeta(td);

      if (meta.x === selected_position.x && meta.y === selected_position.y) {
        if (document.activeElement !== td) {
          td.focus({
            preventScroll: true
          });
        }

        return true;
      }
    }

    if (document.activeElement !== document.body && table.contains(document.activeElement)) {
      document.activeElement.blur();
    }
  }
}; // Events


function keydownListener(table, viewer, event) {
  if (!isEditable.call(this, viewer)) {
    return;
  }

  const target = document.activeElement;
  event.target.classList.remove("psp-error");

  switch (event.keyCode) {
    case 13:
      event.preventDefault();

      if (event.shiftKey) {
        moveSelection.call(this, table, target, 0, -1);
      } else {
        moveSelection.call(this, table, target, 0, 1);
      }

      break;

    case 37:
      if (getPos.call(target) == 0) {
        event.preventDefault();
        moveSelection.call(this, table, target, -1, 0);
      }

      break;

    case 38:
      event.preventDefault();
      moveSelection.call(this, table, target, 0, -1);
      break;

    case 39:
      if (getPos.call(target) == target.textContent.length) {
        event.preventDefault();
        moveSelection.call(this, table, target, 1, 0);
      }

      break;

    case 40:
      event.preventDefault();
      moveSelection.call(this, table, target, 0, 1);
      break;
  }
}

function focusoutListener(table, viewer, event) {
  if (isEditable.call(this, viewer) && selected_position_map.has(table)) {
    event.target.classList.remove("psp-error");
    const selectedPosition = selected_position_map.get(table);
    selected_position_map.delete(table);

    if (selectedPosition.content !== event.target.textContent) {
      if (!write(table, this, event.target)) {
        event.target.textContent = selectedPosition.content;
        event.target.classList.add("psp-error");
        event.target.focus();
      }
    }
  }
}

function focusinListener(table, viewer, event) {
  const meta = table.getMeta(event.target);

  if (meta) {
    const new_state = {
      x: meta.x,
      y: meta.y,
      content: event.target.textContent
    };
    selected_position_map.set(table, new_state);
  }
} // Plugin


async function configureEditable(table, viewer) {
  this._edit_port = await viewer.getEditPort();
  table.addStyleListener(editableStyleListener.bind(this, table, viewer));
  table.addStyleListener(focusStyleListener.bind(this, table, viewer));
  table.addEventListener("focusin", focusinListener.bind(this, table, viewer));
  table.addEventListener("focusout", focusoutListener.bind(this, table, viewer));
  table.addEventListener("keydown", keydownListener.bind(this, table, viewer));
}

/******************************************************************************
 *
 * Copyright (c) 2017, the Perspective Authors.
 *
 * This file is part of the Perspective library, distributed under the terms of
 * the Apache License 2.0.  The full license can be found in the LICENSE file.
 *
 */
async function configureSortable(table, viewer) {
  table.addEventListener("regular-table-psp-sort", event => {
    this._preserve_focus_state = true;
    viewer.setAttribute("sort", JSON.stringify(event.detail.sort));
  });
}

const VIEWER_MAP = new WeakMap();
const INSTALLED = new WeakMap();

function lock$1(body) {
  let lock;
  return async function (...args) {
    while (lock) {
      await lock;
    }

    let resolve;

    try {
      lock = new Promise(x => resolve = x);
      await body.apply(this, args);
    } finally {
      lock = undefined;
      resolve();
    }
  };
}

const datagridPlugin = lock$1(async function (regular, viewer, view) {
  const is_installed = INSTALLED.has(regular);
  const table = viewer.table;
  let model;

  if (!is_installed) {
    model = await createModel(regular, table, view);
    configureRegularTable(regular, model);
    await configureSortable.call(model, regular, viewer);
    await configureRowSelectable.call(model, regular, viewer);
    await configureEditable.call(model, regular, viewer);
    await configureClick.call(model, regular, viewer);
    INSTALLED.set(regular, model);
  } else {
    model = INSTALLED.get(regular);
    await createModel(regular, table, view, model);
  }

  const draw = regular.draw({
    invalid_columns: true
  });

  if (!model._preserve_focus_state) {
    regular.scrollTop = 0;
    regular.scrollLeft = 0;
    deselect(regular);

    regular._resetAutoSize();
  } else {
    model._preserve_focus_state = false;
  }

  await draw;
});
/**
 * Initializes a new datagrid renderer if needed, or returns an existing one
 * associated with a rendering `<div>` from a cache.
 *
 * @param {*} element
 * @param {*} div
 * @returns
 */

function get_or_create_datagrid(element, div) {
  let datagrid;

  if (!VIEWER_MAP.has(div)) {
    datagrid = document.createElement("regular-table");
    datagrid.formatters = formatters;
    div.innerHTML = "";
    div.appendChild(document.createElement("slot"));
    element.appendChild(datagrid);
    VIEWER_MAP.set(div, datagrid);
  } else {
    datagrid = VIEWER_MAP.get(div);

    if (!datagrid.isConnected) {
      div.innerHTML = "";
      div.appendChild(document.createElement("slot"));
      datagrid.clear();
      element.appendChild(datagrid);
    }
  }

  return datagrid;
}
/**
 * <perspective-viewer> plugin.
 *
 * @class DatagridPlugin
 */


class DatagridPlugin {
  static async update(div) {
    const datagrid = VIEWER_MAP.get(div);
    const model = INSTALLED.get(datagrid);
    model._num_rows = await model._view.num_rows();
    await datagrid.draw();
  }

  static async create(div, view) {
    const datagrid = get_or_create_datagrid(this, div);
    await datagridPlugin(datagrid, this, view);
  }

  static async resize() {
    if (this.view && VIEWER_MAP.has(this._datavis)) {
      const datagrid = VIEWER_MAP.get(this._datavis);

      if (INSTALLED.has(datagrid)) {
        await datagrid.draw();
      }
    }
  }

  static delete() {
    if (this.view && VIEWER_MAP.has(this._datavis)) {
      const datagrid = VIEWER_MAP.get(this._datavis);
      datagrid.clear();
    }
  }

  static save() {
    if (VIEWER_MAP.has(this._datavis)) {
      const datagrid = VIEWER_MAP.get(this._datavis);

      if (datagrid[PLUGIN_SYMBOL]) {
        return JSON.parse(JSON.stringify(datagrid[PLUGIN_SYMBOL]));
      }
    }
  }

  static restore(token) {
    const datagrid = get_or_create_datagrid(this, this._datavis);
    datagrid[PLUGIN_SYMBOL] = token;
  }

}
/**
 * Appends the default table CSS to `<head>`, should be run once on module
 * import.
 *
 */


_defineProperty(DatagridPlugin, "name", "Datagrid");

_defineProperty(DatagridPlugin, "selectMode", "toggle");

_defineProperty(DatagridPlugin, "deselectMode", "pivots");

function _register_global_styles() {
  const style = document.createElement("style");
  style.textContent = css_248z;
  document.head.appendChild(style);
}
/******************************************************************************
 *
 * Main
 *
 */


registerPlugin("datagrid", DatagridPlugin);

_register_global_styles();
//# sourceMappingURL=perspective-viewer-datagrid.js.map
