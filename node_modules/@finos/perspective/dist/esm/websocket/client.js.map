{"version":3,"sources":["../../../src/js/websocket/client.js"],"names":["Client","PING_TIMEOUT","WebSocketClient","constructor","ws","_ws","binaryType","_full_binary","_total_chunk_length","_pending_binary_length","onopen","send","id","cmd","ping","setTimeout","onmessage","msg","data","_pending_binary","binary_msg","set","Uint8Array","byteLength","buffer","result","_pending_port_id","undefined","new_data_with_port_id","port_id","delta","_handle","JSON","parse","binary_length","args","length","ArrayBuffer","pre_msg","stringify","terminate","Promise","resolve","onclose","close"],"mappings":"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","sourcesContent":["/******************************************************************************\n *\n * Copyright (c) 2017, the Perspective Authors.\n *\n * This file is part of the Perspective library, distributed under the terms of\n * the Apache License 2.0.  The full license can be found in the LICENSE file.\n *\n */\nimport {Client} from \"../api/client.js\";\n\n// Initiate a `ping` to the server every 30 seconds\nconst PING_TIMEOUT = 30000;\nexport class WebSocketClient extends Client {\n    constructor(ws) {\n        super();\n        this._ws = ws;\n        this._ws.binaryType = \"arraybuffer\";\n        this._full_binary;\n        this._total_chunk_length = 0;\n        this._pending_binary_length = 0;\n\n        this._ws.onopen = () => {\n            this.send({\n                id: -1,\n                cmd: \"init\"\n            });\n        };\n\n        const ping = () => {\n            this._ws.send(\"ping\");\n            setTimeout(ping, PING_TIMEOUT);\n        };\n\n        setTimeout(ping, PING_TIMEOUT);\n\n        this._ws.onmessage = msg => {\n            if (msg.data === \"pong\") {\n                return;\n            }\n\n            if (this._pending_binary) {\n                // Process a binary being sent by the server, which\n                // can decide how many chunks to send and the size of each\n                // chunk.\n                let binary_msg = msg.data;\n\n                this._full_binary.set(new Uint8Array(binary_msg), this._total_chunk_length);\n                this._total_chunk_length += binary_msg.byteLength;\n\n                // Use the total length of the binary from the pre-message\n                // to decide when to stop waiting for new chunks from the\n                // server.\n                if (this._total_chunk_length === this._pending_binary_length) {\n                    // Chunking is complete and the binary has been received\n                    // in full.\n                    binary_msg = this._full_binary.buffer;\n                } else {\n                    // Wait for another chunk.\n                    return;\n                }\n\n                let result = {\n                    data: {\n                        id: this._pending_binary,\n                        data: binary_msg\n                    }\n                };\n\n                // make sure on_update callbacks are called with a `port_id`\n                // AND the transferred binary.\n                if (this._pending_port_id !== undefined) {\n                    const new_data_with_port_id = {\n                        port_id: this._pending_port_id,\n                        delta: binary_msg\n                    };\n                    result.data.data = new_data_with_port_id;\n                }\n\n                // Send the joined message to the client for handling.\n                this._handle(result);\n\n                // Reset flags to end special message flow.\n                delete this._pending_binary;\n                delete this._pending_binary_length;\n                delete this._pending_port_id;\n\n                this._total_chunk_length = 0;\n                this._full_binary = null;\n            } else {\n                msg = JSON.parse(msg.data);\n\n                // If the message has `binary_length` set,the worker expects the\n                // next message to be a binary message. This sets the\n                // `_pending_binary` flag, which triggers a special handler for\n                // the ArrayBuffer containing binary data.\n                if (msg.binary_length) {\n                    this._pending_binary = msg.id;\n                    this._pending_binary_length = msg.binary_length;\n\n                    // Check whether the message also contains a `port_id`,\n                    // indicating that we are in an `on_update` callback and\n                    // the pending binary needs to be joined with the port_id\n                    // for on_update handlers to work properly.\n                    if (msg.data && msg.data.port_id !== undefined) {\n                        this._pending_port_id = msg.data.port_id;\n                    }\n\n                    // Create an empty ArrayBuffer to hold the binary, as it\n                    // will be sent in n >= 1 chunks.\n                    this._full_binary = new Uint8Array(this._pending_binary_length);\n                } else {\n                    this._handle({\n                        data: msg\n                    });\n                }\n            }\n        };\n    }\n\n    /**\n     * Send a message to the server, checking whether the arguments contain an\n     * ArrayBuffer.\n     *\n     * @param {Object} msg a message to send to the remote. If the `args`\n     * param contains an ArrayBuffer, two messages will be sent - a pre-message\n     * with the `binary_length` flag set to true, and a second message\n     * containing the ArrayBuffer. This allows for transport of metadata\n     * alongside an ArrayBuffer, and the pattern should be implemented by the\n     * receiver.\n     */\n    send(msg) {\n        if (msg.args && msg.args.length > 0 && msg.args[0] instanceof ArrayBuffer && msg.args[0].byteLength !== undefined) {\n            const pre_msg = msg;\n            msg.binary_length = msg.args[0].byteLength;\n            this._ws.send(JSON.stringify(pre_msg));\n            this._ws.send(msg.args[0]);\n            return;\n        }\n        this._ws.send(JSON.stringify(msg));\n    }\n\n    terminate() {\n        return new Promise(resolve => {\n            this._ws.onclose = resolve;\n            this._ws.close();\n        });\n    }\n}\n"],"file":"client.js"}