{"version":3,"sources":["../../../src/js/websocket/client.js"],"names":["PING_TIMEOUT","constructor","id","cmd","ping","setTimeout","msg","binary_msg","result","data","new_data_with_port_id","port_id","delta","JSON","send","pre_msg","terminate","resolve"],"mappings":"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","sourcesContent":["/******************************************************************************\n *\n * Copyright (c) 2017, the Perspective Authors.\n *\n * This file is part of the Perspective library, distributed under the terms of\n * the Apache License 2.0.  The full license can be found in the LICENSE file.\n *\n */\nimport {Client} from \"../api/client.js\";\n\n// Initiate a `ping` to the server every 30 seconds\nconst PING_TIMEOUT = 30000;\nexport class WebSocketClient extends Client {\n    constructor(ws) {\n        super();\n        this._ws = ws;\n        this._ws.binaryType = \"arraybuffer\";\n        this._full_binary;\n        this._total_chunk_length = 0;\n        this._pending_binary_length = 0;\n\n        this._ws.onopen = () => {\n            this.send({\n                id: -1,\n                cmd: \"init\"\n            });\n        };\n\n        const ping = () => {\n            this._ws.send(\"ping\");\n            setTimeout(ping, PING_TIMEOUT);\n        };\n\n        setTimeout(ping, PING_TIMEOUT);\n\n        this._ws.onmessage = msg => {\n            if (msg.data === \"pong\") {\n                return;\n            }\n\n            if (this._pending_binary) {\n                // Process a binary being sent by the server, which\n                // can decide how many chunks to send and the size of each\n                // chunk.\n                let binary_msg = msg.data;\n\n                this._full_binary.set(new Uint8Array(binary_msg), this._total_chunk_length);\n                this._total_chunk_length += binary_msg.byteLength;\n\n                // Use the total length of the binary from the pre-message\n                // to decide when to stop waiting for new chunks from the\n                // server.\n                if (this._total_chunk_length === this._pending_binary_length) {\n                    // Chunking is complete and the binary has been received\n                    // in full.\n                    binary_msg = this._full_binary.buffer;\n                } else {\n                    // Wait for another chunk.\n                    return;\n                }\n\n                let result = {\n                    data: {\n                        id: this._pending_binary,\n                        data: binary_msg\n                    }\n                };\n\n                // make sure on_update callbacks are called with a `port_id`\n                // AND the transferred binary.\n                if (this._pending_port_id !== undefined) {\n                    const new_data_with_port_id = {\n                        port_id: this._pending_port_id,\n                        delta: binary_msg\n                    };\n                    result.data.data = new_data_with_port_id;\n                }\n\n                // Send the joined message to the client for handling.\n                this._handle(result);\n\n                // Reset flags to end special message flow.\n                delete this._pending_binary;\n                delete this._pending_binary_length;\n                delete this._pending_port_id;\n\n                this._total_chunk_length = 0;\n                this._full_binary = null;\n            } else {\n                msg = JSON.parse(msg.data);\n\n                // If the message has `binary_length` set,the worker expects the\n                // next message to be a binary message. This sets the\n                // `_pending_binary` flag, which triggers a special handler for\n                // the ArrayBuffer containing binary data.\n                if (msg.binary_length) {\n                    this._pending_binary = msg.id;\n                    this._pending_binary_length = msg.binary_length;\n\n                    // Check whether the message also contains a `port_id`,\n                    // indicating that we are in an `on_update` callback and\n                    // the pending binary needs to be joined with the port_id\n                    // for on_update handlers to work properly.\n                    if (msg.data && msg.data.port_id !== undefined) {\n                        this._pending_port_id = msg.data.port_id;\n                    }\n\n                    // Create an empty ArrayBuffer to hold the binary, as it\n                    // will be sent in n >= 1 chunks.\n                    this._full_binary = new Uint8Array(this._pending_binary_length);\n                } else {\n                    this._handle({\n                        data: msg\n                    });\n                }\n            }\n        };\n    }\n\n    /**\n     * Send a message to the server, checking whether the arguments contain an\n     * ArrayBuffer.\n     *\n     * @param {Object} msg a message to send to the remote. If the `args`\n     * param contains an ArrayBuffer, two messages will be sent - a pre-message\n     * with the `binary_length` flag set to true, and a second message\n     * containing the ArrayBuffer. This allows for transport of metadata\n     * alongside an ArrayBuffer, and the pattern should be implemented by the\n     * receiver.\n     */\n    send(msg) {\n        if (msg.args && msg.args.length > 0 && msg.args[0] instanceof ArrayBuffer && msg.args[0].byteLength !== undefined) {\n            const pre_msg = msg;\n            msg.binary_length = msg.args[0].byteLength;\n            this._ws.send(JSON.stringify(pre_msg));\n            this._ws.send(msg.args[0]);\n            return;\n        }\n        this._ws.send(JSON.stringify(msg));\n    }\n\n    terminate() {\n        return new Promise(resolve => {\n            this._ws.onclose = resolve;\n            this._ws.close();\n        });\n    }\n}\n"],"file":"client.js"}