{"version":3,"file":"regular-table.js","sources":["../../src/js/constants.js","../../src/js/view_model.js","../../src/js/thead.js","../../src/js/tbody.js","../../src/js/utils.js","../../src/js/table.js","../../src/js/scroll_panel.js","../../src/js/events.js","../../src/js/index.js"],"sourcesContent":["/******************************************************************************\n *\n * Copyright (c) 2020, the Regular Table Authors.\n *\n * This file is part of the Regular Table library, distributed under the terms\n * of the Apache License 2.0.  The full license can be found in the LICENSE\n * file.\n *\n */\n\n// Singleton `WeakMap`s to store metadata for td/th elements, as well as the\n// datagrids themselves for each `<perspective-viewer>`\nexport const METADATA_MAP = new WeakMap();\n\n// Output runtime debug info like FPS.\nexport const DEBUG = true;\n\n// The largest size virtual <div> in (px) that Chrome can support without\n// glitching.\nconst isFirefox = navigator.userAgent.toLowerCase().indexOf(\"firefox\") > -1;\nexport const BROWSER_MAX_HEIGHT = isFirefox ? 5000000 : 10000000;\n","/******************************************************************************\n *\n * Copyright (c) 2020, the Regular Table Authors.\n *\n * This file is part of the Regular Table library, distributed under the terms\n * of the Apache License 2.0.  The full license can be found in the LICENSE\n * file.\n *\n */\n\nimport {METADATA_MAP} from \"./constants\";\n\n/******************************************************************************\n *\n * View Model\n *\n */\n\nexport class ViewModel {\n    constructor(column_sizes, container, table) {\n        this._column_sizes = column_sizes;\n        this._container = container;\n        this.table = table;\n        this.cells = [];\n        this.rows = [];\n    }\n\n    num_columns() {\n        return this._get_row(Math.max(0, this.rows.length - 1)).row_container.length;\n    }\n\n    num_rows() {\n        return this.cells.length;\n    }\n\n    _set_metadata(td, metadata) {\n        METADATA_MAP.set(td, metadata);\n    }\n\n    _get_or_create_metadata(td) {\n        if (td === undefined) {\n            return {};\n        } else if (METADATA_MAP.has(td)) {\n            return METADATA_MAP.get(td);\n        } else {\n            const metadata = {};\n            METADATA_MAP.set(td, metadata);\n            return metadata;\n        }\n    }\n\n    _replace_cell(ridx, cidx) {\n        const {tr, row_container} = this._get_row(ridx);\n        let td = row_container[cidx];\n        if (td) {\n            tr.removeChild(td);\n            row_container.splice(cidx, 1, undefined);\n        }\n        return td;\n    }\n\n    _fetch_cell(ridx, cidx) {\n        if (ridx < 0 || cidx < 0) {\n            return;\n        }\n        const {row_container} = this._get_row(ridx);\n        return row_container[cidx];\n    }\n\n    _get_cell(tag = \"TD\", ridx, cidx) {\n        const {tr, row_container} = this._get_row(ridx);\n        let td = row_container[cidx];\n        if (!td) {\n            if (cidx < row_container.length) {\n                td = row_container[cidx] = document.createElement(tag);\n                tr.insertBefore(\n                    td,\n                    row_container.slice(cidx + 1).find((x) => x)\n                );\n            } else {\n                td = row_container[cidx] = document.createElement(tag);\n                tr.appendChild(td);\n            }\n        }\n        if (td.tagName !== tag) {\n            const new_td = document.createElement(tag);\n            tr.replaceChild(new_td, td);\n            this.cells[ridx].splice(cidx, 1, new_td);\n            td = new_td;\n        }\n        return td;\n    }\n\n    _get_row(ridx) {\n        let tr = this.rows[ridx];\n        if (!tr) {\n            tr = this.rows[ridx] = document.createElement(\"tr\");\n            this.table.appendChild(tr);\n        }\n\n        let row_container = this.cells[ridx];\n        if (!row_container) {\n            row_container = this.cells[ridx] = [];\n        }\n\n        return {tr, row_container};\n    }\n\n    _clean_columns(cidx) {\n        for (let i = 0; i < this.rows.length; i++) {\n            const tr = this.rows[i];\n            const row_container = this.cells[i];\n            this.cells[i] = row_container.slice(0, cidx[i] || cidx);\n            const idx = this.cells[i].filter((x) => x !== undefined).length;\n            while (tr.children[idx]) {\n                tr.removeChild(tr.children[idx]);\n            }\n        }\n    }\n\n    _clean_rows(ridx) {\n        while (this.table.children[ridx]) {\n            this.table.removeChild(this.table.children[ridx]);\n        }\n        this.rows = this.rows.slice(0, ridx);\n        this.cells = this.cells.slice(0, ridx);\n    }\n}\n","/******************************************************************************\n *\n * Copyright (c) 2020, the Regular Table Authors.\n *\n * This file is part of the Regular Table library, distributed under the terms\n * of the Apache License 2.0.  The full license can be found in the LICENSE\n * file.\n *\n */\n\nimport {ViewModel} from \"./view_model\";\n\n/**\n * <thead> view model.  This model accumulates state in the form of\n * column_sizes, which leverages <tables> autosize behavior across\n * virtual pages.\n *\n * @class RegularHeaderViewModel\n */\nexport class RegularHeaderViewModel extends ViewModel {\n    _draw_group_th(offset_cache, d, column) {\n        const th = this._get_cell(\"TH\", d, offset_cache[d] || 0);\n        offset_cache[d] += 1;\n        th.removeAttribute(\"colspan\");\n        th.style.minWidth = \"0\";\n\n        th.textContent = \"\";\n        if (column instanceof HTMLElement) {\n            th.appendChild(column);\n        } else {\n            const span = document.createElement(\"span\");\n            span.textContent = column;\n            th.appendChild(span);\n        }\n\n        const resizeSpan = document.createElement(\"span\");\n        resizeSpan.className = \"rt-column-resize\";\n        th.appendChild(resizeSpan);\n\n        return th;\n    }\n\n    _draw_group(column, column_name, th) {\n        const metadata = this._get_or_create_metadata(th);\n        metadata.column_header = column;\n        metadata.value = column_name;\n        metadata.value = column_name;\n        return metadata;\n    }\n\n    _draw_th(column, column_name, th, cidx, size_key) {\n        const metadata = this._get_or_create_metadata(th);\n        metadata.column_header = column;\n        metadata.value = column_name;\n        metadata.size_key = size_key.length ? size_key[0] : size_key; // FIXME\n\n        if (!(size_key.length > 1)) {\n            const override_width = this._column_sizes.override[metadata.size_key];\n            const auto_width = this._column_sizes.auto[metadata.size_key];\n            if (override_width) {\n                th.classList.toggle(\"rt-cell-clip\", auto_width > override_width);\n                th.style.minWidth = override_width + \"px\";\n                th.style.maxWidth = override_width + \"px\";\n            } else if (auto_width) {\n                th.classList.remove(\"rt-cell-clip\");\n                th.style.maxWidth = \"\";\n                th.style.minWidth = auto_width + \"px\";\n            } else {\n                th.style.maxWidth = \"\";\n                th.style.maxWidth = \"\";\n            }\n        }\n\n        return metadata;\n    }\n\n    get_column_header(cidx) {\n        return this._get_cell(\"TH\", this.num_rows() - 1, cidx);\n    }\n\n    _group_header_cache = [];\n    _offset_cache = [];\n\n    draw(alias, parts, colspan, x, size_key, x0, _virtual_x) {\n        const header_levels = parts?.length; //config.column_pivots.length + 1;\n        if (header_levels === 0) return {};\n        let th, metadata, column_name;\n        for (let d = 0; d < header_levels; d++) {\n            column_name = parts[d] ? parts[d] : \"\";\n            this._offset_cache[d] = this._offset_cache[d] || 0;\n            if (d < header_levels - 1) {\n                if (this._group_header_cache?.[d]?.[0]?.value === column_name) {\n                    th = this._group_header_cache[d][1];\n                    this._group_header_cache[d][2] += 1;\n                    if (colspan === 1) {\n                        this._group_header_cache[d][0].row_header_x = size_key;\n                    }\n                    th.setAttribute(\"colspan\", this._group_header_cache[d][2]);\n                } else {\n                    th = this._draw_group_th(this._offset_cache, d, column_name);\n                    metadata = this._draw_group(parts, column_name, th);\n                    this._group_header_cache[d] = [metadata, th, 1];\n                }\n            } else {\n                th = this._draw_group_th(this._offset_cache, d, column_name);\n\n                // Update the group header's metadata such that each group\n                // header has the same metadata coordinates of its rightmost\n                // column.\n                metadata = this._draw_th(alias || parts, column_name, th, x, size_key);\n                for (const [group_meta] of this._group_header_cache) {\n                    group_meta.size_key = metadata.size_key;\n                }\n                th.removeAttribute(\"colspan\");\n            }\n            if (metadata) {\n                metadata.x = x;\n                metadata.column_header_y = d;\n                metadata.x0 = x0;\n                metadata._virtual_x = _virtual_x;\n                if (colspan === 1) {\n                    metadata.row_header_x = size_key;\n                }\n            }\n        }\n\n        this._clean_rows(this._offset_cache.length);\n        return {th, metadata};\n    }\n\n    clean() {\n        this._clean_columns(this._offset_cache);\n    }\n\n    reset_header_cache() {\n        this._offset_cache = [];\n        this._group_header_cache = [];\n    }\n}\n","/******************************************************************************\n *\n * Copyright (c) 2020, the Regular Table Authors.\n *\n * This file is part of the Regular Table library, distributed under the terms\n * of the Apache License 2.0.  The full license can be found in the LICENSE\n * file.\n *\n */\n\nimport {ViewModel} from \"./view_model\";\n\n// const ROW_HEADER_RENDER_MODE = \"rowspan\";\n// console.assert([\"none\", \"rowspan\", \"colspan\"].indexOf(ROW_HEADER_RENDER_MODE) > -1, \"Invalid ROW_HEADER_RENDERER_MODE\");\n\n/**\n * <tbody> view model.\n *\n * @class RegularBodyViewModel\n */\nexport class RegularBodyViewModel extends ViewModel {\n    _draw_td(tagName, ridx, val, cidx, {column_name}, {ridx_offset}, size_key) {\n        const td = this._get_cell(tagName, ridx, cidx);\n        const metadata = this._get_or_create_metadata(td);\n        metadata.y = ridx + ridx_offset;\n        metadata.size_key = size_key;\n        if (tagName === \"TD\") {\n            metadata.column_header = column_name;\n        }\n        const override_width = this._column_sizes.override[metadata.size_key];\n        if (override_width) {\n            const auto_width = this._column_sizes.auto[metadata.size_key];\n            td.classList.toggle(\"rt-cell-clip\", auto_width > override_width);\n            td.style.minWidth = override_width + \"px\";\n            td.style.maxWidth = override_width + \"px\";\n        } else {\n            td.classList.remove(\"rt-cell-clip\");\n            td.style.minWidth = \"\";\n            td.style.maxWidth = \"\";\n        }\n\n        if (val instanceof HTMLElement) {\n            td.textContent = \"\";\n            td.appendChild(val);\n        } else {\n            td.textContent = val;\n        }\n\n        metadata.value = val;\n        return {td, metadata};\n    }\n\n    draw(container_height, column_state, view_state, th = false, x, x0, size_key) {\n        const {cidx, column_data, row_headers, column_data_listener_metadata} = column_state;\n        let {row_height} = view_state;\n        let metadata;\n        const ridx_offset = [],\n            tds = [];\n        let ridx = 0;\n        const cidx_offset = [];\n        for (let i = 0; i < (th ? view_state.row_headers_length : 1); i++) {\n            ridx = 0;\n\n            for (const val of column_data) {\n                const id = row_headers?.[ridx];\n                let obj;\n                if (th) {\n                    const row_header = val[i];\n                    const prev_row = this._fetch_cell(ridx - (ridx_offset[i] || 1), cidx + i);\n                    const prev_row_metadata = this._get_or_create_metadata(prev_row);\n\n                    const prev_col = this._fetch_cell(ridx, cidx + i - (cidx_offset[ridx] || 1));\n                    const prev_col_metadata = this._get_or_create_metadata(prev_col);\n\n                    if (prev_col && (prev_col_metadata.value === row_header || row_header === undefined) && !prev_col.hasAttribute(\"rowspan\")) {\n                        cidx_offset[ridx] = cidx_offset[ridx] ? cidx_offset[ridx] + 1 : 2;\n                        prev_col.setAttribute(\"colspan\", cidx_offset[ridx]);\n                        this._replace_cell(ridx, cidx + i);\n                    } else if (prev_row && prev_row_metadata.value === row_header && !prev_row.hasAttribute(\"colspan\")) {\n                        ridx_offset[i] = ridx_offset[i] ? ridx_offset[i] + 1 : 2;\n                        prev_row.setAttribute(\"rowspan\", ridx_offset[i]);\n                        this._replace_cell(ridx, cidx + i);\n                    } else {\n                        obj = this._draw_td(\"TH\", ridx, row_header, cidx + i, column_state, view_state, i);\n                        obj.td.style.display = \"\";\n                        obj.td.removeAttribute(\"rowspan\");\n                        obj.td.removeAttribute(\"colspan\");\n                        obj.metadata.row_header = val;\n                        obj.metadata.row_header_x = i;\n                        obj.metadata.x0 = x0;\n                        obj.metadata.y0 = view_state.ridx_offset;\n                        obj.metadata.y1 = view_state.y1;\n                        obj.metadata._virtual_x = i;\n                        ridx_offset[i] = 1;\n                        cidx_offset[ridx] = 1;\n                        tds[i] = obj;\n                    }\n                } else {\n                    obj = this._draw_td(\"TD\", ridx, val, cidx, column_state, view_state, size_key);\n                    if (column_data_listener_metadata) {\n                        obj.metadata.user = column_data_listener_metadata[ridx];\n                    }\n\n                    obj.metadata.x = x;\n                    obj.metadata.x0 = x0;\n                    obj.metadata.x1 = view_state.x1;\n                    obj.metadata.row_header = id || [];\n                    obj.metadata.y0 = view_state.ridx_offset;\n                    obj.metadata.y1 = view_state.y1;\n                    obj.metadata.dx = x - x0;\n                    obj.metadata.dy = obj.metadata.y - obj.metadata.y0;\n                    obj.metadata._virtual_x = cidx;\n                    tds[0] = obj;\n                }\n\n                ridx++;\n                metadata = obj ? obj.metadata : metadata;\n                row_height = row_height || obj?.td.offsetHeight;\n                if (ridx * row_height > container_height) {\n                    break;\n                }\n            }\n        }\n        this._clean_rows(ridx);\n        return {tds, ridx, metadata, row_height};\n    }\n\n    clean({ridx, cidx}) {\n        this._clean_rows(ridx);\n        this._clean_columns(cidx);\n    }\n}\n","/******************************************************************************\n *\n * Copyright (c) 2020, the Regular Table Authors.\n *\n * This file is part of the Regular Table library, distributed under the terms\n * of the Apache License 2.0.  The full license can be found in the LICENSE\n * file.\n *\n */\n\n/******************************************************************************\n *\n * Profling\n *\n */\n\nlet AVG = 0,\n    TOTAL = 0,\n    START = performance.now();\n\nexport function get_draw_fps() {\n    const now = performance.now();\n    const elapsed = now - START;\n    const avg = AVG;\n    const real_fps = (TOTAL * 1000) / elapsed;\n    const virtual_fps = 1000 / avg;\n    const num_frames = TOTAL;\n    AVG = 0;\n    TOTAL = 0;\n    START = now;\n    return {avg, real_fps, virtual_fps, num_frames, elapsed};\n}\n\nexport function log_perf(x) {\n    AVG = (AVG * TOTAL + x) / (TOTAL + 1);\n    TOTAL += 1;\n}\n\n/******************************************************************************\n *\n * Utils\n *\n */\n\n/**\n * A class method decorate for memoizing method results.  Only works on one\n * arg.\n */\nexport function memoize(_target, _property, descriptor) {\n    const cache = new Map();\n    const func = descriptor.value;\n    descriptor.value = new_func;\n    return descriptor;\n    function new_func(arg) {\n        if (cache.has(arg)) {\n            return cache.get(arg);\n        } else {\n            const res = func.call(this, arg);\n            cache.set(arg, res);\n            return res;\n        }\n    }\n}\n\n/**\n * Identical to a non-tagger template literal, this is only used to indicate to\n * babel that this string should be HTML-minified on production builds.\n */\nexport const html = (strings, ...args) =>\n    strings\n        .map((str, i) => [str, args[i]])\n        .flat()\n        .filter((a) => !!a)\n        .join(\"\");\n\nconst invertPromise = () => {\n    let _resolve;\n    const promise = new Promise((resolve) => {\n        _resolve = resolve;\n    });\n    promise.resolve = _resolve;\n    return promise;\n};\n\nexport function throttlePromise(target, property, descriptor) {\n    const lock = Symbol(\"private lock\");\n    const f = descriptor.value;\n    descriptor.value = async function (...args) {\n        if (this[lock]) {\n            await this[lock];\n            if (this[lock]) {\n                await this[lock];\n                return;\n            }\n        }\n        this[lock] = invertPromise();\n        let result;\n        try {\n            result = await f.call(this, ...args);\n        } finally {\n            const l = this[lock];\n            this[lock] = undefined;\n            l.resolve();\n        }\n        return result;\n    };\n    descriptor.value.flush = function () {\n        return this[lock];\n    };\n    return descriptor;\n}\n","/******************************************************************************\n *\n * Copyright (c) 2020, the Regular Table Authors.\n *\n * This file is part of the Regular Table library, distributed under the terms\n * of the Apache License 2.0.  The full license can be found in the LICENSE\n * file.\n *\n */\n\nimport {RegularHeaderViewModel} from \"./thead\";\nimport {RegularBodyViewModel} from \"./tbody\";\nimport {html} from \"./utils\";\n\n/**\n * <table> view model.  In order to handle unknown column width when `draw()`\n * is called, this model will iteratively fetch more data to fill in columns\n * until the page is complete, and makes some column viewport estimations\n * when this information is not availble.\n *\n * @class RegularTableViewModel\n */\nexport class RegularTableViewModel {\n    constructor(table_clip, column_sizes, element) {\n        this.clear(element);\n        const [table] = element.children;\n        const [thead, tbody] = table.children;\n        this.table = table;\n        this._column_sizes = column_sizes;\n        this.header = new RegularHeaderViewModel(column_sizes, table_clip, thead);\n        this.body = new RegularBodyViewModel(column_sizes, table_clip, tbody);\n        this.fragment = document.createDocumentFragment();\n    }\n\n    num_columns() {\n        return this.header.num_columns();\n    }\n\n    clear(element) {\n        element.innerHTML = html`\n            <table cellspacing=\"0\">\n                <thead></thead>\n                <tbody></tbody>\n            </table>\n        `;\n    }\n\n    /**\n     * Calculate amendments to auto size from this render pass.\n     *\n     * @param {*} last_cells\n     * @param {*} {columns, column_pivots}\n     * @memberof RegularTableViewModel\n     */\n    autosize_cells(last_cells) {\n        while (last_cells.length > 0) {\n            const [cell, metadata, row_height_cell] = last_cells.pop();\n            let offsetWidth;\n            const style = getComputedStyle(cell);\n            if (style.boxSizing !== \"border-box\") {\n                offsetWidth = cell.clientWidth;\n                offsetWidth -= parseFloat(style.paddingLeft);\n                offsetWidth -= parseFloat(style.paddingRight);\n            } else {\n                offsetWidth = cell.offsetWidth;\n            }\n            this._column_sizes.row_height = this._column_sizes.row_height || row_height_cell.offsetHeight;\n            this._column_sizes.indices[metadata.size_key] = offsetWidth;\n            const is_override = this._column_sizes.override.hasOwnProperty(metadata.size_key);\n            if (offsetWidth && !is_override) {\n                this._column_sizes.auto[metadata.size_key] = offsetWidth;\n            }\n            if (cell.style.minWidth === \"0px\") {\n                cell.style.minWidth = `${offsetWidth}px`;\n            }\n        }\n    }\n\n    async *draw(container_size, view_cache, selected_id, preserve_width, viewport, num_columns) {\n        const {width: container_width, height: container_height} = container_size;\n        const {view, config} = view_cache;\n        let {data, row_headers, column_headers, metadata: data_listener_metadata} = await view(viewport.start_col, viewport.start_row, viewport.end_col, viewport.end_row);\n        const {start_row: ridx_offset = 0, start_col: x0 = 0, end_col: x1 = 0, end_row: y1 = 0} = viewport;\n\n        // pad row_headers for embedded renderer\n        // TODO maybe dont need this - perspective compat\n        if (row_headers) {\n            this._row_headers_length = row_headers.reduce((max, x) => Math.max(max, x.length), 0);\n            row_headers = row_headers.map((x) => {\n                x.length = this._row_headers_length;\n                return x;\n            });\n        }\n\n        view_cache.config.column_pivots = Array.from(Array(column_headers?.[0]?.length - 1 || 0).keys());\n        view_cache.config.row_pivots = Array.from(Array(row_headers?.[0]?.length || 0).keys());\n\n        const view_state = {\n            viewport_width: 0,\n            selected_id,\n            ridx_offset,\n            x0: x0,\n            x1: x1,\n            y1: y1,\n            row_height: this._column_sizes.row_height,\n            row_headers_length: this._row_headers_length,\n        };\n\n        let cont_body,\n            _virtual_x = 0,\n            last_cells = [],\n            first_col = true;\n        if (row_headers?.length > 0) {\n            const column_name = config.row_pivots.join(\",\");\n\n            const column_state = {\n                column_name,\n                cidx: 0,\n                column_data: row_headers,\n                row_headers,\n                first_col,\n            };\n            const size_key = _virtual_x + x0;\n            cont_body = this.body.draw(container_height, column_state, {...view_state, x0: 0}, true, undefined, undefined, size_key);\n            const cont_heads = [];\n            for (let i = 0; i < view_cache.config.row_pivots.length; i++) {\n                cont_heads.push(this.header.draw(column_name, Array(view_cache.config.column_pivots.length + 1).fill(\"\"), 1, undefined, i, x0, i));\n            }\n            first_col = false;\n            view_state.viewport_width += cont_heads.reduce((total, {th}, i) => total + (this._column_sizes.indices[i] || th.offsetWidth), 0);\n            view_state.row_height = view_state.row_height || cont_body.row_height;\n            _virtual_x = row_headers[0].length;\n            if (!preserve_width) {\n                for (let i = 0; i < view_cache.config.row_pivots.length; i++) {\n                    const {td, metadata} = cont_body.tds[i] || {};\n                    const {th, metadata: hmetadata} = cont_heads[i];\n                    last_cells.push([th || td, hmetadata || metadata, td || th]);\n                }\n            }\n        }\n\n        try {\n            let dcidx = 0;\n            const num_visible_columns = num_columns - viewport.start_col;\n            while (dcidx < num_visible_columns) {\n                // If there is no column for this data, our pre-fetch viewport\n                // estimate was wrong and we'll need to do a mid-render fetch\n                // to get more data.\n                if (!data[dcidx]) {\n                    let missing_cidx = Math.max(viewport.end_col, 0);\n                    viewport.start_col = missing_cidx;\n\n                    // Calculate a new data window width based on how large the\n                    // columns drawn so far take up.  This can either be\n                    // summed if we've drawn/measured these columns before,\n                    // or estimated by avg if the missing columns have never\n                    // been seen by the renderer.\n                    let end_col_offset = 0,\n                        size_extension = 0;\n                    while (this._column_sizes.indices.length > _virtual_x + x0 + end_col_offset + 1 && size_extension + view_state.viewport_width < container_width) {\n                        end_col_offset++;\n                        size_extension += this._column_sizes.indices[_virtual_x + x0 + end_col_offset];\n                    }\n\n                    if (size_extension + view_state.viewport_width < container_width) {\n                        const estimate = Math.min(num_columns, missing_cidx + 5); //Math.ceil(((dcidx + end_col_offset) * container_width) / (view_state.viewport_width + size_extension) + 1);\n                        viewport.end_col = Math.max(1, Math.min(num_columns, estimate));\n                    } else {\n                        viewport.end_col = Math.max(1, Math.min(num_columns, missing_cidx + end_col_offset));\n                    }\n\n                    // Fetch the new data window extension and append it to the\n                    // cached data page and continue.\n                    const new_col_req = view(viewport.start_col, viewport.start_row, viewport.end_col, viewport.end_row);\n                    yield undefined;\n                    const new_col = await new_col_req;\n\n                    if (new_col.data.length === 0) {\n                        // The viewport is size 0, first the estimate, then the\n                        // first-pass render, so really actually abort now.\n                        yield last_cells;\n                        return;\n                    }\n\n                    viewport.end_col = viewport.start_col + new_col.data.length;\n                    for (let i = 0; i < new_col.data.length; i++) {\n                        data[dcidx + i] = new_col.data[i];\n                        if (new_col.metadata) {\n                            data_listener_metadata[dcidx + i] = new_col.metadata[i];\n                        }\n\n                        if (column_headers) {\n                            column_headers[dcidx + i] = new_col.column_headers?.[i];\n                        }\n                    }\n                }\n\n                const column_name = column_headers?.[dcidx] || \"\";\n                const column_data = data[dcidx];\n                const column_data_listener_metadata = data_listener_metadata?.[dcidx];\n                const column_state = {\n                    column_name,\n                    cidx: _virtual_x,\n                    column_data,\n                    column_data_listener_metadata,\n                    row_headers,\n                    first_col,\n                };\n\n                const x = dcidx + x0;\n                const size_key = _virtual_x + x0;\n                const cont_head = this.header.draw(undefined, column_name, undefined, x, size_key, x0, _virtual_x);\n                cont_body = this.body.draw(container_height, column_state, view_state, false, x, x0, size_key);\n                first_col = false;\n                if (!preserve_width) {\n                    for (const {td, metadata} of cont_body.tds) {\n                        last_cells.push([cont_head.th || td, cont_head.metadata || metadata, td || cont_head.th]);\n                    }\n                }\n\n                const last_measured_col_width = this._column_sizes.indices[_virtual_x + x0];\n                if (last_measured_col_width) {\n                    view_state.viewport_width += last_measured_col_width;\n                } else {\n                    view_state.viewport_width += cont_head.th?.offsetWidth || cont_body.tds.reduce((x, y) => x + y.td?.offsetWidth, 0);\n                }\n\n                view_state.row_height = view_state.row_height || cont_body.row_height;\n                _virtual_x++;\n                dcidx++;\n\n                if (view_state.viewport_width > container_width) {\n                    this.body.clean({ridx: cont_body?.ridx || 0, cidx: _virtual_x});\n                    this.header.clean();\n                    yield last_cells;\n\n                    // If we make it here, this draw() call was invalidated by\n                    // a call to `invalidate()` within a `StyleListener`, so\n                    // recalculate the cumulative width and keep drawing if\n                    // necessary.  Note `last_cells` is a list of 2-tuples but\n                    // we only bind the first var because _eslint_.\n                    view_state.viewport_width = 0;\n                    for (let [td] of last_cells) {\n                        view_state.viewport_width += td.offsetWidth;\n                    }\n\n                    // If there are still enough columns to fill the screen,\n                    // completely end the iteration here, otherwise\n                    // continue iterating to draw another column.\n                    if (view_state.viewport_width > container_width) {\n                        return;\n                    }\n                }\n            }\n            this.body.clean({ridx: cont_body?.ridx || 0, cidx: _virtual_x});\n            this.header.clean();\n            yield last_cells;\n        } finally {\n            this.body.clean({ridx: cont_body?.ridx || 0, cidx: _virtual_x});\n            this.header.clean();\n        }\n    }\n}\n","/******************************************************************************\n *\n * Copyright (c) 2020, the Regular Table Authors.\n *\n * This file is part of the Regular Table library, distributed under the terms\n * of the Apache License 2.0.  The full license can be found in the LICENSE\n * file.\n *\n */\n\nimport {log_perf, html, throttlePromise} from \"./utils\";\nimport {DEBUG, BROWSER_MAX_HEIGHT} from \"./constants\";\n\nimport container_css from \"../less/container.less\";\n\n/**\n * Handles the virtual scroll pane, as well as the double buffering\n * of the underlying <table>. This DOM structure looks a little like\n * this:\n *\n *     +------------------------+      <- div.rt-scroll-container\n *     | +----------------------|------<- div.rt-virtual-panel\n *     | | +------------------+ |      <- div.rt-scroll-table-clip\n *     | | | +----------------|-|--+   <- table             |\n *     | | | | 1  A  Alabama  | |  |                        |\n *     | | | | 2  B  Arizona  | |  |                        |\n *     | | | | 3  C  Arkansas | |  |                        |\n *     | | | | 4  D  Californi| |  |                        |\n *     | | | | 5  E  Colorado | |  |                        |\n *     | | +------------------+ |  |                        |\n *     +------------------------+  |                        |\n *       |   | 8  H  District of C |                        |\n *       |   +---------------------+                        |\n *       |                                                  |\n *       |                                                  |\n *       |                                                  |\n *       |                                                  |\n *       |                                                  |\n *       +--------------------------------------------------+\n *\n * `overflow: auto` is applied to `.rt-scroll-container`, and `.rt-virtual-pane`\n * is sized to match the estimated \"virtual\" size of the `table`;  estimated,\n * because it's true size can't be known until all columns dimensions are known,\n * which may be deferred in the case of auto-sized tables.\n *\n * Double buffering can be enabled on \"column scroll\", \"row scroll\" and/or\n * \"column schema change\".  When enabled and a redraw is requested for the case,\n * the existing table is cloned with `cloneNode()` and swapped with the real\n * `table`, which is then updated offscreen and swapped back in.  While this is\n * much slower to render, it prevents draw-in.\n *\n * @class RegularVirtualTableViewModel\n */\nexport class RegularVirtualTableViewModel extends HTMLElement {\n    /**\n     * Create the DOM for this `shadowRoot`.\n     *\n     * TODO deprecated\n     * `MATERIAL_STYLE` is needed both here, and in the document `<head>`, due\n     * to double buffering, which may read incorrect position/size values as the\n     * double buffered `<table>` is rendered in the shadow DOM before being\n     * swapped in.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     */\n    create_shadow_dom() {\n        this.attachShadow({mode: \"open\"});\n        const slot = `<slot></slot>`;\n        this.shadowRoot.innerHTML = html`\n            <style>\n                ${container_css}\n            </style>\n            <div class=\"rt-virtual-panel\"></div>\n            <div class=\"rt-scroll-table-clip\">\n                ${slot}\n            </div>\n        `;\n\n        const [, virtual_panel, table_clip] = this.shadowRoot.children;\n        this._table_clip = table_clip;\n        this._virtual_panel = virtual_panel;\n        this._setup_virtual_scroll();\n    }\n\n    _setup_virtual_scroll() {\n        if (this._table_clip) {\n            if (this._virtual_mode === \"both\" || this._virtual_mode === \"vertical\") {\n                this._table_clip.style.top = \"0px\";\n            }\n\n            if (this._virtual_mode === \"both\" || this._virtual_mode === \"horizontal\") {\n                this._table_clip.style.left = \"0px\";\n            }\n        }\n    }\n\n    /**\n     * Calculates the `viewport` argument for perspective's `to_columns` method.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @param {*} nrows\n     * @param {*} reset_scroll_position\n     * @returns\n     */\n    _calculate_viewport(nrows, num_columns, reset_scroll_position, invalid_columns) {\n        const {start_row, end_row} = this._calculate_row_range(nrows, reset_scroll_position);\n        const {start_col, end_col} = this._calculate_column_range(num_columns, invalid_columns);\n        this._nrows = nrows;\n        return {start_col, end_col, start_row, end_row};\n    }\n\n    /**\n     * Calculate `start_row` and `end_row` for the viewport.  We do this by\n     * first calculating `total_scroll_height`, the px height of the\n     * scrollable page, from the `_virtual_panel.offsetHeight`.\n     *\n     *    0px +------------+-------------+  - virtual_panel.offsetHeight\n     *        |            |  .          |  . 600px\n     *        |  viewport  |  .          |  .\n     *        |            |  .          |  .\n     *  200px +------------+  - height   |  .  - total_scroll_height\n     *        |                 200px    |  .  . 400px\n     *        |                          |  .  .\n     *        |                          |  .  .\n     *        |                          |  .  .\n     *        |                          |  .  .\n     *  600px +--------------------------+  -  -\n     *\n     *  `percent_scroll` can be calculated from this value and `scrollTop`,\n     *  which we can then apply to the new calculated height to preserve scroll\n     *  position when the height has changed since previous render.\n     *\n     *    0px +--------------------------+  -\n     *        |                          |  .\n     *        |                          |  .\n     *        |                          |  . scrollable area\n     *  300px +------------+             |  .\n     *        |            |             |  .\n     *  - - - |  viewport  | - - - - - - |  - total_scroll_height\n     *        |            |             |    400px\n     *  500px +------------+             |\n     *        |                          |\n     *  600px +--------------------------+\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @param {*} nrows\n     * @param {*} reset_scroll_position\n     * @returns\n     */\n    _calculate_row_range(nrows, reset_scroll_position) {\n        const {height} = this._container_size;\n        const row_height = this._column_sizes.row_height || 19;\n        const header_levels = this._view_cache.config.column_pivots.length + 1;\n        // TODO use cached height?\n        const total_scroll_height = Math.max(1, this._virtual_panel.offsetHeight - this.clientHeight);\n        const percent_scroll = Math.max(this.scrollTop, 0) / total_scroll_height;\n        const virtual_panel_row_height = height / row_height;\n        const relative_nrows = !reset_scroll_position ? this._nrows || 0 : nrows;\n        const scroll_rows = Math.max(0, relative_nrows + (header_levels - virtual_panel_row_height));\n        let start_row = Math.ceil(scroll_rows * percent_scroll);\n        let end_row = Math.min(Math.ceil(start_row + virtual_panel_row_height), nrows);\n        return {start_row, end_row};\n    }\n\n    /**\n     * Calculates `start_col` and `end_col` for the viewport - most of the\n     * details of which are actually calculated in `_max_column`, the equivalent\n     * of `total_scroll_height` from `_calculate_row_range`.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @returns\n     */\n    _calculate_column_range(num_columns, invalid_columns) {\n        const total_scroll_width = Math.max(1, this._virtual_panel.offsetWidth - this._container_size.width);\n        const percent_left = this.scrollLeft / total_scroll_width;\n        const max_scroll_column = this._max_scroll_column(num_columns) + 0.5;\n        if (this._virtual_mode === \"none\" || this._virtual_mode === \"vertical\") {\n            return {start_col: 0, end_col: Infinity};\n        } else {\n            let start_col = Math.floor(max_scroll_column * percent_left);\n            const vis_cols = (!invalid_columns && this.table_model.num_columns()) || Math.min(num_columns, Math.ceil(this._container_size.width / 60));\n            let end_col = start_col + vis_cols + 1;\n            return {start_col, end_col};\n        }\n    }\n\n    /**\n     * Calculates the minimum possible starting column index for which the last\n     * column is completely visible (e.g. not occluded by the container clip).\n     * This is assumed to be the # of columns until the column widths are\n     * calculated as they are scrolled into view by the user, which requires\n     * special synchronization with _update_virtual_panel_width`\n     * as the scrollable width will change as the user scrolls left to right.\n     *\n     * Once `_column_sizes.indices` has enough column widths populated from\n     * user scrolling, it calulates the cumulative sum of column widths from\n     * last visible column backwards, until the sum is larger than the viewport\n     * px width, which is 1 below the max scroll column\n     *\n     *               width = 290   = 210     = 100    = 0\n     *   0px               V       V         V        500px\n     *   +-----------------+-------+---------+--------+\n     *   | ..ol B) (Col C) | Col D | Col E   | Col F  |\n     *   |                 | 80px  | 110px   | 100px  |\n     *   |                 |       |         |        |\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @returns\n     */\n    _max_scroll_column(num_columns) {\n        let width = 0;\n        if (this._view_cache.config.row_pivots.length > 0) {\n            for (const w of this._column_sizes.indices.slice(0, this._view_cache.config.row_pivots.length)) {\n                width += w;\n            }\n        }\n        let max_scroll_column = num_columns;\n        while (width < this._container_size.width && max_scroll_column >= 0) {\n            max_scroll_column--;\n            width += this._column_sizes.indices[max_scroll_column] || 60;\n        }\n        return Math.min(num_columns - 1, max_scroll_column + 1);\n    }\n\n    /**\n     * Determines whether the viewport is identical in row and column axes to\n     * the previous viewport rendered, for throttling identical render requests,\n     * e.g. when the logical (row-wise) viewport does not change, but the pixel\n     * viewport has moved a few px.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @param {*} {start_col, end_col, start_row, end_row}\n     * @returns\n     */\n    _validate_viewport({start_col, end_col, start_row, end_row}) {\n        const invalid_column = this._start_col !== start_col;\n        const invalid_row = this._start_row !== start_row || this._end_row !== end_row || this._end_col !== end_col;\n        this._start_col = start_col;\n        this._end_col = end_col;\n        this._start_row = start_row;\n        this._end_row = end_row;\n        return {invalid_column, invalid_row};\n    }\n\n    /**\n     * Updates the `virtual_panel` width based on view state.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @param {*} invalid\n     */\n    _update_virtual_panel_width(invalid, num_columns) {\n        if (invalid) {\n            if (this._virtual_mode === \"vertical\" || this._virtual_mode === \"none\") {\n                this._virtual_panel.style.width = this._column_sizes.indices.reduce((x, y) => x + y, 0) + \"px\";\n            } else {\n                const total_scroll_width = Math.max(1, this._virtual_panel.offsetWidth - this._container_size.width);\n                const percent_left = this.scrollLeft / total_scroll_width;\n                const max_scroll_column = this._max_scroll_column(num_columns);\n                let cidx = 0,\n                    virtual_width = 0;\n                while (cidx < max_scroll_column) {\n                    virtual_width += this._column_sizes.indices[cidx] || 60;\n                    cidx++;\n                }\n                const panel_width = this._container_size.width + virtual_width;\n                this._virtual_panel.style.width = panel_width + \"px\";\n                this.scrollLeft = percent_left * virtual_width;\n            }\n        }\n    }\n\n    /**\n     * Updates the `virtual_panel` height based on the view state.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @param {*} nrows\n     */\n    _update_virtual_panel_height(nrows) {\n        const {row_height = 19} = this._column_sizes;\n        const header_height = this.table_model.header.num_rows() * row_height;\n        let virtual_panel_px_size;\n        if (this._virtual_mode === \"horizontal\" || this._virtual_mode === \"none\") {\n            virtual_panel_px_size = nrows * row_height + header_height;\n        } else {\n            //const {height} = this._container_size;\n            // TODO use cached height?\n            const zoom_factor = this.clientHeight / (this._table_clip.offsetHeight - header_height);\n            virtual_panel_px_size = Math.min(BROWSER_MAX_HEIGHT, nrows * row_height * zoom_factor);\n        }\n        this._virtual_panel.style.height = `${virtual_panel_px_size}px`;\n    }\n\n    /**\n     * Draws this virtual panel, given an object of render options that allow\n     * the implementor to fine tune the individual render frames based on the\n     * interaction and previous render state.\n     *\n     * `reset_scroll_position` will not prevent the viewport from moving as\n     * `draw()` may change the dimensions of the virtual_panel (and thus,\n     * absolute scroll offset).  This calls `reset_scroll`, which will\n     * trigger `_on_scroll` and ultimately `draw()` again;  however, this call\n     * to `draw()` will be for the same viewport and will not actually cause\n     * a render.\n     *\n     * @public\n     * @memberof RegularVirtualTableViewModel\n     * @param {DrawOptions} [options]\n     * @param {boolean} [options.invalid_viewport=true]\n     * @param {boolean} [options.preserve_width=false]\n     * @param {boolean} [options.reset_scroll_position=false]\n     * @param {boolean} [options.swap=false]\n     * @returns\n     */\n    @throttlePromise\n    async draw(options = {}) {\n        const __debug_start_time__ = DEBUG && performance.now();\n        const {invalid_viewport = true, preserve_width = false, reset_scroll_position = false, invalid_columns = false} = options;\n\n        if (reset_scroll_position) {\n            this.reset_scroll();\n        }\n\n        this._invalid_schema = invalid_columns || this._invalid_schema;\n        const {num_columns, num_rows} = await this._view_cache.view(0, 0, 0, 0);\n        this._container_size = {\n            width: this._virtual_mode === \"none\" || this._virtual_mode === \"vertical\" ? Infinity : this._table_clip.clientWidth,\n            height: this._virtual_mode === \"none\" || this._virtual_mode === \"horizontal\" ? Infinity : this._table_clip.clientHeight,\n        };\n\n        const viewport = this._calculate_viewport(num_rows, num_columns, reset_scroll_position, invalid_columns);\n        const {invalid_row, invalid_column} = this._validate_viewport(viewport);\n        this._update_virtual_panel_height(num_rows);\n\n        if (this._invalid_schema || invalid_row || invalid_column || invalid_viewport || invalid_column) {\n            this.dispatchEvent(\n                new CustomEvent(\"regular-table-before-update\", {\n                    bubbles: true,\n                    detail: this,\n                })\n            );\n\n            let last_cells = [];\n            for await (last_cells of this.table_model.draw(this._container_size, this._view_cache, this._selected_id, preserve_width, viewport, num_columns)) {\n                this._is_styling = true;\n                const callbacks = this._style_callbacks;\n                for (const callback of callbacks) {\n                    await callback({detail: this});\n                }\n\n                this._is_styling = false;\n                if (!this._invalidated && last_cells !== undefined) {\n                    break;\n                }\n\n                this._invalidated = false;\n            }\n\n            this.table_model.autosize_cells(last_cells);\n            this.table_model.header.reset_header_cache();\n            if (!preserve_width) {\n                this._update_virtual_panel_width(this._invalid_schema || invalid_column || invalid_viewport, num_columns);\n            }\n            this._invalid_schema = false;\n        }\n\n        if (DEBUG) {\n            log_perf(performance.now() - __debug_start_time__);\n        }\n    }\n}\n\n/**\n * Options for the draw method.\n *\n * @typedef DrawOptions\n * @type {object}\n * @property {boolean} [invalid_viewport]\n * @property {boolean} [preserve_width]\n * @property {boolean} [reset_scroll_position]\n * @property {boolean} [swap]\n */\n","/******************************************************************************\n *\n * Copyright (c) 2020, the Regular Table Authors.\n *\n * This file is part of the Regular Table library, distributed under the terms\n * of the Apache License 2.0.  The full license can be found in the LICENSE\n * file.\n *\n */\n\nimport {METADATA_MAP} from \"./constants\";\nimport {RegularVirtualTableViewModel} from \"./scroll_panel\";\nimport {throttlePromise} from \"./utils\";\n\n/**\n *\n *\n * @class RegularViewEventModel\n * @extends {RegularVirtualTableViewModel}\n */\nexport class RegularViewEventModel extends RegularVirtualTableViewModel {\n    register_listeners() {\n        this.addEventListener(\"mousedown\", this._on_click.bind(this));\n        this.addEventListener(\"dblclick\", this._on_dblclick.bind(this));\n        this.addEventListener(\"scroll\", this._on_scroll.bind(this), {\n            passive: false,\n        });\n        this._register_glitch_scroll_listeners();\n    }\n\n    /**\n     *\n     * @internal\n     * @private\n     * @memberof RegularViewEventModel\n     * @returns\n     */\n    async _on_scroll(event) {\n        event.stopPropagation();\n        event.returnValue = false;\n        await this.draw({invalid_viewport: false});\n        this.dispatchEvent(new CustomEvent(\"regular-table-scroll\"));\n    }\n\n    /**\n     * Modern and mobile browsers implement complex scroll behavior to\n     * implement fancy touch and intertia effects;  these must be intercepted\n     * and disabled to achieve clean virtual scrolling in the presence of a\n     * `fixed` element.\n     *\n     * @internal\n     * @private\n     * @memberof RegularViewEventModel\n     */\n    _register_glitch_scroll_listeners() {\n        this.addEventListener(\"mousewheel\", this._on_mousewheel.bind(this), {\n            passive: false,\n        });\n        this.addEventListener(\"touchstart\", this._on_touchstart.bind(this), {\n            passive: false,\n        });\n        this.addEventListener(\"touchmove\", this._on_touchmove.bind(this), {\n            passive: false,\n        });\n    }\n\n    /**\n     * Mousewheel must precalculate in addition to `_on_scroll` to prevent\n     * visual artifacts due to scrolling \"inertia\" on modern browsers.\n     *\n     * @internal\n     * @private\n     * @memberof RegularViewEventModel\n     * @param {*} event\n     */\n    _on_mousewheel(event) {\n        if (!window.safari) {\n            // **** Apple\n            return;\n        }\n\n        const {clientWidth, clientHeight, scrollTop, scrollLeft, scrollHeight} = this;\n        if ((event.deltaY > 0 && scrollTop + clientHeight >= scrollHeight) || (event.deltaY < 0 && scrollTop <= 0)) {\n            event.preventDefault();\n            event.returnValue = false;\n            const total_scroll_height = Math.max(1, this._virtual_panel.offsetHeight - clientHeight);\n            const total_scroll_width = Math.max(1, this._virtual_panel.offsetWidth - clientWidth);\n            this.scrollTop = Math.min(total_scroll_height, scrollTop + event.deltaY);\n            this.scrollLeft = Math.min(total_scroll_width, scrollLeft + event.deltaX);\n            this._on_scroll(event);\n        }\n    }\n\n    /**\n     * Touchmove must precalculate in addition to `_on_scroll` to prevent\n     * visual artifacts due to scrolling \"inertia\" on mobile browsers.  This has\n     * the unfortunate side-effect of disabling scroll intertia, but the\n     * alternative is a dodgy, glitchy mess.\n     *\n     * @internal\n     * @private\n     * @memberof RegularViewEventModel\n     * @param {*} event\n     * @returns\n     */\n    _on_touchmove(event) {\n        event.preventDefault();\n        event.returnValue = false;\n        const {clientWidth, clientHeight, scrollTop, scrollLeft} = this;\n        const total_scroll_height = Math.max(1, this._virtual_panel.offsetHeight - clientHeight);\n        const total_scroll_width = Math.max(1, this._virtual_panel.offsetWidth - clientWidth);\n        this.scrollTop = Math.min(total_scroll_height, scrollTop + (this._memo_touch_startY - event.touches[0].screenY));\n        this.scrollLeft = Math.min(total_scroll_width, scrollLeft + (this._memo_touch_startX - event.touches[0].screenX));\n        this._on_scroll(event);\n    }\n\n    /**\n     * Memoize `touchstart` positions to calculate deltas, since these are not\n     * generated on `touchmove` events.\n     *\n     * @internal\n     * @private\n     * @memberof RegularViewEventModel\n     * @param {*} event\n     */\n    _on_touchstart(event) {\n        this._memo_touch_startY = event.touches[0].screenY;\n        this._memo_touch_startX = event.touches[0].screenX;\n    }\n\n    /**\n     * Handles double-click header width override reset.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @param {*} event\n     * @returns\n     */\n    async _on_dblclick(event) {\n        let element = event.target;\n        while (element.tagName !== \"TD\" && element.tagName !== \"TH\") {\n            element = element.parentElement;\n            if (!this.contains(element)) {\n                return;\n            }\n        }\n\n        const is_resize = event.target.classList.contains(\"rt-column-resize\");\n        const metadata = METADATA_MAP.get(element);\n        if (is_resize) {\n            event.stopImmediatePropagation();\n            // await new Promise(queueMicrotask);\n            element.style.minWidth = \"\";\n            element.style.maxWidth = \"\";\n            if (event.shiftKey) {\n                this._column_sizes.override = [];\n                this._column_sizes.auto = [];\n                this._column_sizes.indices = [];\n            } else {\n                delete this._column_sizes.override[metadata.size_key];\n                delete this._column_sizes.auto[metadata.size_key];\n                delete this._column_sizes.indices[metadata.size_key];\n            }\n\n            for (const row of event.shiftKey ? [this.table_model.header.cells[this.table_model.header.cells.length - 1], ...this.table_model.body.cells] : this.table_model.body.cells) {\n                for (const td of event.shiftKey ? row : [row[metadata._virtual_x]]) {\n                    if (!td) {\n                        continue;\n                    }\n\n                    td.style.minWidth = \"\";\n                    td.style.maxWidth = \"\";\n                    td.classList.remove(\"rt-cell-clip\");\n                }\n            }\n\n            await this.draw();\n        }\n    }\n\n    /**\n     * Dispatches all click events to other handlers, depending on\n     * `event.target`.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @param {*} event\n     * @returns\n     */\n    async _on_click(event) {\n        if (event.button !== 0) {\n            return;\n        }\n\n        let element = event.target;\n        while (element.tagName !== \"TD\" && element.tagName !== \"TH\") {\n            element = element.parentElement;\n            if (!this.contains(element)) {\n                return;\n            }\n        }\n\n        const is_resize = event.target.classList.contains(\"rt-column-resize\");\n        const metadata = METADATA_MAP.get(element);\n        if (is_resize) {\n            this._on_resize_column(event, element, metadata);\n            event.stopImmediatePropagation();\n        }\n    }\n\n    /**\n     * Regular event for column resize.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @param {*} event\n     * @param {*} element\n     * @param {*} metadata\n     */\n    _on_resize_column(event, element, metadata) {\n        const {_virtual_x, size_key} = metadata;\n        const start = event.pageX;\n        const header_x = _virtual_x + element.colSpan - 1;\n        const header_element = this.table_model.header.get_column_header(header_x);\n        const width = this._column_sizes.indices[size_key];\n        const move = (event) => this._on_resize_column_move(event, header_element, start, width, size_key, header_x);\n        const up = () => {\n            document.removeEventListener(\"mousemove\", move);\n            document.removeEventListener(\"mouseup\", up);\n            const override_width = this._column_sizes.override[size_key];\n            const should_redraw = this._column_sizes.indices[size_key] !== override_width;\n            this._column_sizes.indices[size_key] = override_width;\n            if (should_redraw) {\n                this.draw();\n            }\n        };\n\n        document.addEventListener(\"mousemove\", move);\n        document.addEventListener(\"mouseup\", up);\n    }\n\n    /**\n     * Regular event for mouse movement when resizing a column.\n     *\n     * @internal\n     * @private\n     * @memberof RegularVirtualTableViewModel\n     * @param {*} event\n     * @param {*} th\n     * @param {*} start\n     * @param {*} width\n     * @param {*} metadata\n     */\n    @throttlePromise\n    async _on_resize_column_move(event, th, start, width, size_key, virtual_x) {\n        await new Promise(setTimeout);\n        const diff = event.pageX - start;\n        const override_width = Math.max(1, width + diff);\n        this._column_sizes.override[size_key] = override_width;\n\n        // If the column is smaller, new columns may need to be fetched, so\n        // redraw, else just update the DOM widths as if redrawn.\n        if (diff < 0) {\n            await this.draw({preserve_width: true});\n        } else {\n            th.style.minWidth = override_width + \"px\";\n            th.style.maxWidth = override_width + \"px\";\n            const auto_width = this._column_sizes.auto[size_key];\n            for (const row of this.table_model.body.cells) {\n                const td = row[virtual_x];\n                if (td) {\n                    td.style.maxWidth = td.style.minWidth = override_width + \"px\";\n                    td.classList.toggle(\"rt-cell-clip\", auto_width > override_width);\n                }\n            }\n        }\n    }\n}\n","/******************************************************************************\n *\n * Copyright (c) 2020, the Regular Table Authors.\n *\n * This file is part of the Regular Table library, distributed under the terms\n * of the Apache License 2.0.  The full license can be found in the LICENSE\n * file.\n *\n */\n\nimport {METADATA_MAP} from \"./constants\";\nimport {RegularTableViewModel} from \"./table\";\nimport {RegularViewEventModel} from \"./events\";\nimport {get_draw_fps} from \"./utils\";\n\nconst VIRTUAL_MODES = [\"both\", \"horizontal\", \"vertical\", \"none\"];\n\n/**\n * The `<regular-table>` custom element.\n *\n * This module has no exports, but importing it has a side effect: the\n * `RegularTableElement` class is registered as a custom element, after which\n * it can be used as a standard DOM element.\n *\n * The documentation in this module defines the instance structure of a\n * `<regular-table>` DOM object instantiated typically, through HTML or any\n * relevent DOM method e.g. `document.createElement(\"perspective-viewer\")` or\n * `document.getElementsByTagName(\"perspective-viewer\")`.\n *\n * @public\n * @extends HTMLElement\n */\nclass RegularTableElement extends RegularViewEventModel {\n    /**\n     * For internal use by the Custom Elements API: \"Invoked each time the\n     * custom element is appended into a document-connected element\".\n     * Ref: https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks\n     *\n     * @internal\n     * @private\n     * @memberof RegularTableElement\n     */\n    connectedCallback() {\n        if (!this._initialized) {\n            this.create_shadow_dom();\n            this.register_listeners();\n            this.setAttribute(\"tabindex\", \"0\");\n            this._column_sizes = {auto: {}, override: {}, indices: []};\n            this._style_callbacks = [];\n            this.table_model = new RegularTableViewModel(this._table_clip, this._column_sizes, this);\n            this._initialized = true;\n        }\n    }\n\n    /**\n     * Reset the viewport of this regular table.\n     *\n     * @internal\n     * @private\n     * @memberof RegularTableElement\n     */\n    _reset_viewport() {\n        this._start_row = undefined;\n        this._end_row = undefined;\n        this._start_col = undefined;\n        this._end_col = undefined;\n    }\n\n    /**\n     * Reset the scroll position of this regular table back to the origin.\n     *\n     * @internal\n     * @private\n     * @memberof RegularTableElement\n     */\n    _reset_scroll() {\n        this._column_sizes.indices = [];\n        this.scrollTop = 0;\n        this.scrollLeft = 0;\n        this._reset_viewport();\n    }\n\n    /**\n     * Reset column autosizing, such that column sizes will be recalculated\n     * on the next draw() call.\n     *\n     * @internal\n     * @private\n     * @memberof RegularTableElement\n     */\n    _resetAutoSize() {\n        this._column_sizes.auto = {};\n        this._column_sizes.override = {};\n        this._column_sizes.indices = [];\n\n        for (let i = 0; i < this.table_model.header.num_columns(); i++) {\n            const th = this.table_model.header.get_column_header(i);\n            th.style.minWidth = \"\";\n            th.style.maxWidth = \"\";\n        }\n    }\n\n    /**\n     * Clears the current renderer `<table>`.\n     *\n     * @public\n     * @memberof RegularTableElement\n     */\n    clear() {\n        this.table_model = new RegularTableViewModel(this._table_clip, this._column_sizes, this);\n    }\n\n    /**\n     * Adds a style listener callback. The style listeners are called\n     * whenever the <table> is re-rendered, such as through API invocations\n     * of draw() and user-initiated events such as scrolling. Within this\n     * optionally async callback, you can select <td>, <th>, etc. elements\n     * via regular DOM API methods like querySelectorAll().\n     *\n     * @public\n     * @memberof RegularTableElement\n     * @param {function({detail: RegularTableElement}): void} styleListener - A\n     * (possibly async) function that styles the inner <table>.\n     * @returns {function(): void} A function to remove this style listener.\n     * @example\n     * const unsubscribe = table.addStyleListener(() => {\n     *     for (const td of table.querySelectorAll(\"td\")) {\n     *         td.setAttribute(\"contenteditable\", true);\n     *     }\n     * });\n     *\n     * setTimeout(() => {\n     *     unsubscribe();\n     * }, 1000);\n     */\n    addStyleListener(styleListener) {\n        this._style_callbacks = this._style_callbacks.concat(styleListener);\n\n        let isSubscribed = true;\n\n        const unsubscribe = () => {\n            if (!isSubscribed) {\n                return;\n            }\n            isSubscribed = false;\n\n            const callbacks = (this._style_callbacks = this._style_callbacks.slice());\n            const index = callbacks.indexOf(styleListener);\n            callbacks.splice(index, 1);\n        };\n        return unsubscribe;\n    }\n\n    /**\n     * When called within the execution scope of a function registered to this\n     * `<regular-table>` as a `StyleListener`, invalidate this draw's\n     * dimensions and attempt to draw more columns.  Useful if your\n     * `StyleListener` changes a cells dimensions, otherwise `<regular-table>`\n     * may not draw enough columns to fill the screen.\n     */\n    invalidate() {\n        if (!this._is_styling) {\n            throw new Error(\"Cannot call `invalidate()` outside of a `StyleListener`\");\n        }\n        this._invalidated = true;\n    }\n\n    /**\n     * Returns the `MetaData` object associated with a `<td>` or `<th>`.  When\n     * your `StyleListener` is invoked, use this method to look up additional\n     * `MetaData` about any `HTMLTableCellElement` in the rendered `<table>`.\n     *\n     * @public\n     * @memberof RegularTableElement\n     * @param {HTMLTableCellElement|Partial<MetaData>} element - The child element\n     * of this `<regular-table>` for which to look up metadata, or a\n     * coordinates-like object to refer to metadata by logical position.\n     * @returns {MetaData} The metadata associated with the element.\n     * @example\n     * const elems = document.querySelector(\"td:last-child td:last_child\");\n     * const metadata = table.getMeta(elems);\n     * console.log(`Viewport corner is ${metadata.x}, ${metadata.y}`);\n     * @example\n     * const header = table.getMeta({row_header_x: 1, y: 3}).row_header;\n     */\n    getMeta(element) {\n        if (typeof element === \"undefined\") {\n            return;\n        } else if (element instanceof HTMLElement) {\n            return METADATA_MAP.get(element);\n        } else if (element.row_header_x >= 0) {\n            if (element.row_header_x < this._view_cache.config.row_pivots.length) {\n                const td = this.table_model.body._fetch_cell(element.y, element.row_header_x);\n                return this.getMeta(td);\n            }\n        } else if (element.column_header_y >= 0) {\n            if (element.column_header_y < this._view_cache.config.column_pivots.length) {\n                const td = this.table_model.body._fetch_cell(element.column_header_y, element.y);\n                return this.getMeta(td);\n            }\n        } else {\n            return this.getMeta(this.table_model.body._fetch_cell(element.dy, element.dx + this.table_model._row_headers_length));\n        }\n    }\n\n    /**\n     * Get performance statistics about this `<regular-table>`.  Calling this\n     * method resets the internal state, which makes it convenient to measure\n     * performance at regular intervals (see example).\n     *\n     * @public\n     * @memberof RegularTableElement\n     * @returns {Performance} Performance data aggregated since the last\n     * call to `getDrawFPS()`.\n     * @example\n     * const table = document.getElementById(\"my_regular_table\");\n     * setInterval(() => {\n     *     const {real_fps} = table.getDrawFPS();\n     *     console.log(`Measured ${fps} fps`)\n     * });\n     */\n    getDrawFPS() {\n        return get_draw_fps();\n    }\n\n    /**\n     * Call this method to set the `scrollLeft` and `scrollTop` for this\n     * `<regular-table>` by calculating the position of this `scrollLeft`\n     * and `scrollTop` relative to the underlying widths of its columns\n     * and heights of its rows.\n     *\n     * @public\n     * @memberof RegularTableElement\n     * @param {number} x - The left most `x` index column to scroll into view.\n     * @param {number} y - The top most `y` index row to scroll into view.\n     * @param {number} ncols - Total number of columns in the data model.\n     * @param {number} nrows - Total number of rows in the data model.\n     * @example\n     * table.scrollToCell(1, 3, 10, 30);\n     */\n    async scrollToCell(x, y, ncols, nrows) {\n        const row_height = this._virtual_panel.offsetHeight / nrows;\n        this.scrollTop = row_height * y;\n        this.scrollLeft = (x / (this._max_scroll_column(ncols) || ncols)) * (this.scrollWidth - this.clientWidth);\n        await this.draw.flush();\n    }\n\n    /**\n     * Call this method to set `DataListener` for this `<regular-table>`,\n     * which will be called whenever a new data slice is needed to render.\n     * Calls to `draw()` will fail if no `DataListener` has been set\n     *\n     * @public\n     * @memberof RegularTableElement\n     * @param {DataListener} dataListener\n     * `dataListener` is called by to request a rectangular section of data\n     * for a virtual viewport, (x0, y0, x1, y1), and returns a `DataReponse`\n     * object.\n     * @param {Options} options.virtual_mode\n     * The `virtual_mode` options flag may be one of \"both\", \"horizontal\",\n     * \"vertical\", or \"none\" indicating which dimensions of the table should be\n     * virtualized (vs. rendering completely).\n     * @example\n     * table.setDataListener((x0, y0, x1, y1) => {\n     *     return {\n     *         num_rows: num_rows = DATA[0].length,\n     *         num_columns: DATA.length,\n     *         data: DATA.slice(x0, x1).map(col => col.slice(y0, y1))\n     *     };\n     * })\n     */\n    setDataListener(dataListener, {virtual_mode = \"both\"} = {}) {\n        let schema = {};\n        let config = {\n            row_pivots: [],\n            column_pivots: [],\n        };\n\n        console.assert(VIRTUAL_MODES.indexOf(virtual_mode) > -1, `Unknown virtual_mode ${virtual_mode};  valid options are \"both\" (default), \"horizontal\", \"vertical\" or \"none\"`);\n        this._virtual_mode = virtual_mode;\n        this._invalid_schema = true;\n        this._view_cache = {view: dataListener, config, schema};\n        this._setup_virtual_scroll();\n    }\n}\n\nif (document.createElement(\"regular-table\").constructor === HTMLElement) {\n    window.customElements.define(\"regular-table\", RegularTableElement);\n}\n\n/**\n * An object with performance statistics about calls to\n * `draw()` from some time interval (captured in milliseconds by the\n * `elapsed` proprty).\n *\n * @typedef Performance\n * @type {object}\n * @property {number} avg - Avergage milliseconds per call.\n * @property {number} real_fps - `num_frames` / `elapsed`\n * @property {number} virtual_fps - `elapsed` / `avg`\n * @property {number} num_frames - Number of frames rendered.\n * @property {number} elapsed - Number of milliseconds since last call\n * to `getDrawFPS()`.\n */\n\n/**\n * An object describing virtual rendering metadata about an\n * `HTMLTableCellElement`, use this object to map rendered `<th>` or `<td>`\n * elements back to your `data`, `row_headers` or `column_headers` within\n * listener functions for `addStyleListener()` and `addEventListener()`.\n * @example\n *\n * MetaData                     (x = 0, column_header_y = 0))\n *                              *-------------------------------------+\n *                              |                                     |\n *                              |                                     |\n *                              +-------------------------------------+\n * (row_header_x = 0, y = 0)    (x = 0, y = 0)\n * *------------------------+   *-------------------------------------+\n * |                        |   |                                     |\n * |                        |   |      (x0, y0)                       |\n * |                        |   |      *---------------*              |\n * |                        |   |      |               |              |\n * |                        |   |      |     * (x, y)  |              |\n * |                        |   |      |               |              |\n * |                        |   |      *---------------* (x1, y1)     |\n * |                        |   |                                     |\n * +------------------------+   +-------------------------------------+\n *\n * @typedef MetaData\n * @type {object}\n * @property {number} [x] - The `x` index in your virtual data model.\n * property is only generated for `<td>`, `<th>` from `row_headers`.\n * @property {number} [y] - The `y` index in your virtual data model.\n * property is only generated for `<td>`, `<th>` from `row_headers`.\n * @property {number} [x0] - The `x` index of the viewport origin in\n * your data model, e.g. what was passed to `x0` when your\n * `dataListener` was invoked.\n * @property {number} [y0] - The `y` index of the viewport origin in\n * your data model, e.g. what was passed to `y0` when your\n * `dataListener` was invoked.\n * @property {number} [x1] - The `x` index of the viewport corner in\n * your data model, e.g. what was passed to `x1` when your\n * `dataListener` was invoked.\n * @property {number} [y1] - The `y` index of the viewport corner in\n * your data model, e.g. what was passed to `y1` when your\n * `dataListener` was invoked.\n * @property {number} [dx] - The `x` index in `DataResponse.data`, this\n * property is only generated for `<td>`, and `<th>` from `column_headers`.\n * @property {number} [dy] - The `y` index in `DataResponse.data`, this\n * property is only generated for `<td>`, `<th>` from `row_headers`.\n * @property {number} [column_header_y] - The `y` index in\n * `DataResponse.column_headers[x]`, this property is only generated for `<th>`\n * from `column_headers`.\n * @property {number} [row_header_x] - The `x` index in\n * `DataResponse.row_headers[y]`, this property is only generated for `<th>`\n * from `row_headers`.\n * @property {number} size_key - The unique index of this column in a full\n * `<table>`, which is `x` + (Total Row Header Columns).\n * @property {Array<object>} [row_header] - The `Array` for this `y` in\n * `DataResponse.row_headers`, if it was provided.\n * @property {Array<object>} [column_header] - The `Array` for this `x` in\n * `DataResponse.column_headers`, if it was provided.\n * @property {object} [value] - The value dispalyed in the cell or header.\n */\n\n/**\n * The `DataResponse` object describes a rectangular region of a virtual\n * data set, and some associated metadata.  `<regular-table>` will use this\n * object to render the `<table>`, though it may make multiple requests for\n * different regions to achieve a compelte render as it must estimate\n * certain dimensions.  You must construct a `DataResponse` object to\n * implement a `DataListener`.\n *\n * @typedef DataResponse\n * @type {object}\n * @property {Array<Array<object>>} [column_headers] - A two dimensional\n * `Array` of column group headers, in specificity order.  No `<thead>`\n * will be generated if this property is not provided.\n * @property {Array<Array<object>>} [row_headers] - A two dimensional\n * `Array` of row group headers, in specificity order.  No `<th>`\n * elements within `<tbody>` will be generated if this property is not\n * provided.\n * @property {Array<Array<object>>} data - A two dimensional `Array`\n * representing a rectangular section of the underlying data set from\n * (x0, y0) to (x1, y1), arranged in columnar fashion such that\n * `data[x][y]` returns the `y`th row of the `x`th column of the slice.\n * @property {number} num_rows - Total number of rows in the underlying\n * data set.\n * @property {number} num_columns - Total number of columns in the\n * underlying data set.\n * @example\n * {\n *     \"num_rows\": 26,\n *     \"num_columns\": 3,\n *     \"data\": [\n *         [0, 1],\n *         [\"A\", \"B\"]\n *     ],\n *     \"row_headers\": [\n *         [\"Rowgroup 1\", \"Row 1\"],\n *         [\"Rowgroup 1\", \"Row 2\"]\n *     ],\n *     \"column_headers\": [\n *         [\"Colgroup 1\", \"Column 1\"],\n *         [\"Colgroup 1\", \"Column 2\"]\n *     ]\n * }\n */\n\n/**\n * The `DataListener` is similar to a normal event listener function.\n * Unlike a normal event listener, it takes regular arguments (not an\n * `Event`); and returns a `Promise` for a `DataResponse` object for this\n * region (as opposed to returning `void` as a standard event listener).\n *\n * @callback DataListener\n * @param {number} x0 - The origin `x` index (column).\n * @param {number} y0 - The origin `y` index (row).\n * @param {number} x1 - The corner `x` index (column).\n * @param {number} y1 - The corner `y` index (row).\n * @returns {Promise<DataResponse>} The resulting `DataResponse`.  Make sure\n * to `resolve` or `reject` the `Promise`, or your `<regular-table>` will\n * never render!\n */\n"],"names":["METADATA_MAP","WeakMap","BROWSER_MAX_HEIGHT","navigator","userAgent","toLowerCase","indexOf","ViewModel","constructor","column_sizes","container","table","_column_sizes","_container","cells","rows","num_columns","this","_get_row","Math","max","length","row_container","num_rows","_set_metadata","td","metadata","set","_get_or_create_metadata","undefined","has","get","_replace_cell","ridx","cidx","tr","removeChild","splice","_fetch_cell","_get_cell","tag","document","createElement","insertBefore","slice","find","x","appendChild","tagName","new_td","replaceChild","_clean_columns","i","idx","filter","children","_clean_rows","RegularHeaderViewModel","_draw_group_th","offset_cache","d","column","th","removeAttribute","style","minWidth","textContent","HTMLElement","span","resizeSpan","className","_draw_group","column_name","column_header","value","_draw_th","size_key","override_width","override","auto_width","auto","classList","toggle","maxWidth","remove","get_column_header","draw","alias","parts","colspan","x0","_virtual_x","header_levels","_offset_cache","_group_header_cache","row_header_x","setAttribute","group_meta","column_header_y","clean","reset_header_cache","RegularBodyViewModel","_draw_td","val","ridx_offset","y","container_height","column_state","view_state","column_data","row_headers","column_data_listener_metadata","row_height","tds","cidx_offset","row_headers_length","id","obj","row_header","prev_row","prev_row_metadata","prev_col","prev_col_metadata","hasAttribute","display","y0","y1","user","x1","dx","dy","_obj","offsetHeight","AVG","TOTAL","START","performance","now","html","strings","args","map","str","flat","a","join","throttlePromise","target","property","descriptor","lock","Symbol","f","async","result","_resolve","promise","Promise","resolve","invertPromise","call","l","flush","RegularTableViewModel","table_clip","element","clear","thead","tbody","header","body","fragment","createDocumentFragment","innerHTML","autosize_cells","last_cells","cell","row_height_cell","pop","offsetWidth","getComputedStyle","boxSizing","clientWidth","parseFloat","paddingLeft","paddingRight","indices","is_override","hasOwnProperty","container_size","view_cache","selected_id","preserve_width","viewport","width","container_width","height","view","config","data","column_headers","data_listener_metadata","start_col","start_row","end_col","end_row","_row_headers_length","reduce","column_pivots","Array","from","keys","row_pivots","viewport_width","cont_body","first_col","cont_heads","push","fill","total","hmetadata","dcidx","num_visible_columns","missing_cidx","end_col_offset","size_extension","estimate","min","new_col_req","new_col","_new_col$column_heade","cont_head","last_measured_col_width","_y$td","RegularVirtualTableViewModel","create_shadow_dom","attachShadow","mode","shadowRoot","virtual_panel","_table_clip","_virtual_panel","_setup_virtual_scroll","_virtual_mode","top","left","_calculate_viewport","nrows","reset_scroll_position","invalid_columns","_calculate_row_range","_calculate_column_range","_nrows","_container_size","_view_cache","total_scroll_height","clientHeight","percent_scroll","scrollTop","virtual_panel_row_height","relative_nrows","scroll_rows","ceil","total_scroll_width","percent_left","scrollLeft","max_scroll_column","_max_scroll_column","Infinity","floor","table_model","w","_validate_viewport","invalid_column","_start_col","invalid_row","_start_row","_end_row","_end_col","_update_virtual_panel_width","invalid","virtual_width","panel_width","_update_virtual_panel_height","header_height","virtual_panel_px_size","zoom_factor","options","__debug_start_time__","invalid_viewport","reset_scroll","_invalid_schema","dispatchEvent","CustomEvent","bubbles","detail","_selected_id","_is_styling","callbacks","_style_callbacks","callback","_invalidated","RegularViewEventModel","register_listeners","addEventListener","_on_click","bind","_on_dblclick","_on_scroll","passive","_register_glitch_scroll_listeners","event","stopPropagation","returnValue","_on_mousewheel","_on_touchstart","_on_touchmove","window","safari","scrollHeight","deltaY","preventDefault","deltaX","_memo_touch_startY","touches","screenY","_memo_touch_startX","screenX","parentElement","contains","is_resize","stopImmediatePropagation","shiftKey","row","button","_on_resize_column","start","pageX","header_x","colSpan","header_element","move","_on_resize_column_move","up","removeEventListener","should_redraw","virtual_x","setTimeout","diff","VIRTUAL_MODES","RegularTableElement","connectedCallback","_initialized","_reset_viewport","_reset_scroll","_resetAutoSize","addStyleListener","styleListener","concat","isSubscribed","index","invalidate","Error","getMeta","getDrawFPS","elapsed","avg","real_fps","num_frames","virtual_fps","get_draw_fps","ncols","scrollWidth","setDataListener","dataListener","virtual_mode","console","assert","schema","customElements","define"],"mappings":"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"}